<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨一瓶</title>
  
  <subtitle>非常に広い肩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-05T02:41:47.139Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yangyiqing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017 CCF 大数据竞赛top4%</title>
    <link href="http://yoursite.com/2088/01/20/2017CCF/"/>
    <id>http://yoursite.com/2088/01/20/2017CCF/</id>
    <published>2088-01-19T16:00:00.000Z</published>
    <updated>2018-02-05T02:41:47.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2017-CCF-大数据竞赛思路及源码分享"><a href="#2017-CCF-大数据竞赛思路及源码分享" class="headerlink" title="2017 CCF 大数据竞赛思路及源码分享"></a>2017 CCF 大数据竞赛思路及源码分享</h1><p><strong><a href="https://github.com/NeoAlex18up" target="_blank" rel="noopener">源码见我的Github</a> </strong>比赛：蚂蚁金服：精准室内定位**，线下赛最终经过作弊筛选后是前100，共有2845支队伍，因为当时和小伙伴都不太会MapReduce，加上还有两个周期末考试了然而我为了比赛完全没有复习，所以复赛就弃了。</p><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给出用户在商场使用手机支付时所采集到的信息，包括用户信息，店铺信息，商场信息等，要求预测给出上述信息后精准预测用户所在店铺。具体给出的数据表可以点击<a href="https://tianchi.aliyun.com/competition/information.htm?spm=5176.100067.5678.2.647adc0v8Xce5&amp;raceId=231620" target="_blank" rel="noopener">这里</a>来看。</p><h2 id="2-大致分析与思路"><a href="#2-大致分析与思路" class="headerlink" title="2.大致分析与思路"></a>2.大致分析与思路</h2><p>虽然给出了比较多的信息，包括很多的用户信息和商店类别之类的看似有用的信息，但是做过这个比赛的都知道，其实是一个Wifi定位的问题，当然其他的信息经过正确的特征提取也会给模型带来增益，但是绝大程度上的精确度都是由wifi信息来提供的。所以，如何有效的提取wifi信息，去除其中的噪音，构造与wifi信息相关的特征，就是比赛的关键。</p><h2 id="3-具体做法"><a href="#3-具体做法" class="headerlink" title="3.具体做法"></a>3.具体做法</h2><h3 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1.数据预处理"></a>1.数据预处理</h3><ul><li>删除公共wifi，因为本题中给出了mall信息，当两个mall距离较远的情况下，同一个wifiId在这两个mall或多个mall都出现过的话，那么就可以判定这个wifiId是公共wifi或者是个人热点。</li><li>训练集和测试集wifi取交集，因为对于wifi指纹或我们后来构造的wifi特征来说，只在train中出现过或只在test中出现过的wifi都是无用的，甚至可能是噪音。</li><li>离群值的去除，没发现有什么离群点，部分wifi强度值有缺失，这里没有进行处理，因为模型对缺失值自动处理的效果比较好<h3 id="2-经纬度信息"><a href="#2-经纬度信息" class="headerlink" title="2.经纬度信息"></a>2.经纬度信息</h3>给了两种经纬度信息，一种是店铺经纬度（固定值），一种是买家付款时的经纬度，两种经纬度理论上差距应该很小，实际部分差距很大<br><img src="img/data.png" alt="pic1"></li><li>通过对精度的调整做了一个小的离散化处理</li><li>欧氏距离特征</li><li>曼哈顿距离特征</li><li>经纬度聚类（效果一般）<h3 id="3-时间特征的处理"><a href="#3-时间特征的处理" class="headerlink" title="3.时间特征的处理"></a>3.时间特征的处理</h3></li><li>提取饭点特征</li><li>提取早晨和深夜指示特征，因为这两种店可能比较固定<h3 id="4-用户特征"><a href="#4-用户特征" class="headerlink" title="4.用户特征"></a>4.用户特征</h3></li><li>用户购买力</li><li>用户常去商店<br>这里的用户特征是个坑，奥斯卡之夜也有人演过这一出，用户特征的提取会使得本地验证的分数提高不少，但是实际上可能是个噪音，因为测试集里的用户更换了绝大多数，记得好像只有不到1/5之一的旧用户吧，但是在训练集里用户特征会占很高的重要性，所以在将来会出现一些预测上的偏差，它们是要负责任的。<h3 id="5-Wifi特征"><a href="#5-Wifi特征" class="headerlink" title="5.Wifi特征"></a>5.Wifi特征</h3>wifi特征是最主要的部分，这里我们主要构建了如下的wifi特征<br><strong>(1)当前用户连接到的最强wifi</strong><br>转换成规则的话其实是一个极大似然估计，举个例子来说，当我能搜索到的最强wifi是wifi0的时候，在历史上最强wifi是wifi0的时候有80个人在A店铺，5个人在B店铺，10个人在C店铺，那么我最大可能当前在A店铺。这个特征算是一个比较强的特征了。<br><strong>(2)wifi出现的次数</strong><br>搜索到的wifi数，wifi历史计数<br><strong>(3)店铺wifi指纹</strong><br>根据每个店铺历史上出现过的wifi和强度建立wifi强度指纹库，取每个wifi出现过的所有值得中位数作为最终指纹值，比对当前强度wifi和指纹库<br><strong>(4)商场wifi原点</strong><br>根据整个商场历史上出现过的wifi和强度（统计频率，只取出现频率前50的wiif）建立一个原点wiif，计算每条数据wiif的wifi序列到wifi原点的欧氏距离<br><strong>(5)高频wifi强度特征</strong><br>也是先统计所有wifi出现过的次数，选其中出现频率高的wifi，每一个wifi及其强度作为一个特征，效果较好。<br><strong>后处理</strong>除了特征以外，还用了一些简单的规则来对预测数据进行后处理，相对于模型预测来说，后处理可处理的数据很少，但是相对于模型来说更加准确。</li><li>wiif强度序列完全相同</li><li>当前连接的wifi在历史上所在店铺的极大似然<br>其实在作比赛的时候远远试了比这些更多的特征，但是因为效果不好都去掉了，最后提交模型一共使用了以上特征。<h2 id="4-数据集划分"><a href="#4-数据集划分" class="headerlink" title="4.数据集划分"></a>4.数据集划分</h2>因为这是个时间相关的预测问题，所以应该和大多数人一样，最终我选取了最后一个周进行训练，特征提取是在整个训练集上进行的<h2 id="5-模型"><a href="#5-模型" class="headerlink" title="5.模型"></a>5.模型</h2>最开始我们使用了xgb的多分类模型，分mall进行预测，效果一般，然后转而使用二分类实现多分类，依然分mall进行预测，提升显著。<br>具体做法是使用N个二分类器，分别对每个mall的每个店铺进行二分类得到一个二分类器，然后对数据进行预测，这样对于每一个二分类器都可以得到一个预测概率值，选取其中预测最大的概率值对应的店铺作为最终分类结果。</li></ul><table><thead><tr><th>样本</th><th style="text-align:right">分类器1</th><th style="text-align:center">分类器2</th></tr></thead><tbody><tr><td>1</td><td style="text-align:right">0.12</td><td style="text-align:center">0.131</td></tr><tr><td>2</td><td style="text-align:right">0.13</td><td style="text-align:center">0.03</td></tr><tr><td>3</td><td style="text-align:right">0.94</td><td style="text-align:center">0.001</td></tr></tbody></table><p>大概就是表格里这种（值是我瞎写的）<br>这样做的好处还有一个是模型融合的时候会很快捷和高效，直接将模型概率加权相加即可<br><strong>模型融合:</strong>最后我们取了 0.65<em>xgb + 0.35</em>lgb 加权融合</p><p>就写这么多，比赛过去两个月了好多东西都忘了，以后想到再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;比赛记录和思路&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="比赛" scheme="http://yoursite.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2017-JDD京东金融算法大赛15th解决方案</title>
    <link href="http://yoursite.com/2088/01/20/2017JDD/"/>
    <id>http://yoursite.com/2088/01/20/2017JDD/</id>
    <published>2088-01-19T16:00:00.000Z</published>
    <updated>2018-02-03T09:25:40.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDD-2017"><a href="#JDD-2017" class="headerlink" title="JDD-2017"></a>JDD-2017</h1><p><strong>JDD-2017 京东金融大数据竞赛-销量预测-15th解决方案</strong><br><img src="http://i2.bvimg.com/620746/68825dc4d75e71fcs.png" alt="Markdown"></p><h2 id="比赛说明"><a href="#比赛说明" class="headerlink" title="比赛说明"></a>比赛说明</h2><p>通过竞赛数据中店铺过往的销售记录，商品信息，商品评价，以及广告费用等信息来建立预测模型，预测店铺未来90天内的销售额。<br>训练数据包含2017-04-30日之前270天之内若干店铺的每日订单量、销售额、顾客数、评价数、广告费用等数据，下架时间在2017-04-30之后或者未下架的商品数据，以及这些店铺2016年6月-2017年1月每月末后90天内的销售额。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>特殊的数据主要包含以下几部分</p><ul><li><strong>活动促销</strong>：比如双11和618</li><li><strong>特殊月份</strong>：比如过年前后</li><li><strong>店铺刷单</strong>：有些店铺平时销量很低，会有几天莫名其妙的很高</li><li><strong>下降商品</strong>：某些店铺会在短时间内下架大量的商品</li></ul><h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p>我们试过非常多的方案，最终选择了使用一个月作为训练区间，该月的前三个月作为特征提取区间</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="商品特征"><a href="#商品特征" class="headerlink" title="商品特征"></a>商品特征</h3><ul><li>在售总商品数</li><li>平均每个商品的订单量</li><li>平均每个商品的实际销量</li><li>平均每个商品的退货订单数</li><li>未售商品占总商品的比例</li></ul><h3 id="订单特征"><a href="#订单特征" class="headerlink" title="订单特征"></a>订单特征</h3><ul><li>总销售金额</li><li>平均每个订单销售金额</li><li>总优惠金额</li><li>平均每笔订单优惠金额</li><li>总优惠金额占总销售金额比</li><li>总订单量</li><li>总退货订单量</li><li>总实际订单量</li><li>总退货订单金额</li><li>退货金额占总销售额金额的比</li><li>总实际销售金额</li><li>平均每笔订单实际销售金额</li><li>总顾客数</li><li>平均每个顾客的订单量</li><li>平均每个顾客的购买金额</li><li>平均每个顾客的退货订单数</li><li>平均每个顾客的退货金额</li><li>总优惠笔数</li><li>总优惠金额占总退货金额比例</li><li>平均每笔订单总优惠金额占总退货金额比例</li><li>平均每笔优惠金额</li><li>平均销售金额增长率（每个月和前一个月算增长率，所有增长率取平均）</li><li>平均订单量增长率</li><li>平均退货订单增长率</li><li>平均退货金额增长率</li></ul><h3 id="评价特征（取平均的时候是按照有效评论日期取平均）"><a href="#评价特征（取平均的时候是按照有效评论日期取平均）" class="headerlink" title="评价特征（取平均的时候是按照有效评论日期取平均）"></a>评价特征（取平均的时候是按照有效评论日期取平均）</h3><ul><li>总好评数</li><li>总中评数</li><li>总差评数</li><li>总评论数</li><li>平均好评数</li><li>平均中评数</li><li>平均差评数</li><li>好评率</li><li>差评率</li><li>中评率</li><li>平均好评率增长率</li></ul><h3 id="交叉特征"><a href="#交叉特征" class="headerlink" title="交叉特征"></a>交叉特征</h3><ul><li>平均每个月的充值广告费用占总销售金额比</li><li>平均每个月的充值广告费用占实际销售金额比</li><li>平均每个订单的好评率</li><li>平均每个订单的差评率</li><li>平均每个订单的好评数</li><li>平均每个订单的差评数</li></ul><h3 id="销售额和下架特征"><a href="#销售额和下架特征" class="headerlink" title="销售额和下架特征"></a>销售额和下架特征</h3><ul><li>总销售额</li><li>当月销售额</li><li>前一个月总销售金额</li><li>前两个月总销售金额</li><li>前三个月总销售金额</li><li>前一个周总销售金额</li><li>前两个周总销售金额</li><li>前三个周总销售金额</li><li>前一个月下架商品数</li><li>前两个月下架商品数</li><li>前三个月下架商品数</li><li>最近一周下架商品数</li></ul><p>一开始加的特征比较多，因为效果还不错吧，所以也没有根据线上去判断一下哪些特征是否有用，而且这个比赛想构建一个比较稳定的线下验证是非常困难的，因为销量波动还是比较大的，所以更多的时候是以线上来验证我的一些想法。根据特征的重要性来看，跟销售金额有关的特征比较强一些，某些特征重要性非常低但是我也没删除。</p><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>因为某些店铺的销量波动实在是太大了，所以除了预测销量的模型之外，我还尝试构建了一个二分类模型，主要来区别销量比较平稳和销量波动很大的商铺，所以最终的模型为：<br><img src="http://i2.bvimg.com/620746/1b1eaf565bb477cas.png" alt="Markdown"></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;比赛记录和思路&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="比赛" scheme="http://yoursite.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow</title>
    <link href="http://yoursite.com/2088/01/20/Tensorflow%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2088/01/20/Tensorflow笔记/</id>
    <published>2088-01-19T16:00:00.000Z</published>
    <updated>2018-02-03T08:14:04.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用flags定义命令行参数"><a href="#使用flags定义命令行参数" class="headerlink" title="使用flags定义命令行参数"></a>使用flags定义命令行参数</h1><p>flag在TensorFlow中用于定义命令行参数<br><a href="http://blog.csdn.net/leiting_imecas/article/details/72367937" target="_blank" rel="noopener">参考链接</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一个是参数名称，第二个参数是默认值，第三个是参数描述</span></span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">'str_name'</span>, <span class="string">'def_v_1'</span>,<span class="string">"descrip1"</span>)</span><br><span class="line">tf.app.flags.DEFINE_integer(<span class="string">'int_name'</span>, <span class="number">10</span>,<span class="string">"descript2"</span>)</span><br><span class="line">tf.app.flags.DEFINE_boolean(<span class="string">'bool_name'</span>, <span class="keyword">False</span>, <span class="string">"descript3"</span>)</span><br><span class="line"></span><br><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须带参数，否则：'TypeError: main() takes no arguments (1 given)';   main的参数名随意定义，无要求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span>  </span><br><span class="line">    print(FLAGS.str_name)</span><br><span class="line">    print(FLAGS.int_name)</span><br><span class="line">    print(FLAGS.bool_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tf.app.run()  <span class="comment">#执行main函数</span></span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@AliHPC-G41<span class="number">-211</span> test]<span class="comment"># python tt.py</span></span><br><span class="line">def_v_1</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">[root@AliHPC-G41<span class="number">-211</span> test]<span class="comment"># python tt.py --str_name test_str --int_name 99 --bool_name True</span></span><br><span class="line">test_str</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="Tensorflow实现线性回归"><a href="#Tensorflow实现线性回归" class="headerlink" title="Tensorflow实现线性回归"></a>Tensorflow实现线性回归</h1><p>(本习题也是港大深度学习的第一次作业)</p><h2 id="线性回归原理"><a href="#线性回归原理" class="headerlink" title="线性回归原理"></a>线性回归原理</h2><p><strong>单变量线性回归</strong></p><ul><li>因为是线性回归，所以学习到的函数为线性函数，即直线函数</li><li>因为是单变量，因此只有一个x<br>我们能够给出单变量线性回归的模型：<br><img src="http://img.blog.csdn.net/20161006121754312" alt="公式1"><br>我们常称x为feature，h(x)为hypothesis（假设函数）<br><strong>Cost Function：</strong>对假设的函数进行评价，Cost Function越小的函数，说明对训练数据拟合的越好。下面给出costFunction公式：<br><img src="http://img.blog.csdn.net/20161006124407924" alt="公式2"><br>如果theta0和theta1都不固定，则theta0、theta1、J的函数为：<br><img src="http://img.blog.csdn.net/20161006134926885" alt="公式3"><br><strong>注意如果是线性回归，则cost function一定是碗状的，即只有一个最小点。</strong></li></ul><p><strong>损失函数最优化：梯度下降</strong><br>下面给出梯度下降算法：<br><img src="http://img.blog.csdn.net/20161006140441811" alt="公式4"><br><strong>特点</strong><br><strong>a)</strong>初始点不同，获得的最小值也不同，因此梯度下降求得的只是局部最小值；<br><strong>b)</strong>越接近最小值，下降速度越慢。<br><strong>问题1：</strong>如果和初始值就在local minimum的位置，则、会如何变化？<br><strong>答案：</strong>因为、已经在local minimum位置，所以derivative（导数）肯定是0，因此、不会改变。<br><strong>问题2：</strong>如果取到一个正确的值，则cost function应该会越来越小。那么，怎么取值？<br><strong>答案：</strong>随时观察值，如果cost function变小了，则OK；反之，则再取一个更小的值。</p><p><strong>注意：</strong>下降的步伐大小非常重要，因为，如果太小，则找到函数最小值的速度就很慢；如果太大，则可能会出现overshoot the minimum现象。<br><img src="http://img.blog.csdn.net/20161006143417373" alt="overshoot"><br>那既然梯度下降可以求到损失函数的最小值，线性回归又是需要一个最小的损失函数，那么可以将两者进行整合：<br><img src="http://img.blog.csdn.net/20161006144108314" alt="整合"></p><p><strong>Feature Scaling</strong>此种方法应用于梯度下降，为了加快梯度下降的执行速度。<br>思想：将各个feature的值标准化，使得取值范围大致都在<strong>-1&lt;=x&lt;=1</strong>之间。<br>常用的方法是Mean Normalization，即<img src="http://img.blog.csdn.net/20161006144838659" alt="1">,或者[X-mean(X)]/std(X)。</p><p><strong>多变量线性回归</strong><br>其假设函数为:<br><img src="http://img.blog.csdn.net/20161006151000259" alt="3"><br>损失函数仍然定义为平方损失函数<br>最小化损失函数仍然可以用梯度下降法：<br><img src="http://img.blog.csdn.net/20161006151253077" alt="4"></p><p>下面给出python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据集 -2到2 200个点 等差数列</span></span><br><span class="line">x_train = np.linspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment"># 构造 系数为2 偏差为4的y 加入一些随机噪音</span></span><br><span class="line">y_train = x_train * <span class="number">2</span> + np.ones(len(x_train)) * <span class="number">4</span> + np.random.randn(len(x_train)) * <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensorflow构造模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.定义输入和输出的占位符 tf中一般是tf.float32</span></span><br><span class="line">X = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line">Y = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义参数变量,初始化为0</span></span><br><span class="line">w = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'weights'</span>)</span><br><span class="line">b = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'bias'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.定义假设模型的输出,wx+b</span></span><br><span class="line">y_pred = tf.multiply(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.定义损失函数,这里是平方损失函数</span></span><br><span class="line">loss = tf.square(y_pred - Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.定义优化函数来最小化损失函数,学习率，要最小化的损失函数</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到这里搭建完了图模型，但是不会产生任何运算结果，因为需要session来驱动</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># 变量必须要初始化，如果变量有嵌套关系，则必须按顺序初始化</span></span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line"><span class="comment"># 定义迭代次数</span></span><br><span class="line">iteration_nums = <span class="number">500</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration_nums):</span><br><span class="line">    <span class="comment"># 注意这里，要run的是optimizer这个函数，它又用到了loss这个函数，而loss函数又用到了y_pred这个结果，所以追溯向前，一共</span></span><br><span class="line">    <span class="comment"># 用到了 X,Y 这两个被占位符声明的输入与输出以及w,b这两个变量，而参数变量正是我们要优化的目标</span></span><br><span class="line">    sess.run(optimizer, feed_dict=&#123;X: x_train, Y: y_train&#125;)</span><br><span class="line"><span class="comment"># 学习完成后，变量w,b被重新赋值，打印w和b</span></span><br><span class="line">print(sess.run(w))</span><br><span class="line">print(sess.run(b))</span><br></pre></td></tr></table></figure></p><p>最终的输出为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.0024</span></span><br><span class="line"><span class="number">3.9702</span></span><br></pre></td></tr></table></figure></p><p>与预期输出相符，注意我在一开始设置步长为0.01的时候发散掉了，最后w和b都是nan，所以合理的调参是必不可少的<br>下面绘制一下样本点和回归函数的图像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意上面y_pred没有实际的值</span></span><br><span class="line">y_pred = sess.run(y_pred,&#123;X:x_train&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'Population of City in 10,000s'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Profit in $10,000s'</span>)</span><br><span class="line">plt.plot(x_train,y_train,marker=<span class="string">'x'</span>,lw=<span class="number">0</span>,color=<span class="string">'r'</span>,label=<span class="string">'Training data'</span>)</span><br><span class="line">plt.plot(x_train,y_pred,linestyle=<span class="string">'-'</span>,color=<span class="string">'b'</span>,label=<span class="string">'Linear regression line'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="http://i4.bvimg.com/620746/ca16ce6a4d186649s.png" alt="1"></p><p>再构造一些测试数据，用学习到的模型进行预测<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.定义测试数据</span></span><br><span class="line">X_test = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line"><span class="comment"># 2.定义相关参数</span></span><br><span class="line">w = sess.run(w)</span><br><span class="line">b = sess.run(b)</span><br><span class="line"><span class="comment"># 3.定义预测</span></span><br><span class="line">predict = tf.multiply(w,X_test)+b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.得到预测结果</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line">test_pred = sess.run(predict,&#123;X_test:x_test&#125;)</span><br><span class="line">print(test_pred)</span><br></pre></td></tr></table></figure></p><p>绘制测试集上的回归函数图像：<br><img src="http://i4.bvimg.com/620746/af37e43ce35e8e51s.png" alt="2"><br>可以看到拟合的效果还是不错的。</p><p>这是<a href="http://blog.csdn.net/freedom098/article/details/52106931" target="_blank" rel="noopener">freedom098博客</a>上的一点关于梯度下降的一点儿感悟：<br><strong>1、</strong>梯度下降法分为批量梯度下降和随机梯度下降法，第一种是所有数据都参与运算后，计算误差函数，根据此误差函数来更新模型参数，实际调试发现，如果定义误差函数为平方误差函数，这个值很快就会飞掉，原因是，批量平方误差都加起来可能会很大，如果此时学习率比较高，那么调整就会过，造成模型参数向一个方向大幅调整，造成最终结果发散。所以这个时候要降低学习率，让参数变化不要太快。<br><strong>2、</strong>随机梯度下降法，每次用一个数据计算误差函数，然后更新模型参数，这个方法有可能会造成结果出现震荡，而且麻烦的是由于要一个个取出数据参与运算，而不是像批量计算那样采用了广播或者向量化乘法的机制，收敛会慢一些。但是速度要比使用批量梯度下降要快，原因是不需要每次计算全部数据的梯度了。比较折中的办法是mini-batch，也就是每次选用一小部分数据做梯度下降，目前这也是最为常用的方法了。<br><strong>3、</strong>epoch概念：所有样本集过完一轮，就是一个epoch，很明显，如果是严格的随机梯度下降法，一个epoch内更新了样本个数这么多次参数，而批量法只更新了一次。</p><hr><h1 id="tf-multiply和tf-matmul区别"><a href="#tf-multiply和tf-matmul区别" class="headerlink" title="tf.multiply和tf.matmul区别"></a>tf.multiply和tf.matmul区别</h1><p>其中tf.multiply是点乘，tf.matmul是矩阵乘法，点乘要求维度相同，结果是每个对应的元素相乘，矩阵乘法要求MxN NxK,最后得到MxK<br>举个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">B = np.array([[<span class="number">5</span>],[<span class="number">2</span>],[<span class="number">1</span>]])</span><br><span class="line">C = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">-2</span>,<span class="number">0</span>]])</span><br><span class="line">print(<span class="string">'矩阵A'</span>)</span><br><span class="line">print(A)</span><br><span class="line">print(<span class="string">'矩阵B'</span>)</span><br><span class="line">print(B)</span><br><span class="line">print(<span class="string">'矩阵A乘以B'</span>)</span><br><span class="line">print(np.matmul(A,B))</span><br><span class="line">print(<span class="string">'矩阵A点乘C'</span>)</span><br><span class="line">print(np.multiply(A,C))</span><br></pre></td></tr></table></figure></p><p>Output<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">矩阵A</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">矩阵B</span><br><span class="line">[[<span class="number">5</span>]</span><br><span class="line"> [<span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span>]]</span><br><span class="line">矩阵A乘以B</span><br><span class="line">[[<span class="number">12</span>]</span><br><span class="line"> [<span class="number">36</span>]]</span><br><span class="line">矩阵A点乘C</span><br><span class="line">[[  <span class="number">1</span>   <span class="number">0</span>  <span class="number">-3</span>]</span><br><span class="line"> [  <span class="number">8</span> <span class="number">-10</span>   <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="np-dot"><a href="#np-dot" class="headerlink" title="np.dot"></a>np.dot</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">          [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">          [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">          [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]])</span><br><span class="line">B = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]])</span><br><span class="line">C = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]])</span><br><span class="line">D = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">E = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 当x,y都为一维数组的时候，np.dot表示内积</span></span><br><span class="line">print(np.dot(D,E))</span><br><span class="line"><span class="comment">#print(np.dot(np.mat(B).T,np.mat(C).T))</span></span><br><span class="line"><span class="comment"># 除此之外，表示矩阵乘积</span></span><br><span class="line">print(np.dot(A,C))</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span></span><br><span class="line"></span><br><span class="line">[[ <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">70</span>]</span><br><span class="line"> [<span class="number">110</span>]</span><br><span class="line"> [<span class="number">150</span>]]</span><br></pre></td></tr></table></figure></p><hr><h1 id="手动实现Logistic"><a href="#手动实现Logistic" class="headerlink" title="手动实现Logistic"></a>手动实现Logistic</h1><p><a href="http://blog.csdn.net/zjsghww/article/details/55211530" target="_blank" rel="noopener">参考链接1</a><br>下面两个图可以看到线性回归和逻辑回归的联系，因为逻辑回归的假设函数的输出是0到1之间的概率，相当于把线性回归的假设函数归一化<br><img src="http://img.blog.csdn.net/20170421120330053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3lhbmd6aGl6aG91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic1"><br><img src="http://img.blog.csdn.net/20170421120330053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3lhbmd6aGl6aG91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic2"><br>那现在有一个线性回归模型$ z = \theta^Tx $,要将输出转为y(0,1)，那么就需要将z转为y，如果用单位阶跃函数来表示:<br><img src="http://i4.bvimg.com/620746/9ee33a6be0a9f522t.jpg" alt=""><br>由于其不连续，所以用sigmoid函数代替：<br>$ y = \frac{1}{1+e^{-z}} $<br>则其输出为（假设函数）:<br>$ y = \frac{1}{1+e^{-(\theta^Tx)}} $<br>其函数图像为：<br><img src="http://img.blog.csdn.net/20170215164754943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempzZ2h3dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic1"><br>如果将假设函数进行变形，将theta向量与X矩阵相乘拿出来的话，可以得到：<br><img src="http://i4.bvimg.com/620746/85ba3427935c40e3s.png" alt="Markdown"><br>那这也就是对数几率回归，y看成是样本x正例的概率，1-y则为样本x负例的概率，这里将条件概率模型转化为了线性模型:<br><img src="http://i4.bvimg.com/620746/adc966e5666b3f2fs.png" alt="Markdown"><br>那么接下来要求<strong>样本点的联合概率分布</strong>，对于每一个样本点来说:<br><img src="http://i4.bvimg.com/620746/ed72b022fd704853s.png" alt="Markdown"><br>那考虑所有样本，由于每个样本点互相独立，因此他们的联合概率分布等于各自的边缘概率分布的积：<br><img src="http://i4.bvimg.com/620746/94b312b9d23e88c0s.png" alt="Markdown"><br>其对数似然函数为：<br><img src="http://i4.bvimg.com/620746/eb257067ab63dbd8s.png" alt="Markdown"><br>现在需要使得联合概率分布最大，或者说使得其对数似然函数最大，需要使用梯度下降法来求θ(其损失函数可以说是-1/m * 对数似然函数（联合概率分布）)<br>给出其损失函数<img src="http://i4.bvimg.com/620746/26995a9c1aaaf458s.png" alt="Markdown">并给出从损失函数到偏导的推导:<br><img src="http://img.blog.csdn.net/20170215174429487?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempzZ2h3dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic3"></p><p><strong>下面给出其python实现过程：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">x_train = [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">2.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">3.0</span>, <span class="number">5.0</span>], [<span class="number">1.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">2.0</span>], [<span class="number">7.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">11.0</span>, <span class="number">3.0</span>],</span><br><span class="line">           [<span class="number">8.0</span>, <span class="number">7.0</span>]]</span><br><span class="line">y_train = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">good_index = []</span><br><span class="line">bad_index = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_train)):</span><br><span class="line">    <span class="keyword">if</span> y_train[i]==<span class="number">1</span>:</span><br><span class="line">        good_index.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bad_index.append(i)</span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">plt.scatter(np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[good_index],np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[good_index],marker=<span class="string">'o'</span>,color=<span class="string">'k'</span>,label=<span class="string">'good'</span>)</span><br><span class="line">plt.scatter(np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[bad_index],np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[bad_index],marker=<span class="string">'x'</span>,color=<span class="string">'g'</span>,label=<span class="string">'bad'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="http://i1.bvimg.com/620746/8fb6d8adb6285060s.png" alt="pic"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化变量 由于这里是两维特征 h(θ) = θ0*x0 + θ1*x1 + θ2*x2</span></span><br><span class="line"><span class="comment"># 为了构造矩阵相乘，给数据集X添加一列1</span></span><br><span class="line">init_theta = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">X = np.array([[<span class="number">1.0</span>]+x <span class="keyword">for</span> x <span class="keyword">in</span> x_train])</span><br><span class="line">y = np.array(y_train)</span><br><span class="line"><span class="comment"># 构造假设函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Objective</span><span class="params">(theta,X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-np.dot(theta.reshape(<span class="number">1</span>,<span class="number">3</span>),X.T)))</span><br><span class="line"><span class="comment"># 构造损失函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(theta,X,y)</span>:</span></span><br><span class="line">    pred_y = Objective(theta,X)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 在当前theta下训练集的损失函数值,求原来损失函数的最大，在这里取负号就是最小</span></span><br><span class="line">    lossSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">        lossSum += -y[i]*pred_y[i] + np.log(<span class="number">1</span>+np.exp(pred_y[i]))</span><br><span class="line">    <span class="keyword">return</span> lossSum/X.shape[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">'在初始theta的情况下，训练集的损失函数值为:'</span>,loss(init_theta,X,y))</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在初始theta的情况下，训练集的损失函数值为: <span class="number">0.71354969579</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化损失函数</span></span><br><span class="line"><span class="comment"># 为了寻找最优的theta向量使得损失函数最小，这里使用梯度下降法</span></span><br><span class="line"><span class="comment"># 计算当前梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gradient</span><span class="params">(theta,X,y)</span>:</span></span><br><span class="line">    grad = []</span><br><span class="line">    pred_y = Objective(theta,X)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>]):</span><br><span class="line">        cur_grad = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前梯度跟每一个样本实例都有关系</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">            cur_grad += (pred_y[j]-y[j]) * X[j][i]</span><br><span class="line">        grad.append(cur_grad/X.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> np.array(grad)</span><br><span class="line">print(<span class="string">'初始梯度'</span>,Gradient(init_theta,X,y))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始梯度 [ <span class="number">0.39880029</span>  <span class="number">2.39851299</span>  <span class="number">1.09756494</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用梯度下降找到最优参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic</span><span class="params">(theta,X,y,eta)</span>:</span></span><br><span class="line">    loss_list = []</span><br><span class="line">    minLoss = <span class="number">1000</span></span><br><span class="line">    minTheta = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 定义迭代次数</span></span><br><span class="line">    theLoss = <span class="number">0</span></span><br><span class="line">    iteration_times = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration_times):</span><br><span class="line">        <span class="comment"># 每一轮迭代更新损失theta向量和损失函数值</span></span><br><span class="line">        theta = theta - eta * Gradient(theta,X,y)</span><br><span class="line">        theLoss = loss(theta,X,y)</span><br><span class="line">        <span class="keyword">if</span> theLoss &lt; minLoss:</span><br><span class="line">            minLoss = theLoss</span><br><span class="line">            minTheta = theta</span><br><span class="line">        loss_list.append(theLoss)</span><br><span class="line">    <span class="keyword">return</span> loss_list,minLoss,minTheta</span><br><span class="line">loss_list,minLoss,minTheta = logistic(init_theta,X,y,<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># 画出收敛曲线的图</span></span><br><span class="line">axis_x = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(len(loss_list))]</span><br><span class="line">plt.xlabel(<span class="string">'iteration times'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss function value'</span>)</span><br><span class="line">plt.plot(axis_x,loss_list,linestyle=<span class="string">'-'</span>,color=<span class="string">'b'</span>,label=<span class="string">'Convergent curve'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://i1.bvimg.com/620746/6bbfdf02e262ce31s.png" alt="pic"></p><hr><h1 id="交叉熵Corss-entropy和Softmax"><a href="#交叉熵Corss-entropy和Softmax" class="headerlink" title="交叉熵Corss-entropy和Softmax"></a>交叉熵Corss-entropy和Softmax</h1><h2 id="交叉熵Cross-entropy"><a href="#交叉熵Cross-entropy" class="headerlink" title="交叉熵Cross-entropy"></a>交叉熵Cross-entropy</h2><p><a href="https://www.zhihu.com/question/65288314/answer/230209104" target="_blank" rel="noopener">参考链接</a><br><img src="http://i1.bvimg.com/620746/fcd91367dd3490e5s.png" alt="Markdown"><br><img src="http://i1.bvimg.com/620746/6f3c163bcd3a6e43s.png" alt="Markdown"><br><img src="http://i1.bvimg.com/620746/0d58162dce573c0cs.png" alt="Markdown"></p><h2 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h2><p><strong>Softmax函数用于多分类或二分类，可以对样本输出的每一个类别给出对应的概率值</strong><br>这里的softmax可以看成是一个激励（activation）函数或者链接（link）函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10个数字类的概率分布。因此，给定一张图片，它对于每一个数字的吻合度可以被softmax函数转换成为一个概率值<br><img src="http://i1.bvimg.com/620746/e922629c244061a5s.png" alt="Markdown"><br><img src="http://i1.bvimg.com/620746/e1c695434044cc9es.png" alt="Markdown"></p><hr><h1 id="Logistic回归：MINIST训练集"><a href="#Logistic回归：MINIST训练集" class="headerlink" title="Logistic回归：MINIST训练集"></a>Logistic回归：MINIST训练集</h1><p>MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片：<br><img src="http://wiki.jikexueyuan.com/project/tensorflow-zh/images/MNIST.png" alt="11"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line">MNIST = input_data.read_data_sets(<span class="string">"data"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义相关超参</span></span><br><span class="line">eta = <span class="number">0.01</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">n_epochs = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为输入和输出定义placeholder</span></span><br><span class="line"><span class="comment"># 因为每个在MNIST中的像素是28*28 = 784</span></span><br><span class="line"><span class="comment"># 所以每一个图像都有784个特征，是一个1x784的张量</span></span><br><span class="line">X = tf.placeholder(<span class="string">'float32'</span>,[batch_size,<span class="number">784</span>])</span><br><span class="line">y = tf.placeholder(<span class="string">'float32'</span>,[batch_size,<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建要调整的参数变量 weights and bias</span></span><br><span class="line"><span class="comment"># 784，10 是因为要输出一个长度为10的结果向量</span></span><br><span class="line">w = tf.Variable(tf.random_normal(shape=[<span class="number">784</span>,<span class="number">10</span>],stddev=<span class="number">0.1</span>), name=<span class="string">'weights'</span>)</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>,<span class="number">10</span>]), name=<span class="string">'bias'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义假设函数</span></span><br><span class="line">logits = tf.matmul(X,w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">entropy = tf.nn.softmax_cross_entropy_with_logits(logits=logits,labels=y)</span><br><span class="line">loss = tf.reduce_mean(entropy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=eta).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里batch_size是每一次训练多少个样本，这里要算每一轮要训练多少次</span></span><br><span class="line">n_batches = int(MNIST.train.num_examples/batch_size)</span><br><span class="line"><span class="comment"># 训练多少轮</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_batches):</span><br><span class="line">        <span class="comment"># 该循环的每个步骤中，我们都会随机抓取训练数据中的batch_size个批处理数据点，然后我们用这些数据点作为参数替换之前的占位符来运行train_step</span></span><br><span class="line">        X_batch,Y_batch = MNIST.train.next_batch(batch_size)</span><br><span class="line">        sess.run([optimizer,loss],&#123;X:X_batch,y:Y_batch&#125;)</span><br><span class="line"><span class="comment"># 测试模型</span></span><br><span class="line">corrects = <span class="number">0</span></span><br><span class="line">n_batches = int(MNIST.test.num_examples/batch_size)</span><br><span class="line">total_correct_preds = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_batches):</span><br><span class="line">    X_batch, Y_batch = MNIST.test.next_batch(batch_size)</span><br><span class="line">    _,loss_batch,logits_batch = sess.run([optimizer,loss,logits],feed_dict=&#123;X:X_batch,y:Y_batch&#125;)</span><br><span class="line">    preds = tf.nn.softmax(logits_batch)</span><br><span class="line">    corrects_preds = tf.equal(tf.argmax(preds,<span class="number">1</span>),tf.argmax(Y_batch,<span class="number">1</span>))</span><br><span class="line">    accuracy = tf.reduce_sum(tf.cast(corrects_preds,tf.float32))</span><br><span class="line">    total_correct_preds += sess.run(accuracy)</span><br><span class="line">print(<span class="string">'Accuracy'</span>,total_correct_preds/MNIST.test.num_examples)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Accuracy <span class="number">0.9077</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Something about TensorFlow&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2088/01/05/python/"/>
    <id>http://yoursite.com/2088/01/05/python/</id>
    <published>2088-01-04T16:00:00.000Z</published>
    <updated>2018-02-03T06:57:43.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-math库"><a href="#python-math库" class="headerlink" title="python math库"></a>python math库</h1><h2 id="Number-theoretic-and-representation-functions"><a href="#Number-theoretic-and-representation-functions" class="headerlink" title="Number-theoretic and representation functions"></a>Number-theoretic and representation functions</h2><ul><li><strong>math.ceil(x)</strong> 上限，返回大于或等于x的最小整数</li><li><strong>math.copysign(x,y)</strong> 赋值符号,返回x的绝对值，使用y的符号,返回类型为float</li><li><strong>math.fabs(x)</strong> 返回x的绝对值</li><li><strong>math.factorial(x)</strong> 返回x的阶乘，如果x为非正整数会报错</li><li><strong>math.floor(x)</strong> 下限，小于或等于x的最大整数 </li><li><strong>math.fmod(x,y)</strong> 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号）</li><li><strong>math.frexp(x)</strong> 返回一个元组(m,n),根据x = m<em>(2*</em>n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了）</li><li><strong>math.fsum(iterable)</strong> 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999</li><li><strong>math.gcd(a,b)</strong> 返回最大公约数,a,b必须为整数</li><li><strong>math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0)</strong> 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.18</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">11.3</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True</p><ul><li><strong>math.isfinite(x)</strong> 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number)</li><li><p><strong>math.isinf(x)</strong> 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正无穷</span></span><br><span class="line">float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="comment"># 负无穷</span></span><br><span class="line">float(<span class="string">'-inf'</span>)</span><br><span class="line">-float(<span class="string">'inf'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>math.isnan(x)</strong> 判断是否是NAN（not a number）</p></li><li><strong>math.ldexp(x,i)</strong> 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数</li><li><strong>math.modf(x)</strong> 分别返回x的小数部分和整数部分，同时带x的符号，例如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.modf(<span class="number">-1.89</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出(-0.8899999999999999, -1.0)</p><ul><li><strong>math.trunc(x)</strong> 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数<h2 id="Power-and-logarithmic-functions"><a href="#Power-and-logarithmic-functions" class="headerlink" title="Power and logarithmic functions"></a>Power and logarithmic functions</h2></li><li><strong>math.exp(x)</strong> 返回e的x方</li><li><strong>math.expm1(x)</strong> 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确</li><li><strong>math.log(x[,base])</strong> 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base),</li><li><strong>math.log1p(x)</strong> 返回值为 log(1+x)/log(e)</li><li><strong>math.log2(x)</strong> 返回值为log(x)/log2,用来代替log(x,2),因为更加精确</li><li><strong>math.log10(x)</strong> 同理，返回log(x)/log(10)</li><li><strong>math.pow(x,y)</strong> 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan</li><li><strong>math.sqrt(x)</strong> 返回x的平方根<h2 id="Trigonometric-functions"><a href="#Trigonometric-functions" class="headerlink" title="Trigonometric functions"></a>Trigonometric functions</h2><strong>三角函数</strong></li><li><strong>math.acos(x)</strong> 返回x的反余弦 arc cosine，把斜率转换成弧度</li><li><strong>math.asin(x)</strong> 返回x的反正弦 arc sine</li><li><strong>math.atan(x)</strong> 返回x的反正切 arc tangent</li><li><strong>math.atan2(y,x)</strong> 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标</li><li><strong>math.cos(x)</strong> 返回x的余弦,角度值转为余弦值,cos(0)=1.0</li><li><strong>math.sin(x)</strong> 返回x的正弦</li><li><strong>math.tan(x)</strong> 返回x的正切</li><li><strong>math.hypot(x,y)</strong> 返回欧几里得范数 sqrt(x<em>x + y</em>y) ,也就是点(x,y)到原点的距离</li><li><strong>math.degrees(x)</strong> 把角度x转为弧度，角度=（弧度/π）*180</li><li><strong>math.radians(x)</strong> 把弧度x转为角度，弧度= (角度/180)*π<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2></li><li><strong>math.lgamma(x)</strong> 返回伽马函数绝对值在x上的自然对数。</li></ul><hr><h1 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h1><p>pyhton 中的 filter函数接收一个函数f和一个序列(<strong>python中的序列有：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象，列表和元组的区别主要是：列表可以修改，元组不能</strong>)，函数f的作用是对列表中的每一个元素进行条件判断，返回True或False，filter函数最终返回一个迭代器Iterator(在python 2.x中返回一个list)<br>举例：返回1-1000中的所有奇数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x%<span class="number">2</span>!=<span class="number">0</span></span><br><span class="line"><span class="comment"># in python 3.x</span></span><br><span class="line">print(list(filter(is_odd,range(<span class="number">1</span>,<span class="number">1001</span>))))</span><br><span class="line"><span class="comment"># in python 2.x</span></span><br><span class="line"><span class="keyword">print</span> filter(is_odd,range(<span class="number">1</span>,<span class="number">1001</span>))</span><br></pre></td></tr></table></figure></p><p>字符串遍历筛选的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x==<span class="string">'a'</span></span><br><span class="line">print(list(filter(is_a,<span class="string">'HaHaHaHa'</span>)))</span><br><span class="line">Output:</span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure></p><p>例如：删除None和空字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cal_str</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip())&gt;<span class="number">0</span></span><br><span class="line">filter(Cal_str,[<span class="string">"H"</span>,<span class="keyword">None</span>,<span class="string">""</span>,<span class="string">"ello"</span>])</span><br><span class="line">Output: <span class="string">"[H"</span>,<span class="string">"ello"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h2><p><strong> strip(rm)</strong> 默认删除s字符串中开头、结尾处的rm字符串，当rm为空的时候，默认删除空白（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)</p><ul><li>s.strip(rm)        删除s字符串中开头、结尾处，位于 rm删除序列的字符</li><li>s.lstrip(rm)       删除s字符串中开头处，位于 rm删除序列的字符</li><li>s.rstrip(rm)      删除s字符串中结尾处，位于 rm删除序列的字符<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'Hello world'</span></span><br><span class="line">print(a.strip(<span class="string">'He'</span>))</span><br><span class="line">print(a.strip(<span class="string">'eH'</span>))</span><br><span class="line">print(a.strip(<span class="string">'el'</span>))</span><br><span class="line">Output:</span><br><span class="line">llo world</span><br><span class="line">llo world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></li></ul><p>由于Python3.x中的filter返回的是一个Iterator，所以不仅仅可以指定为list，也可以set(filter(…))</p><hr><h1 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h1><p>python 中的 map函数接收一个函数f和一个序列，f将作用于序列中的每个元素，最终的结果作为Interator返回</p><p>如果使用map来实现filter中的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="string">'a'</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">print(list(map(is_a,<span class="string">"Hahahah"</span>)))</span><br><span class="line">Output:</span><br><span class="line">[<span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure></p><p><strong>map最终返回的序列长度是等于原来的序列长度的，filter返回的序列长度是小于等于原来的长度的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lambda函数的例子</span></span><br><span class="line">print(list(map(<span class="keyword">lambda</span> x:x+<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p><strong>注意！</strong> 当只有一个序列的时候，map和filter都是可以使用的，但是当处理多个序列的时候，只能使用map<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(list(map(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">14</span>]</span><br><span class="line"><span class="comment"># 相当于zip,然后将zip的结果传给函数,所以map在处理多个序列的时候，无法操作序列长度不一致，对应值类型不同的情况</span></span><br><span class="line"><span class="comment"># 例如[1,4,6],[2,5,6,8]或[1,4,6],['a',3,6]</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h1><p><strong>注意</strong> 在python3中，reduce已经从内置函数中被抛弃了，要使用就要引入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure></p><p>reduce函数是一个累积运算的过程，其接收一个函数f(x,y)和一个序列（以及一个可选的初始值）,其中函数f的x,y首先代表序列中的第一个和第二个参数，其返回值作为新的x，第三个参数作为新的y，依次运算至结束。<br>例如求和运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">print(list(reduce(f,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])))</span><br><span class="line">Process:</span><br><span class="line">先计算头两个元素：f(<span class="number">1</span>, <span class="number">3</span>)，结果为<span class="number">4</span>；</span><br><span class="line">再把结果和第<span class="number">3</span>个元素计算：f(<span class="number">4</span>, <span class="number">5</span>)，结果为<span class="number">9</span>；</span><br><span class="line">再把结果和第<span class="number">4</span>个元素计算：f(<span class="number">9</span>, <span class="number">7</span>)，结果为<span class="number">16</span>；</span><br><span class="line">再把结果和第<span class="number">5</span>个元素计算：f(<span class="number">16</span>, <span class="number">9</span>)，结果为<span class="number">25</span>；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果<span class="number">25</span></span><br></pre></td></tr></table></figure></p><p>如果设置了初始值为100，那么第一次运算就是f(100,1)</p><p>再例如，用reduce实现5的阶乘:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">6</span>)))</span><br><span class="line">Output:</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>只举了两个简单的例子，通过函数可以实现更为复杂的操作</p><hr><h1 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h1><p>lambda作为一个表达式，定义了一个匿名函数<br>定义一个lambda表达式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line"><span class="comment"># 可以这样理解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>lambda 常常配合上述的 reduce , map, filter 作为f来使用，可以使得代码大大简化。<br><strong>但是python中的 for..in..if 已经非常强大</strong>，lambda并不一定作为首选<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意是[]</span></span><br><span class="line"><span class="keyword">print</span> ([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>总之：ambda 并不会带来程序运行效率的提高，只会使代码更简洁。<strong>lambda是为了减少单行函数而存在的</strong></p><hr><h1 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h1><p>python的set和其他语言类似，是一个是一个无序不重复元素集, 基本功能包括<strong>关系测试和消除重复元素.</strong> 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.作为一个无序的集合，<strong>sets不记录元素位置或者插入点</strong>。因此，<strong>sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作</strong>。<br><strong> 初始化 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s0 = set()</span><br><span class="line">s1 = set(<span class="string">'HelloWorld'</span>)</span><br><span class="line">s2 = set([<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>])</span><br><span class="line">s3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 注意，没有这种操作 set(1,2,3)</span></span><br></pre></td></tr></table></figure></p><p><strong>简单例子：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = set(<span class="string">'spam'</span>)  </span><br><span class="line">y = set([<span class="string">'h'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>])  </span><br><span class="line">x,y</span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line">(set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'m'</span>]), set([<span class="string">'a'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>]))</span><br></pre></td></tr></table></figure></p><p><strong>去除list l 中重复元素的例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">55</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> set(l)])</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure></p><p><strong>两个集合的数学运算</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）  </span></span><br><span class="line">d = t ^ s          <span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）  </span></span><br><span class="line"><span class="comment"># 当然，也可以麻烦点写成函数的形式</span></span><br><span class="line">print(s.intersection(t), s &amp; t)  <span class="comment"># 交集</span></span><br><span class="line">print(s.union(t), s | t)   <span class="comment"># 并集 </span></span><br><span class="line">print(s.difference(t), s - t)  <span class="comment"># 差集 </span></span><br><span class="line">print(s.symmetric_difference(t), s ^ t) <span class="comment"># 对称差集 </span></span><br><span class="line">print(s1.issubset(s2), s1 &lt;= s2) <span class="comment"># 子集</span></span><br><span class="line">print(s1.issuperset(s2), s1 &gt;= s2)      <span class="comment"># 包含</span></span><br></pre></td></tr></table></figure></p><p><strong> 基本方法 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">len(s)  <span class="comment"># 获取集合中的元素的总数</span></span><br><span class="line">s.update([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># 添加多个元素</span></span><br><span class="line">s.add(<span class="string">"x"</span>)         <span class="comment"># 添加一个元素</span></span><br><span class="line">s.remove(<span class="string">"x"</span>)      <span class="comment"># 去掉一个元素</span></span><br><span class="line">s.discard(<span class="string">"x"</span>)     <span class="comment"># 如果集合存在指定元素，则删除该元素</span></span><br><span class="line">c = s.copy()       <span class="comment"># 复制集合</span></span><br><span class="line">s.pop() <span class="comment"># 弹出集合中的一个不确定元素(好像不是等价随机)</span></span><br><span class="line">s.clear()          <span class="comment"># 删除集合中所有的元素(改变原集合)</span></span><br><span class="line">x <span class="keyword">in</span> s  <span class="comment">#测试 x 是否是 s 的成员  </span></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></p><p><strong>参考链接</strong><br><a href="http://www.jb51.net/article/60480.htm" target="_blank" rel="noopener">链接1</a><br><a href="http://blog.csdn.net/business122/article/details/7541486" target="_blank" rel="noopener">链接2</a></p><hr><h1 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace 函数"></a>replace 函数</h1><p><strong>replace()方法语法：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(old, new[, max])</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>old – 将被替换的子字符串。</li><li>new – 新字符串，用于替换old子字符串。</li><li>max – 可选字符串, 替换不超过 max 次</li></ul><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"this is string example....wow!!! this is really string"</span>;</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>);</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas <span class="keyword">is</span> really string</span><br></pre></td></tr></table></figure></p><hr><h1 id="sort-sorted-reverse-reversed"><a href="#sort-sorted-reverse-reversed" class="headerlink" title="sort sorted reverse reversed"></a>sort sorted reverse reversed</h1><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort()是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>sorted()是python的内置函数，<strong>并不是可变对象(列表、字典)的特有方法</strong>，sorted()函数<strong>需要一个参数</strong>(参数可以是列表、字典、元组、字符串)，无论传递什么参数，<strong>都将返回一个以列表为容器的返回值</strong>，如果是字典将返回键的列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mystring=<span class="string">"54321"</span></span><br><span class="line">mytuple=(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">mylist=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sorted(mystring)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">mystring</span><br><span class="line">&gt;&gt;&gt;<span class="string">"54321"</span></span><br><span class="line"></span><br><span class="line">sorted(mytuple)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sorted(mylist)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><h2 id="reverse-reversed"><a href="#reverse-reversed" class="headerlink" title="reverse reversed"></a>reverse reversed</h2><p>reverse()与sort的使用方式一样，而reversed()与sorted()的使用方式相同<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mylist=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">mylist.reverse()</span><br><span class="line">mylist</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(mylist):</span><br><span class="line"><span class="keyword">print</span> i,</span><br><span class="line">&gt;&gt;&gt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p><h2 id="通过序列的切片也可以达到“逆转”的效果"><a href="#通过序列的切片也可以达到“逆转”的效果" class="headerlink" title="通过序列的切片也可以达到“逆转”的效果"></a>通过序列的切片也可以达到“逆转”的效果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mystring=<span class="string">"54321"</span></span><br><span class="line">mytuple=(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">mylist=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">mystring[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="string">'12345'</span></span><br><span class="line">mytuple[::<span class="number">-1</span>]</span><br><span class="line">&gt;&gt;&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">mylist[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)人生苦短，我用python&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2017/12/13/leetcode/"/>
    <id>http://yoursite.com/2017/12/13/leetcode/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2018-02-07T04:12:58.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-Two-sum"><a href="#Array-Two-sum" class="headerlink" title="(Array)Two sum"></a>(Array)Two sum</h1><p>**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.**</p><p>Example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p><p>给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解）</p><p>Sample solution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    buff_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> buff_dict:</span><br><span class="line">            <span class="keyword">return</span> [buff_dict[nums[i]], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buff_dict[target - nums[i]] = i</span><br></pre></td></tr></table></figure></p><p><strong>思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index]</strong></p><hr><h1 id="Array-Reverse-Integer"><a href="#Array-Reverse-Integer" class="headerlink" title="(Array)Reverse Integer"></a>(Array)Reverse Integer</h1><p>Q:Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output:  <span class="number">-321</span></span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output:  <span class="number">21</span></span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>My Answer:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(str(nums))&gt;<span class="number">0</span> <span class="keyword">and</span> nums != <span class="number">0</span> <span class="keyword">and</span> nums &lt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">            nums = str(nums)</span><br><span class="line">            newStr = <span class="string">''</span></span><br><span class="line">            <span class="comment"># len(nums)-1 to -1 , -1 not included , interval is -1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                newStr = newStr + nums[i]</span><br><span class="line">            print(newStr)</span><br><span class="line">            <span class="keyword">while</span> newStr[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                newStr= newStr[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> newStr[<span class="number">-1</span>]==<span class="string">'-'</span>:</span><br><span class="line">                newStr=<span class="string">'-'</span>+newStr[:len(newStr)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> math.fabs(int(newStr)) &gt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span>(int(newStr))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：主要注意几点</strong><br>1.32位有符号整数范围判断<br>2.逆序以后0的处理<br>3.切片时注意索引是否会超范围，也就是只输入0的情况<br>4.对于是否为负的处理</p><hr><h1 id="Array-Palindrome-Number"><a href="#Array-Palindrome-Number" class="headerlink" title="(Array)Palindrome Number"></a>(Array)Palindrome Number</h1><p><strong>判断是否是回文数字</strong><br><strong>注意</strong><br>1.负数不为回文数<br>2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性</p><p>Mysolution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> nums&lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> math.pow(<span class="number">10</span>,length) &lt;= nums:</span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(math.ceil(length/<span class="number">2</span>)):</span><br><span class="line">                status = math.isclose((math.floor(nums/math.pow(<span class="number">10</span>,i))%<span class="number">10</span>),(math.floor(nums/math.pow(<span class="number">10</span>,length-i<span class="number">-1</span>))%<span class="number">10</span>),abs_tol = <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="keyword">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p><strong>Hint:</strong> 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。</p><hr><h1 id="Array-Non-decreasing-Array"><a href="#Array-Non-decreasing-Array" class="headerlink" title="(Array)Non-decreasing Array"></a>(Array)Non-decreasing Array</h1><p><strong>非下降数组</strong><br><strong>Q:</strong>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<strong></strong>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could modify the first </span><br><span class="line"><span class="number">4</span></span><br><span class="line"> to </span><br><span class="line"><span class="number">1</span></span><br><span class="line"> to get a non-decreasing array.</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">False</span></span><br><span class="line">Explanation: You can<span class="string">'t get a non-decreasing array by modify at most one element.</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>:The n belongs to [1, 10,000].</p><p><strong>题意:</strong>给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。</p><p> <strong>Mysolution:</strong><br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">       num1 = nums.copy()</span><br><span class="line">       num2 = nums.copy()</span><br><span class="line">       <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">           <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">               num1[i] = num1[i+<span class="number">1</span>]</span><br><span class="line">               num2[i+<span class="number">1</span>] = num2[i]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">return</span> num1==sorted(num1) <span class="keyword">or</span> num2==sorted(num2)</span><br></pre></td></tr></table></figure></p><p><strong>借鉴了Discuss里 -Yangshun的思路:</strong>First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting.</p><hr><h1 id="Array-k-diff-Pairs-in-an-Array"><a href="#Array-k-diff-Pairs-in-an-Array" class="headerlink" title="(Array)k-diff Pairs in an Array"></a>(Array)k-diff Pairs in an Array</h1><p><strong>Q:</strong>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.<br><strong>Example 1:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: There are two <span class="number">2</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">and</span> (<span class="number">3</span>, <span class="number">5</span>).</span><br><span class="line">Although we have two <span class="number">1</span>s <span class="keyword">in</span> the input, we should only <span class="keyword">return</span> the number of unique pairs.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], k = <span class="number">1</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: There are four <span class="number">1</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>) <span class="keyword">and</span> (<span class="number">4</span>, <span class="number">5</span>).</span><br></pre></td></tr></table></figure></p><p><strong>Example 3:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], k = <span class="number">0</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> one <span class="number">0</span>-diff pair <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">1</span>).</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong><br>1.(1,3),(3,1)属于同一个数值对<br>2.k为负的时候返回0<br>3.注意处理k=0的情况<br>4.不要使用循环嵌套，必超时<br><strong> Mysolution </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 精简版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums))))</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">        <span class="keyword">return</span> len(set(sorted(nums)) &amp; set(map(<span class="keyword">lambda</span> x:x+k,nums)))</span><br></pre></td></tr></table></figure></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样写会好理解一些</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">           <span class="comment">#nums = list(filter(lambda x:nums.count(x)&gt;1,nums))</span></span><br><span class="line">           <span class="comment">#return len(set(nums))</span></span><br><span class="line">       nums = set(sorted(nums))</span><br><span class="line">       nums1 = set(map(<span class="keyword">lambda</span> x:x+k,nums))</span><br><span class="line">       <span class="keyword">return</span> len(nums &amp; nums1)</span><br></pre></td></tr></table></figure><p>思路：将数组中每个数+k后与原数组取交集</p><hr><h1 id="Hash-Table-Count-Primes"><a href="#Hash-Table-Count-Primes" class="headerlink" title="(Hash Table)Count Primes"></a>(Hash Table)Count Primes</h1><p><strong>Description:</strong><br>Count the number of prime numbers less than a non-negative number, <strong>n.</strong><br>计算小于正整数n的素数的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 一个长度为n的，值为True的list</span></span><br><span class="line">    primes = [<span class="keyword">True</span>] * n</span><br><span class="line">    <span class="comment"># 前两位置为False 0和1 都不是素数，最小的素数是2</span></span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数</span></span><br><span class="line">        <span class="comment"># 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了</span></span><br><span class="line">        <span class="keyword">if</span> primes[i]:</span><br><span class="line">            <span class="comment"># 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数</span></span><br><span class="line">            <span class="comment"># 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了</span></span><br><span class="line">            primes[i * i: n: i] = [<span class="keyword">False</span>] * len(primes[i * i: n: i])</span><br><span class="line">    <span class="comment"># 返回剩余的True的个数</span></span><br><span class="line">    <span class="keyword">return</span> sum(primes)</span><br></pre></td></tr></table></figure><p>这个算法实现的是<strong>埃拉托斯特尼筛法</strong>：<br>算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于  的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了）</p><hr><h1 id="Array-Medium-Insert-Delete-GetRandom-O-1"><a href="#Array-Medium-Insert-Delete-GetRandom-O-1" class="headerlink" title="(Array-Medium)Insert Delete GetRandom O(1)"></a>(Array-Medium)Insert Delete GetRandom O(1)</h1><p><strong>Description:</strong><br>Design a data structure that supports all following operations in average O(1) time.<br> 1.insert(val) : Inserts an item val to the set if not already present.<br> 2.remove(val) : Removes an item val from the set if present.<br> 3.getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned.</p><p><strong>Example：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">1</span> to the set. Returns true <span class="keyword">as</span> <span class="number">1</span> was inserted successfully.</span><br><span class="line">randomSet.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// Returns false <span class="keyword">as</span> <span class="number">2</span> does <span class="keyword">not</span> exist <span class="keyword">in</span> the set.</span><br><span class="line">randomSet.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">2</span> to the set, returns true. Set now contains [<span class="number">1</span>,<span class="number">2</span>].</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// getRandom should <span class="keyword">return</span> either <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes <span class="number">1</span> <span class="keyword">from</span> the set, returns true. Set now contains [<span class="number">2</span>].</span><br><span class="line">randomSet.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="number">2</span> was already <span class="keyword">in</span> the set, so <span class="keyword">return</span> false.</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Since <span class="number">2</span> <span class="keyword">is</span> the only number <span class="keyword">in</span> the set, getRandom always <span class="keyword">return</span> <span class="number">2.</span></span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p><p><strong> My Solution*</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Rset,self.Rlist = set(),[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Rset.add(val)</span><br><span class="line">            self.Rlist.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            self.Rset.remove(val)</span><br><span class="line">            self.Rlist.remove(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.Rlist)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素<br>再添加一个discuss里用<strong>字典</strong>和list来实现的代码，更快一些：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums, self.pos = [], &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.pos:</span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            self.pos[val] = len(self.nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.pos:</span><br><span class="line">            idx, last = self.pos[val], self.nums[<span class="number">-1</span>]</span><br><span class="line">            self.nums[idx], self.pos[last] = last, idx</span><br><span class="line">            self.nums.pop(); self.pos.pop(val, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[random.randint(<span class="number">0</span>, len(self.nums) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p><hr><h1 id="Array-medium-4Sum-拓展为Nsum问题"><a href="#Array-medium-4Sum-拓展为Nsum问题" class="headerlink" title="(Array-medium)4Sum(拓展为Nsum问题)"></a>(Array-medium)4Sum(拓展为Nsum问题)</h1><p><strong>Description</strong><br>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br><strong>Note:</strong> The solution set must not contain duplicate quadruplets.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Solution</strong>借鉴discuss的思路，很不错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N,nums,target,result,results)</span>:</span></span><br><span class="line">            <span class="comment"># 特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> N&gt;len(nums) <span class="keyword">or</span> target&gt;N*nums[<span class="number">-1</span>] <span class="keyword">or</span> target&lt;N*nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 高效的2Sum</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                        <span class="comment"># 补充到最终结果</span></span><br><span class="line">                        results.append(result + [nums[l], nums[r]])</span><br><span class="line">                        <span class="comment"># 左指针右移，同时右指针左移，因为已经排好序了，一个值不变另一个值变一定不会得到target</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 解决重复问题</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> r &gt; l <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 注意这里的范围，是到len(nums)-N+1,因为最后N个数为最后一组，无须再进行递归</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 结合sorted可解决重复问题</span></span><br><span class="line">                    <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> (i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]!=nums[i]):</span><br><span class="line">                        <span class="comment"># 递归，将nSum问题降为n-1Sum问题</span></span><br><span class="line">                        Nsum(N<span class="number">-1</span>,nums[i+<span class="number">1</span>:],target-nums[i],result+[nums[i]],results)</span><br><span class="line">        results = []</span><br><span class="line">        Nsum(<span class="number">4</span>,sorted(nums),target,[],results)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：给定一个list和一个target，求所有n个list中的数和为target的不重复组合。本题是4Sum，代码拓展为了nSum问题，主要思路是通过迭代来把问题转换为高效的2Sum问题，即nSum-&gt;n-1Sum-&gt;….-&gt;4Sum-&gt;3Sum-&gt;2Sum,具体细节在代码注释中。</p><hr><h1 id="Hash-Table-Repeated-DNA-Sequences"><a href="#Hash-Table-Repeated-DNA-Sequences" class="headerlink" title="(Hash-Table)Repeated DNA Sequences"></a>(Hash-Table)Repeated DNA Sequences</h1><p><strong>Description</strong>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.<br>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.<br>For example,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given s = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>].</span><br></pre></td></tr></table></figure></p><p>就是求一个字符串里的所有指定长度的重复子字符串。<br><strong>Mysolution</strong><br>class Solution(object):<br>    def findRepeatedDnaSequences(self, s):<br>        “””<br>        :type s: str<br>        :rtype: List[str]<br>        “””<br>        if len(s)<10: return="" []="" results="[]" dnadict="{}" for="" i="" in="" range(len(s)-9):="" if="" s[i:i+10]="" dnadict:="" dnadict[s[i:i+10]]="" +="1" else:="" key,value="" dnadict.items():="" value="">0:<br>                results.append(key)<br>        return results<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**思路** 循环切片判断是否重复，数据结构用的字典，注意的就是range的范围和切片的范围问题。将10替换为N可以变为求一个字符串中长度为N的重复子串。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># Longest Palindromic Substring</span><br><span class="line">经典的最大回文子字符串问题</span><br><span class="line">样例：</span><br><span class="line">``` python</span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></10:></p><p><strong>思路：</strong>从左到右依次把每个字符当做中心，然后依次判断两边的字符是否相等，最后取最大的那个就行了，唯一要注意的一点是连续字符的情况，比如 abccbd,这个时候要把cc整体作为一个字符串，这里用了两个位置变量，left和right，每次判断两边的相同字符之前要确定right的值，也就是相同字符的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            right = <span class="number">1</span></span><br><span class="line">            left = <span class="number">1</span></span><br><span class="line">            <span class="comment"># get the step length</span></span><br><span class="line">            <span class="keyword">while</span> i + right &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i + right] == s[i]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ((i -left ) &gt;= <span class="number">0</span> <span class="keyword">and</span> (i + right) &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i - left] == s[i + right]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            longest = s[i - left+<span class="number">1</span>:i + right]</span><br><span class="line">            <span class="keyword">if</span> len(longest) &gt; len(result):</span><br><span class="line">                result = longest</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h1 id="链表-Add-Two-Numbers"><a href="#链表-Add-Two-Numbers" class="headerlink" title="(链表)Add Two Numbers"></a>(链表)Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></p><p><strong>思路:</strong>就是由两个链表逆序表示的整数的和，没什么思路可言，这里主要考察的是对链表的操作，具体看代码，讲的很通俗易懂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s1 = str(l1.val)</span><br><span class="line">        s2 = str(l2.val)</span><br><span class="line">        <span class="keyword">while</span> l1.next:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            s1 = str(l1.val)+s1</span><br><span class="line">        <span class="keyword">while</span> l2.next:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            s2 = str(l2.val)+s2</span><br><span class="line">        result = str(int(s1)+int(s2))</span><br><span class="line">        <span class="comment"># 头节点</span></span><br><span class="line">        head = ListNode(int(result[<span class="number">-1</span>]))</span><br><span class="line">        after = head</span><br><span class="line">        <span class="comment"># 这里是对数组的操作，[-2::-1]表示从倒数第二个元素向后-1的取全部，注意这里[-2:0:-1]和[-2::-1]是不同的，前者取到下标为1，因为:左右就是[)的，后者取到数组头</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> result[<span class="number">-2</span>::<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># 新开辟一块内存空间</span></span><br><span class="line">            node = ListNode(int(c))</span><br><span class="line">            <span class="comment"># 让after.next指向这个内存空间，相当于把两个节点连接起来</span></span><br><span class="line">            after.next = node</span><br><span class="line">            <span class="comment"># after指向这块内存空间，方便下一个节点建立以后after代表这块内存空间去实行指向下一块新的节点的任务</span></span><br><span class="line">            after = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h1 id="字符串-最大字符不重复子串问题-Longest-Substring-Without-Repeating-Characters"><a href="#字符串-最大字符不重复子串问题-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="(字符串)最大字符不重复子串问题 Longest Substring Without Repeating Characters"></a>(字符串)最大字符不重复子串问题 Longest Substring Without Repeating Characters</h1><p>Given a string, find the length of the longest substring without repeating characters.<br><strong>Examples:</strong><br>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.<br>给定一个字符串，求其最大子串，要求子串中无重复字符</p><p><strong>思路:</strong>一开始我使用简单的从左到右每一个字符遍历最大子串，最后一个测试用例超时了，这里discuss里给出了一个特别好的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        usedChar = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="comment"># start是一个下表，表示这一轮新的字符串的开始下标</span></span><br><span class="line">        <span class="comment"># if s[i] in userChar 表示遍历到的当前字符曾经用过，有跟我当前新字符串重复的嫌疑</span></span><br><span class="line">        <span class="comment"># start &lt;= userChar[s[i]]就是说我去查查你上次出现的下标，如果是在start以后，也就是说在当前新字符串你已经出现过一次了，那么这次就算重复了</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">            <span class="comment"># 那么这次新字符串的遍历到此结束，start更新为上次这个下标出现的后一位字符，下面会有详细解释</span></span><br><span class="line">                start = usedChar[s[i]]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength = max(maxLength,i-start+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 每次都更新下标</span></span><br><span class="line">            usedChar[s[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">**举个例子说明**</span><br><span class="line">abczkoz543q</span><br><span class="line"></span><br><span class="line">从左到右遍历：(used 误拼为 user 了)</span><br><span class="line">a -&gt; not in userChar ; max(0,1)=1 ; userChar[a] = 0</span><br><span class="line">b -&gt; not in userChar ; max(1,2)=2 ; userChar[b] = 1</span><br><span class="line">c -&gt; not in userChar ; max(2,3)=3 ; userChar[c] = 2</span><br><span class="line">z -&gt; not in userChar ; max(3,4)=4 ; userChar[z] = 3</span><br><span class="line">k -&gt; not in userChar ; max(4,5)=5 ; userChar[k] = 4</span><br><span class="line">o -&gt; not in userChar ; max(5,6)=6 ; userChar[b] = 5</span><br><span class="line">(到这儿为止，字符串一直是从start=<span class="number">0</span>到当前下标，所以长度为<span class="number">6</span>)</span><br><span class="line">z -&gt; in userChar and start &lt; userChar[z]</span><br><span class="line">在这里z在下标为<span class="number">3</span>的时候出现过的，而当前字符串是从下标为<span class="number">0</span>开始的，所以这个字符串到此为止了，它贡献了maxLength=<span class="number">6</span></span><br><span class="line">然后更新start为<span class="number">3</span>+<span class="number">1</span>，也就是从z后面的k作为下一个字符串的开始下标</span><br><span class="line">这里就要从第二个开始继续遍历了，因为没必要从b开始再遍历，因为b也肯定会遍历第一个z然后遍历到第二个z，它形成的最大子串其实是a形成的最大子串的子串，即 bczko 属于 abzko</span><br><span class="line">所以直接从z的下一个元素，也就是k开始作为start即可，同时这里用到了字典，也降低了时间复杂度</span><br></pre></td></tr></table></figure><hr><h1 id="分治-两个数组的中位数-Median-of-Two-Sorted-Arrays"><a href="#分治-两个数组的中位数-Median-of-Two-Sorted-Arrays" class="headerlink" title="(分治)两个数组的中位数 Median of Two Sorted Arrays"></a>(分治)两个数组的中位数 Median of Two Sorted Arrays</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>限制时间复杂度是O(log(m+n))<br><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>思路:</strong>非常简单的一道题目，先用+连起来，sorted一下，如果是偶数就输出中间两个的均值，如果是奇数长度就输出中间那个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = sorted(nums1+nums2)</span><br><span class="line">        <span class="keyword">if</span> len(l)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (l[int(len(l)/<span class="number">2</span>)] + l[int(len(l)/<span class="number">2</span><span class="number">-1</span>)])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(l[int((len(l)<span class="number">-1</span>)/<span class="number">2</span>)])</span><br></pre></td></tr></table></figure></p><p><strong>但是</strong>其实这个复杂度是O(m+n),这种做法的思想基于下面这种做法一样，而且应该花的时间更长，是最优化最差也是最简单的做法：<br>依次遍历两个数组，每次取最小那个，直到遍历到第i个，这个i就是我们要的中位数或中间两个数，时间复杂度为O(m+n)<br><strong>有更好的做法：分治</strong><br>思路是分治常用的“割”，关键点是一条线割开两个数组，使得左边部分全部小于右边部分，这样就可以确定虚拟数组（两个数组合并排序）的前k个值了，妙啊妙啊。<br>这是O(min(m,n))的做法(感觉不够简练)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1)+len(nums2)&lt;=<span class="number">10</span>:</span><br><span class="line">            l = sorted(nums1 + nums2)</span><br><span class="line">            <span class="keyword">if</span> len(l) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> (float(l[int(len(l) / <span class="number">2</span>)]) + float(l[int(len(l) / <span class="number">2</span> - <span class="number">1</span>)])) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(l[int((len(l) - <span class="number">1</span>) / <span class="number">2</span>)])</span><br><span class="line">        <span class="keyword">if</span> len(nums1)&lt;len(nums2):</span><br><span class="line">            long = nums2</span><br><span class="line">            short = nums1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            long = nums1</span><br><span class="line">            short = nums2</span><br><span class="line">        <span class="keyword">if</span> (len(long)+len(short))%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 前面找k个数</span></span><br><span class="line">            k = ((len(nums1)+len(nums2))<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">            k1 = <span class="number">0</span></span><br><span class="line">            k2 = k - <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> ((k2 + <span class="number">1</span> &lt;= len(long) - <span class="number">1</span> <span class="keyword">and</span> short[k1] &gt; long[k2 + <span class="number">1</span>]) <span class="keyword">or</span> (</span><br><span class="line">                        k1 + <span class="number">1</span> &lt;= len(short) - <span class="number">1</span> <span class="keyword">and</span> long[k2] &gt; short[k1 + <span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">if</span> short[k1]&gt;long[k2+<span class="number">1</span>]:</span><br><span class="line">                    k1-=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k1+=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">            <span class="keyword">if</span> k1 + <span class="number">1</span> &lt;= len(short) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> min(short[k1 + <span class="number">1</span>], long[k2 + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> long[k2 + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = (len(nums1)+len(nums2))/<span class="number">2</span> <span class="number">-1</span></span><br><span class="line">            <span class="comment"># 割少的那个尾巴，注意下标</span></span><br><span class="line">            k1 = <span class="number">0</span></span><br><span class="line">            k2 = k<span class="number">-2</span></span><br><span class="line">            <span class="keyword">while</span>((k2+<span class="number">1</span>&lt;= len(long)<span class="number">-1</span> <span class="keyword">and</span> short[k1]&gt;long[k2+<span class="number">1</span>]) <span class="keyword">or</span> (k1+<span class="number">1</span> &lt;= len(short)<span class="number">-1</span> <span class="keyword">and</span> long[k2]&gt;short[k1+<span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">if</span> short[k1]&gt;long[k2+<span class="number">1</span>]:</span><br><span class="line">                    k1-=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k1+=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">            compareL = []</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k1+<span class="number">1</span>&lt;=len(short)<span class="number">-1</span> <span class="keyword">and</span> count &lt;<span class="number">2</span>:</span><br><span class="line">                compareL.append(short[k1+<span class="number">1</span>])</span><br><span class="line">                k1+=<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k2+<span class="number">1</span>&lt;=len(long)<span class="number">-1</span> <span class="keyword">and</span> count &lt;<span class="number">2</span>:</span><br><span class="line">                compareL.append(long[k2+<span class="number">1</span>])</span><br><span class="line">                k2+=<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            x1 = min(compareL)</span><br><span class="line">            compareL.remove(x1)</span><br><span class="line">            x2 = min(compareL)</span><br><span class="line">            <span class="keyword">return</span> (float(x1)+float(x2))/<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以加个二分查找就变为了O(log(min(m,n))),有空再更新吧</p><hr><h1 id="3Sum问题"><a href="#3Sum问题" class="headerlink" title="3Sum问题"></a>3Sum问题</h1><p>第二次重写Nsum问题，花了一个小时调试边界值，虽然基本思想没忘，但是对细节的处理很差，后面写上注意事项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N, L, subResult, target)</span>:</span></span><br><span class="line">            <span class="comment"># 这种写法的复杂度是nlog(n),超时了，改写为排序数组的2Sum写法</span></span><br><span class="line">            <span class="comment"># if N == 2:</span></span><br><span class="line">            <span class="comment">#     sumDict = &#123;&#125;</span></span><br><span class="line">            <span class="comment">#     for i in L:</span></span><br><span class="line">            <span class="comment">#         if i not in sumDict:</span></span><br><span class="line">            <span class="comment">#             sumDict[target - i] = i</span></span><br><span class="line">            <span class="comment">#         else:</span></span><br><span class="line">            <span class="comment">#             # 这里用了一个sorted来解决重复问题，不知道有没有更好的办法</span></span><br><span class="line">            <span class="comment">#             if sorted(subResult+[target-i,i]) not in result:</span></span><br><span class="line">            <span class="comment">#                 print subResult+[target-i,i]</span></span><br><span class="line">            <span class="comment">#                 result.append(sorted(subResult+[target-i,i]))</span></span><br><span class="line">            <span class="comment">#     return</span></span><br><span class="line">            <span class="keyword">if</span> N==<span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(L)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> r&gt;l:</span><br><span class="line">                    <span class="keyword">if</span> L[l]+L[r] == target:</span><br><span class="line">                        result.append(subResult+[L[r],L[l]])</span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> L[l] == L[l+<span class="number">1</span>]:</span><br><span class="line">                            l+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> L[r] == L[r<span class="number">-1</span>]:</span><br><span class="line">                            r-=<span class="number">1</span></span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L[l]+L[r] &gt; target:</span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L[l]+L[r] &lt; target:</span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 每次跳过重复字符</span></span><br><span class="line">                    <span class="comment"># while i&gt;1 and i&lt;len(L)-1 and L[i]==L[i-1]:</span></span><br><span class="line">                    <span class="comment">#     i+=1</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] != L[i]):</span><br><span class="line">                        Nsum(N - <span class="number">1</span>, L[i + <span class="number">1</span>:], subResult + [L[i]], target - L[i])</span><br><span class="line">        Nsum(<span class="number">3</span>,sorted(nums),[],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>1：</strong>思路依然是递归的将Nsum问题转化为2Sum问题，这里2Sum因为要找的值是不用管下标的，所以可以将数组排好序，这样可以将2Sum问题的时间<br>复杂度降为O(n),而找两个下标的2Sum问题的复杂度是O(nlogN),我一开始将两者弄混了，所以一开始用的找下标的那种方法，然后就超时了<br><strong>2：</strong>注意2Sum问题的时候，指针移动的时候，要先跳过所以重复值，加上l<r就可以防止边界问题 **3：**递归的地方我注释掉的部分，**while="" i="">1 and i&lt;len(L)-1 and L[i]==L[i-1]:**如果用这种方法来去掉遍历时候的重复值，会出现一些问题，比如[0,0,0,0,0]，<br>虽然跳过了0，但是最后一个0还是会进，这样就会出现输出为[[0,0,0],[0,0,0]]的情况，所以用if可以防止这种情况，只要和前面重复都不进。</r就可以防止边界问题></p><hr><h1 id="NSum-Closest问题"><a href="#NSum-Closest问题" class="headerlink" title="NSum Closest问题"></a>NSum Closest问题</h1><p>是Nsum问题的变形，但是原理差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 全局变量问题</span></span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    <span class="keyword">global</span> Min</span><br><span class="line">    Min = <span class="number">9999</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(N, L, Sum, target)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> result</span><br><span class="line">        <span class="keyword">global</span> Min</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 从L里找两个数，使得min(|(x1+x2+sum)-1|)</span></span><br><span class="line">            l, r = <span class="number">0</span>, len(L) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 先替换</span></span><br><span class="line">                <span class="keyword">if</span> Min &gt; abs(L[r] + L[l] + Sum - target):</span><br><span class="line">                    Min = abs(L[r] + L[l] + Sum - target)</span><br><span class="line">                    result = L[r] + L[l] + Sum</span><br><span class="line">                <span class="comment"># 是否特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> abs(L[r] + L[l] + Sum - target) ==<span class="number">0</span>:</span><br><span class="line">                    result = L[r] + L[l] + Sum</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># 移动指针</span></span><br><span class="line">                <span class="keyword">if</span> L[r] + L[l] + Sum &gt; target <span class="keyword">and</span> l&lt;r:</span><br><span class="line">                    r-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> L[r] + L[l] + Sum &lt;target <span class="keyword">and</span> l&lt;r:</span><br><span class="line">                    l+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L) - N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i] != L[i - <span class="number">1</span>]):</span><br><span class="line">                    findSum(N - <span class="number">1</span>, L[i + <span class="number">1</span>:], Sum + L[i], target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    findSum(<span class="number">3</span>, sorted(nums), <span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>还是递归的思想减少的2Sum问题，每次左右指针先算一次去替换最小，如果出现最优情况直接return，否则根据情况移动左右指针，跟Nsum还是有所区别。</p><hr><h1 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h1><p>数字组合，给出手机上的号码，每个号码对应着一组字母，求之间的有多少种组合方式<br>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="图片"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>就是一个简单的递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        kvmaps = &#123;</span><br><span class="line">            <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">            <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">            <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">            <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">            <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">            <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">            <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">            <span class="string">'9'</span>: <span class="string">'wxyz'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">comLetter</span><span class="params">(number, L)</span>:</span></span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">if</span> number == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> L == []:result = [x <span class="keyword">for</span> x <span class="keyword">in</span> kvmaps[number[<span class="number">0</span>]]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> kvmaps[number[<span class="number">0</span>]]:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> L:</span><br><span class="line">                        result.append(y+x)</span><br><span class="line">            <span class="keyword">if</span> len(number) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> comLetter(number[<span class="number">1</span>:], result)</span><br><span class="line">        <span class="keyword">return</span> comLetter(digits, [])</span><br></pre></td></tr></table></figure><hr><h1 id="动态规划-最长不下降或不上升子序列"><a href="#动态规划-最长不下降或不上升子序列" class="headerlink" title="动态规划 最长不下降或不上升子序列"></a>动态规划 最长不下降或不上升子序列</h1><p><a href="http://blog.csdn.net/wy19910326/article/details/7229350" target="_blank" rel="noopener">参考</a></p><hr><h1 id="O-n-复杂度根据index删除链表中的元素"><a href="#O-n-复杂度根据index删除链表中的元素" class="headerlink" title="O(n)复杂度根据index删除链表中的元素"></a>O(n)复杂度根据index删除链表中的元素</h1><p>给定一个链表，要求删除掉倒数第n个元素，然后返回head<br>例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>要求onepass，遍历一次<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> fast.next:</span><br><span class="line">                fast = fast.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            slow.next = slow.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：两个指针，一个在前一个在后，他们之间的间隔为n，那么当前面的那个指针到达链表的尾部的时候，后面那个指针的下一个元素就是要删除掉的元素，直接next = next.next跳过就可以了</p><hr><h1 id="括号匹配问题Generate-Parentheses"><a href="#括号匹配问题Generate-Parentheses" class="headerlink" title="括号匹配问题Generate Parentheses"></a>括号匹配问题Generate Parentheses</h1><p>给定一个数字，比如3，在3个括号的前提下求所有可能的括号匹配，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>回溯，注意两个点，一个是左括号一定等于右括号，第二个是左括号一定大于右括号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addParentheses</span><span class="params">(strP,left,right)</span>:</span></span><br><span class="line">            <span class="comment"># 如果还剩下左括号，优先安排左括号</span></span><br><span class="line">            <span class="keyword">if</span> left: addParentheses(strP+<span class="string">'('</span>,left<span class="number">-1</span>,right)</span><br><span class="line">            <span class="comment"># 如果右括号比左括号剩的多，再安排右括号</span></span><br><span class="line">            <span class="keyword">if</span> right&gt;left:addParentheses(strP+<span class="string">')'</span>,left,right<span class="number">-1</span>)</span><br><span class="line">            <span class="comment"># 这样，在递归的过程中，就可以列出所有可能的情况了</span></span><br><span class="line">            <span class="keyword">if</span> right==<span class="number">0</span>:</span><br><span class="line">                result.append(strP)</span><br><span class="line">        addParentheses(<span class="string">''</span>,n,n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>下面就3的例子画个图解释一下：</strong><br><img src="http://i2.bvimg.com/620746/73363b4f08d0bb26s.jpg" alt="Markdown"></p><hr><h1 id="交换链表节点"><a href="#交换链表节点" class="headerlink" title="交换链表节点"></a>交换链表节点</h1><p>从左到右，一次交换每两个节点<br>例如 1-&gt;2-&gt;3-&gt;4-&gt;5 到 2-&gt;1-&gt;4-&gt;3-&gt;5<br>要求不准使用多余的空间，不准改变链表的值<br><strong>My Solution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        current = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> head.next:</span><br><span class="line">            temp = head.next</span><br><span class="line">            head.next = head.next.next</span><br><span class="line">            temp.next = head</span><br><span class="line">            head = temp</span><br><span class="line">            current = head.next</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="keyword">if</span> current.next:</span><br><span class="line">                <span class="keyword">if</span> current.next.next:</span><br><span class="line">                    first = current.next</span><br><span class="line">                    second = current.next.next</span><br><span class="line">                    current.next = second</span><br><span class="line">                    first.next = second.next</span><br><span class="line">                    second.next = first</span><br><span class="line">                    current = current.next.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>因为头结点比较特殊，所以我把对头结点的交换和后面的交换给分开了，主要用到三个变量，current,first,scond,其中，first和second是要交换的节点，current是first的上一个节点，所以要判断后面是否有两个值可以交换要判断current.next.next是否为None,具体的交换思路看下图</p><p><img src="img/new1.jpg" alt="new1"></p><hr><h1 id="Reverse-Nodes-in-k-Group"><a href="#Reverse-Nodes-in-k-Group" class="headerlink" title="Reverse Nodes in k-Group"></a>Reverse Nodes in k-Group</h1><p>翻转链表中k-group，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p><p>感冒了脑子太僵了，先占个坑</p><hr><h1 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h1><p>下一个最大的数字串，如果不是最大的，就找一个最小的比它大的，如果已经已经最大了，找一个最小的,例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong></p><ul><li>从后往前遍历看看每一位是否能被替换</li><li>看每一位后面的所有字符是否有比它大的</li><li>挑出比它大的最小的那个来互换</li><li>互换完以后把该位后面的数按从小到大排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        AlreadyMax = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-2</span>,-len(nums)<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> max(nums[i:]) &gt; nums[i]:</span><br><span class="line">                AlreadyMax = <span class="number">0</span></span><br><span class="line">                min_index = <span class="number">0</span></span><br><span class="line">                minvalue = <span class="number">9999999</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)+i,len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &gt; nums[i] <span class="keyword">and</span> nums[j] &lt; minvalue:</span><br><span class="line">                        min_index = j</span><br><span class="line">                        minvalue = nums[j]</span><br><span class="line">                <span class="comment"># change</span></span><br><span class="line">                temp = nums[i]</span><br><span class="line">                nums[i] = nums[min_index]</span><br><span class="line">                nums[min_index] = temp</span><br><span class="line">                sortedList = sorted(nums[len(nums)+i+<span class="number">1</span>:])</span><br><span class="line">                m = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) + i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                    nums[j] = sortedList[m]</span><br><span class="line">                    m+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> AlreadyMax:</span><br><span class="line">            nums.reverse()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><hr><h1 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h1><p>翻转的有序数组里找个数，就是一个升序排序数组事先翻转了，例如：<br>0 1 2 4 5 6 7 -&gt; 4 5 6 7 0 1 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> nums.index(target) <span class="keyword">if</span> target <span class="keyword">in</span> nums <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findIndex</span><span class="params">(head, tail)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> tail - head &lt; <span class="number">3</span>:</span><br><span class="line">        result = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(head, tail + <span class="number">1</span>) <span class="keyword">if</span> nums[i] == target]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> result == [] <span class="keyword">else</span> result[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> nums[int((tail + head) / <span class="number">2</span>)]&gt;=nums[head]:</span><br><span class="line">        <span class="keyword">return</span> findIndex(head, int((tail + head) / <span class="number">2</span>)) <span class="keyword">if</span> nums[head]&lt;=target&lt;=nums[int((tail + head) / <span class="number">2</span>)] <span class="keyword">else</span> findIndex(int((tail + head) / <span class="number">2</span>), tail)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> findIndex(int((tail + head) / <span class="number">2</span>), tail) <span class="keyword">if</span> nums[int((tail + head) / <span class="number">2</span>)]&lt;=target&lt;=nums[tail] <span class="keyword">else</span> findIndex(head, int((tail + head) / <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> findIndex(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>思路：</strong><br>递归，参数为数组头和尾指针<br><img src="http://i1.bvimg.com/620746/63dcf9f59fae4d1cs.png" alt="Markdown"></p><hr><h1 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a>Search for a Range</h1><p><strong>找数组中某个数开始和结束的index</strong><br>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findIndex</span><span class="params">(head, tail)</span>:</span></span><br><span class="line">        halfIndex = int((tail + head) / <span class="number">2</span>)</span><br><span class="line">        halfNumber = nums[halfIndex]</span><br><span class="line">        <span class="keyword">if</span> nums[head] == nums[tail]:</span><br><span class="line">            <span class="keyword">return</span> [head,tail] <span class="keyword">if</span> nums[head]==target <span class="keyword">else</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> halfNumber != target <span class="keyword">and</span> halfIndex-head &gt; <span class="number">1</span> <span class="keyword">and</span> tail - halfIndex &gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> findIndex(head,halfIndex) <span class="keyword">if</span> target &lt; halfNumber <span class="keyword">else</span> findIndex(halfIndex,tail)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> halfIndex-head &gt; <span class="number">1</span> <span class="keyword">and</span> nums[int((head+halfIndex)/<span class="number">2</span>)]&lt;target:</span><br><span class="line">                head = int((head+halfIndex)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> tail - halfIndex &gt;<span class="number">1</span> <span class="keyword">and</span> nums[int((tail+halfIndex)/<span class="number">2</span>)]&gt;target:</span><br><span class="line">                tail = int((tail+halfIndex)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> tail &gt; head <span class="keyword">and</span> nums[head]!=target:</span><br><span class="line">                head+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> tail &gt; head <span class="keyword">and</span> nums[tail]!=target:</span><br><span class="line">                tail-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> findIndex(head,tail)</span><br><span class="line">    <span class="keyword">return</span> findIndex(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>二分法，我用的是从两边往中间缩，直到无法用二分法缩了以后，用while找到头和尾，详细一点：</p><ul><li>终止条件：如果头的值等于尾的值，判断是否等于target，是返回最终结果，否则[-1,-1]说明不在list里</li><li>如果中间值不等于target说明该值在左半部分或右半部分，递归</li><li>左边每次缩一半，如果还没遇到target的话，右边同理，缩到最小</li><li>左右多余一点儿裁掉，找到head和tail，返回<br><strong>注意：</strong>int((head+halfIndex)/2)如果两个index紧邻的话会无限重复，因为int(a,a+1)=a,需要判别</li></ul><hr><h1 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h1><p>给定一个正整数去重序列，求序列中所有和为target的非重复组合，每个数可以重复用，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Mysolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">        <span class="keyword">if</span> len(candidates)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        minValue = candidates[<span class="number">0</span>]</span><br><span class="line">        result= []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(Sum,tempL)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> Sum == <span class="number">0</span>:</span><br><span class="line">                final = sorted(tempL)</span><br><span class="line">                <span class="keyword">if</span> final <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                    result.append(final)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> candidates:</span><br><span class="line">                    <span class="keyword">if</span> Sum-x &gt;=<span class="number">0</span>:</span><br><span class="line">                        findSum(Sum-x,tempL+[x])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        findSum(target,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>递归，参数为每个子序列及其目前的和，每次用target减去总序列的每个值，如果为0，说明该子序列结束有解，如果为负数则无解，不添加该子序列。</p><hr><h1 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h1><p>与上个题基本一样，但是序列是重复的，并且每个数不能重复用，求所有和为target的非重复序列<br><strong>思路：</strong>递归参数加一个，nowCandidate，大小为遍历到的该数后面的序列[i+1:]<br><strong>solution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(candidates) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        minValue = candidates[<span class="number">0</span>]</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(Sum, tempL, nowCan)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> Sum == <span class="number">0</span>:</span><br><span class="line">                final = sorted(tempL)</span><br><span class="line">                <span class="keyword">if</span> final <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                    result.append(final)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nowCan)):</span><br><span class="line">                    <span class="keyword">if</span> Sum - nowCan[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                        findSum(Sum - nowCan[i], tempL + [nowCan[i]], nowCan[i+<span class="number">1</span>:])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        findSum(target, [], candidates)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h1><p>给定一个非重复整数串，求所有可能的子序排列，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>递归，从剩下的序列中遍历选取一个加入到目前子序列，再将这个数从剩下的子序列中删除<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findAll</span><span class="params">(nowL, remainL)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> remainL == []:</span><br><span class="line">                result.append(nowL)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remainL)):</span><br><span class="line">                tempL = remainL[:]</span><br><span class="line">                tempL.remove(remainL[i])</span><br><span class="line">                findAll(nowL + [remainL[i]], tempL)</span><br><span class="line">        findAll([], nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a>Permutations II</h1><p>与上题类似，但是给定序列中有重复数字，求所有可能的子序排列（去重复）<br>只要在上题的基础上在每次从剩余序列选值的时候加上跳过重复值得操作即可，首先要对整个序列排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findAll</span><span class="params">(nowL, remainL)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> remainL == []:</span><br><span class="line">                result.append(nowL)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remainL)):</span><br><span class="line">                <span class="comment"># 加入下面这一行,因为不管在哪一轮，如果有两个以上重复的，那么选他们任意超过两个后续操作必然重复，因为没有区别</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> (i&gt;<span class="number">0</span> <span class="keyword">and</span> remainL[i]!=remainL[i<span class="number">-1</span>]):</span><br><span class="line">                    tempL = remainL[:]</span><br><span class="line">                    tempL.remove(remainL[i])</span><br><span class="line">                    findAll(nowL + [remainL[i]], tempL)</span><br><span class="line"></span><br><span class="line">        findAll([], nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h1 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h1><p>判断给的已经填充一部分的数独是否有效<br><strong>思路：</strong><br>只需要判断三个条件：</p><ul><li>行不能重复</li><li>列不能重复</li><li>九宫格内不能重复<br>所以，依次遍历每一个填充的值，把i,j,position（位于哪个九宫格）加入字典，只要有一个重复就fail</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sudokuDict = &#123;&#125;</span><br><span class="line">        n = len(board)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 判断在哪个九宫格内</span></span><br><span class="line">                position = [int(i / <span class="number">3</span>), int(j / <span class="number">3</span>)]</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] <span class="keyword">not</span> <span class="keyword">in</span> sudokuDict:</span><br><span class="line">                        sudokuDict[board[i][j]] = [[i, j, position]]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">for</span> l <span class="keyword">in</span> sudokuDict[board[i][j]]:</span><br><span class="line">                            <span class="keyword">if</span> l[<span class="number">0</span>] == i <span class="keyword">or</span> l[<span class="number">1</span>] == j <span class="keyword">or</span> l[<span class="number">2</span>] == position:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            sudokuDict[board[i][j]].append([i, j, position])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h1><p>旋转二位数组，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix <span class="keyword">in</span>-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>每次遍历最外层的正方形的第一层，找到四个位置的对应关系，依次替换即可（不用管奇数偶数问题，因为最后中心即使剩下一个单独的值无需替换）<br><img src="http://i2.bvimg.com/620746/e9f1106b57504a32s.png" alt="Markdown"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(int(n/<span class="number">2</span>)):</span><br><span class="line">            start = i</span><br><span class="line">            <span class="comment"># 不包括ends</span></span><br><span class="line">            end = n-i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(start,end):</span><br><span class="line">                print(start,end)</span><br><span class="line">                print(i,j)</span><br><span class="line">                <span class="comment">#   matrix[i][j]   -&gt;    matrix[j][end]</span></span><br><span class="line">                <span class="comment">#         ↑               ↓</span></span><br><span class="line">                <span class="comment"># matrix[n-1-j][start] &lt;- matrix[n-1-i][n-1-j]</span></span><br><span class="line">                temp = matrix[j][end]</span><br><span class="line">                matrix[j][end] = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n<span class="number">-1</span>-j][start]</span><br><span class="line">                matrix[n<span class="number">-1</span>-j][start] = matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j]</span><br><span class="line">                matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j] = temp</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)leetcode刷题记录&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/1970/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/1970/01/01/数据结构/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-02-01T06:49:23.937Z</updated>
    
    <content type="html"><![CDATA[<p>#二叉树的相关概念<br>一 特殊的二叉树及其特点<br>1.斜树<br>2.满二叉树<br>3.完全二叉树<br>二 二叉树性质<br>1.一般二叉树性质<br>2.完全二叉树性质<br>三 二叉树遍历<br>1.前序遍历<br>2.中序遍历<br>3.后序遍历<br>四 二叉树的建立<br><strong><a href="https://www.cnblogs.com/polly333/p/4740355.html#0" target="_blank" rel="noopener">点击查看二叉树相关概念</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,v)</span>:</span></span><br><span class="line">        self.value = v</span><br><span class="line">        self.Lchild = <span class="keyword">None</span></span><br><span class="line">        self.Rchild = <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,v)</span>:</span></span><br><span class="line">        rootNode = Node(v)</span><br><span class="line">        self.root = rootNode</span><br><span class="line">    <span class="comment"># 只添加左子树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addLChild</span><span class="params">(self,v)</span>:</span></span><br><span class="line">        node = Node(v)</span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 去遍历每一个子节点，直到找到第一个没有左子树的节点，添加左子树</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = [self.root]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                currentNode = p.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> currentNode.Lchild == <span class="keyword">None</span>:</span><br><span class="line">                    currentNode.Lchild = node</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'添加左子树'</span>,v</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.append(currentNode.Lchild)</span><br><span class="line">                    <span class="keyword">if</span> currentNode.Rchild != <span class="keyword">None</span>:</span><br><span class="line">                        p.append(currentNode.Rchild)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 正常从左到右添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNode</span><span class="params">(self,v)</span>:</span></span><br><span class="line">        node = Node(v)</span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = [self.root]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="comment"># 用一个队列来实现从左到右的层遍历</span></span><br><span class="line">                currentNode = p.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>  currentNode.Lchild == <span class="keyword">None</span>:</span><br><span class="line">                    currentNode.Lchild = node</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'添加左节点'</span>,v</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> currentNode.Rchild == <span class="keyword">None</span>:</span><br><span class="line">                    currentNode.Rchild = node</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'添加右节点'</span>,v</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.append(currentNode.Lchild)</span><br><span class="line">                    p.append(currentNode.Rchild)</span><br><span class="line">    <span class="comment"># 按层遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'二叉树为空'</span></span><br><span class="line">        p = [self.root]</span><br><span class="line">        p_value = [self.root.value]</span><br><span class="line">        <span class="keyword">while</span> len(p)!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 用一个队列来实现从左到右的层遍历</span></span><br><span class="line">            current = p.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 原来很简单，按次序遍历数组p，然后把左右子树加到数组p，这样在二叉树中就相当于按层从左到右遍历了</span></span><br><span class="line">            <span class="keyword">if</span> current.Lchild != <span class="keyword">None</span>:</span><br><span class="line">                p.append(current.Lchild)</span><br><span class="line">                p_value.append(current.Lchild.value)</span><br><span class="line">            <span class="keyword">if</span> current.Rchild != <span class="keyword">None</span>:</span><br><span class="line">                p.append(current.Rchild)</span><br><span class="line">                p_value.append(current.Rchild.value)</span><br><span class="line">        <span class="keyword">print</span> p_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如何实现换行进行按层遍历二叉树</span></span><br><span class="line">    <span class="comment"># 也就是实现记录行号的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Better_traverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'二叉树为空'</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 可以通过两个变量来实现判断是否是最终的节点,lase,c_pos</span></span><br><span class="line">        last = self.root</span><br><span class="line">        Know_last = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        p = [self.root]</span><br><span class="line">        p_val = []</span><br><span class="line">        <span class="keyword">print</span> self.root.value</span><br><span class="line">        <span class="keyword">while</span> len(p)!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 用一个队列来实现从左到右的层遍历</span></span><br><span class="line">            current = p.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 原来很简单，按次序遍历数组p，然后把左右子树加到数组p，这样在二叉树中就相当于按层从左到右遍历了</span></span><br><span class="line">            <span class="keyword">if</span> current.Lchild != <span class="keyword">None</span>:</span><br><span class="line">                p.append(current.Lchild)</span><br><span class="line">                Know_last = current.Lchild</span><br><span class="line">                p_val.append(current.Lchild.value)</span><br><span class="line">            <span class="keyword">if</span> current.Rchild != <span class="keyword">None</span>:</span><br><span class="line">                p.append(current.Rchild)</span><br><span class="line">                Know_last = current.Rchild</span><br><span class="line">                p_val.append(current.Rchild.value)</span><br><span class="line">            <span class="keyword">if</span> current == last:</span><br><span class="line">                <span class="keyword">print</span> p_val</span><br><span class="line">                last = Know_last</span><br><span class="line">                p_val = []</span><br><span class="line">    <span class="comment"># 打印以root为根节点的第K层的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNodeAtLevel</span><span class="params">(self,root,lv)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> lv == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> root.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.Lchild:</span><br><span class="line">                self.printNodeAtLevel(root.Lchild,lv<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> root.Rchild:</span><br><span class="line">                self.printNodeAtLevel(root.Rchild, lv<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Tree(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t.addNode(i)</span><br><span class="line">t.Better_traverse()</span><br></pre></td></tr></table></figure><hr><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p><a href="https://github.com/wangpanjun/datastructure/blob/master/linkedlist/singleLinkedList.md" target="_blank" rel="noopener">参考链接</a><br> <strong>链表与数组的不同点</strong><br>1.数组需要预先定义大小，无法适应数据动态地增减，数据小于定义的长度会浪费内存，数据超过预定义的长度无法插入。而链表是动态增删数据，可以随意增加。<br>2.数组适用于获取元素的操作，直接get索引即可，链表对于获取元素比较麻烦需要从头一直寻找，但是适用与增删，直接修改节点的指向即可，但是对于数组就比较麻烦了，例如［1，2，3，4］需要在下标为1的位置插入－2，则需要将［2，3，4］后移，赋值ls[1]=-2<br>3.数组从栈中分配空间, 对于程序员方便快速,但自由度小。链表从堆中分配空间, 自由度大但申请管理比较麻烦.<br><strong>单链表python实现</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;各种数据结构的python实现&lt;/center&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>各公司校招算法题</title>
    <link href="http://yoursite.com/1970/01/01/%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/1970/01/01/校招算法题/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-10T15:57:58.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网易2018校园招聘编程题真题"><a href="#网易2018校园招聘编程题真题" class="headerlink" title="网易2018校园招聘编程题真题"></a>网易2018校园招聘编程题真题</h1><h2 id="魔法币"><a href="#魔法币" class="headerlink" title="魔法币"></a>魔法币</h2><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一行,包括一个正整数n(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">9</span>),表示小易需要的魔法币数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符<span class="string">'1'</span>和<span class="string">'2'</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = int(input()) </span><br><span class="line">arr=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStr</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 奇数</span></span><br><span class="line">            arr.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 偶数</span></span><br><span class="line">            arr.append(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-2</span>)/<span class="number">2</span>))</span><br><span class="line">getStr(n)</span><br><span class="line">arr.reverse()</span><br><span class="line">finalStr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalStr += str(x)</span><br><span class="line">print(finalStr)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong> 递归，如果最终结果是偶数，那么上一步一定用了机器2，奇数机器1同理</p><hr><p>##”相反数“”<br>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一个整数n,(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个整数,表示n的相反数</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">1325</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">6556</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> str(n)]</span><br><span class="line">arr.reverse()</span><br><span class="line">finalNumber = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalNumber+=x</span><br><span class="line">finalNumber = int(finalNumber)</span><br><span class="line"><span class="keyword">print</span> (finalNumber + n)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单</p><hr><p>##字符串碎片<br>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个字符串s,字符串s的长度length(<span class="number">1</span> ≤ length ≤ <span class="number">50</span>),s只含小写字母(<span class="string">'a'</span>-<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。</span><br><span class="line"></span><br><span class="line">如样例所示: s = <span class="string">"aaabbaaac"</span></span><br><span class="line">所有碎片的平均长度 = (<span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span>) / <span class="number">4</span> = <span class="number">2.25</span></span><br><span class="line"></span><br><span class="line">输入例子<span class="number">1</span>:</span><br><span class="line">aaabbaaac</span><br><span class="line"></span><br><span class="line">输出例子<span class="number">1</span>:</span><br><span class="line"><span class="number">2.25</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = str(input())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findS</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    sum=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i]!=s[i+<span class="number">1</span>]:</span><br><span class="line">            sum+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(s)/sum</span><br><span class="line">print(<span class="string">'%.2f'</span>%findS(s))</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单的题目，就注意格式化的时候，我一开始用round，报错3.50要求不能3.5，于是用了%.2f</p><hr><p>##重排数列</p><p>小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。<br>牛博士给小易出了一个难题:<br>对数列A进行重新排列,使数列A满足所有的A[i] * A<a href="1 ≤ i ≤ N - 1">i + 1</a>都是4的倍数。<br>小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line"><span class="comment">#输入的第一行为数列的个数t(1 ≤ t ≤ 10),</span></span><br><span class="line"><span class="comment">#接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)</span></span><br><span class="line"><span class="comment">#第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line"><span class="comment">#对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。</span></span><br><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="comment">#输入</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = int(input())</span><br><span class="line">resultArr = []</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = [int(y) <span class="keyword">for</span> y <span class="keyword">in</span> str(input()).split(<span class="string">' '</span>)]</span><br><span class="line">    dic[n] = arr</span><br><span class="line">    arr = [int(x%<span class="number">4</span>) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br><span class="line">    ji = arr.count(<span class="number">1</span>)+arr.count(<span class="number">3</span>)<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 有能被2整除的</span></span><br><span class="line">    <span class="keyword">if</span> arr.count(<span class="number">2</span>)&gt;<span class="number">0</span>:</span><br><span class="line">        arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x != <span class="number">2</span>]</span><br><span class="line">        arr.append(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#如果存在能被2整除的，这些数必须紧邻在一起当做一个奇数</span></span><br><span class="line">    <span class="keyword">if</span> float(arr.count(<span class="number">0</span>))&gt;=(len(arr)<span class="number">-1</span>)/<span class="number">2</span>:</span><br><span class="line">        resultArr.append(<span class="string">'Yes'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resultArr.append(<span class="string">'No'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> resultArr:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong> 如果有能被2整除的，那为了满足条件，它们必须紧挨着，那就相当于一个奇数，所以可以删除它们加进来一个奇数，那么数组就只剩下奇数和能被4整除的数了，那么满足被4整除的数插在奇数中间即可，即 n* &gt;= (len(array)-1)/2 或者 大于等于奇数-1，都一样.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)互联网公司校招算法题&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/1970/01/01/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/1970/01/01/剑指offer/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-02-06T08:51:21.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二位数组中的查找"><a href="#二位数组中的查找" class="headerlink" title="二位数组中的查找"></a>二位数组中的查找</h1><p><strong>题目描述</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>My solution</strong>:用递归来解，从右下向左上对角线遍历，每次把大矩阵分为左下右上两个小矩阵进行递归，终止条件是target位于对角线或矩阵只剩一行或一列遍历target（矩阵可能行列数不相同）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self,target, array)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">FindTarget</span><span class="params">(target, array)</span>:</span></span><br><span class="line">            <span class="comment"># 如果只有一行</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> target <span class="keyword">in</span> array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(array) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果只有一列</span></span><br><span class="line">                <span class="keyword">if</span> len(array[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> len(array[<span class="number">1</span>]) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> target <span class="keyword">in</span> [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="comment"># 其它情况</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    height = len(array)</span><br><span class="line">                    width = len(array[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">while</span> (height &gt; <span class="number">0</span> <span class="keyword">and</span> width &gt; <span class="number">0</span>):</span><br><span class="line">                        v = array[height - <span class="number">1</span>][width - <span class="number">1</span>]</span><br><span class="line">                        height -= <span class="number">1</span></span><br><span class="line">                        width -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> v == target:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">if</span> v &gt; target <span class="keyword">and</span> height!=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            remain1 = [x[width + <span class="number">1</span>:len(array[<span class="number">0</span>])] <span class="keyword">for</span> x <span class="keyword">in</span> array[:height+<span class="number">1</span>]]</span><br><span class="line">                            remain2 = [x[:width + <span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array[height + <span class="number">1</span>:len(array)]]</span><br><span class="line">                            <span class="keyword">return</span> (FindTarget(target, remain1)) <span class="keyword">or</span> (FindTarget(target, remain2))</span><br><span class="line">        result = <span class="keyword">False</span></span><br><span class="line">        result = FindTarget(target, array)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>简单做法：</strong><br>从左下开始遍历，比target大就往上，比target小就往下（妈的，看完很气，还特么辛苦写了个递归，这个简单做法太简单就不写了，╭(╯^╰)╮）</p><hr><h1 id="从尾到头打印列表"><a href="#从尾到头打印列表" class="headerlink" title="从尾到头打印列表"></a>从尾到头打印列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l = []</span><br><span class="line">        head = listNode</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l.insert(<span class="number">0</span>, head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p>很简单，注意是<strong>while head</strong> 不是 <strong>while head.next</strong></p><hr><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><strong>题目描述：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><strong>思路</strong><br>就是一个数组，把从后面切片放到前面来，让找最小数字，最简单的做法是直接min()函数，但是耗时<br>我的做法是使用递归，如果数组中间的数比开头的小，那么说明最小的数在这个切片里，不然就在后半切片里<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array)&lt;<span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> min(array)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&gt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[int(len(array)/<span class="number">2</span>):])</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&lt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[:int(len(array)/<span class="number">2</span>)+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> findMin(rotateArray)</span><br></pre></td></tr></table></figure></p><p>再优化一点就是从左到右找，找到下一个比当前的小了说明下一个就是最小值</p><hr><h1 id="输出斐波那契数列第n个数"><a href="#输出斐波那契数列第n个数" class="headerlink" title="输出斐波那契数列第n个数"></a>输出斐波那契数列第n个数</h1><p><strong>递归做法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getN</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getN(n - <span class="number">1</span>) + getN(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> getN(n)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**数组做法**</span><br><span class="line">``` python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> a[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">                a.append(a[<span class="number">-1</span>]+a[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p><strong>三个变量做法</strong>最快</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">        int one = <span class="number">0</span>;</span><br><span class="line">        int two = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> one;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> two;</span><br><span class="line">        int result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            result = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="斐波那契数列扩展"><a href="#斐波那契数列扩展" class="headerlink" title="斐波那契数列扩展"></a>斐波那契数列扩展</h1><p><strong>问题</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路</strong><br>一个青蛙跳到第k个台阶，对于k-1个台阶来说只有一种跳法，就是跳1级，对k-2级台阶来说就是跳两级，也只有一种跳法，所以跳到第k个台阶的做法就是跳到第k-1个台阶的做法+跳到第k-2个台阶的做法<br>也就是 <strong>斐波那契数列！</strong><br>精彩</p><hr><h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><p><strong>问题：</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路：</strong><br>跟上题类似，但是青蛙上次的位置不限于k-1和k-2了，可以在任何位置，用递归来实现，核心思想是：<br>**递归的加上一次所有可能的位置（1到k-1）加上从0直接到当前位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAlljumps</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sum([findAlljumps(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n)],<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> findAlljumps(number)</span><br></pre></td></tr></table></figure><hr><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><p><strong>题目：</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2<em>n的大矩形，总共有多少种方法？<br><em>*思路：</em></em>用从后往前的递归方法想一下，先填满，然后依次往外拿，行已经知道是2了，列为n列，那么就是求f(n),递归往前一步想，有两类往外拿的方法，一个是拿一个横的，一个是拿一个竖着的，如果拿出一个竖着的，那么其实就是f(n-1)然后填一个竖着的到f(n),如果拿一个横着的（其实相当于拿出两个横着的，因为不管拿上面还是下面的横着的，它对应的上面或下面的那个横着的没有其它拿法，所以相当于f(n-2),所以这道题其实又是一个斐波那契数列的问题了）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last = <span class="number">1</span></span><br><span class="line">        current = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> number<span class="number">-2</span>&gt;<span class="number">0</span>:</span><br><span class="line">            temp = current</span><br><span class="line">            current = last + current</span><br><span class="line">            last = temp</span><br><span class="line">            number-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure></p><hr><h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p><strong>题目：</strong><br>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><strong>思路：</strong>用递归上下左右的满足条件去走，每走一步count+1，具体的条件：<br>1.下一步不超边界<br>2.下一步满足横纵坐标各个位数之和不大于k<br>3.下一步不重复（可以把走过的位置用字典存起来）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(threshold, rows, cols)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> rows==cols==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    count = []</span><br><span class="line">    hasGone = &#123;&#125;</span><br><span class="line">    hasGone[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSmaller</span><span class="params">(n, x, y)</span>:</span></span><br><span class="line">        xSum = <span class="number">0</span></span><br><span class="line">        ySum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str(x))):</span><br><span class="line">            xSum += int(str(x)[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(str(y))):</span><br><span class="line">            ySum += int(str(y)[j])</span><br><span class="line">        <span class="keyword">if</span> xSum+ySum &gt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'调用'</span>)</span><br><span class="line">        count.append(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(i,j)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="comment"># 往上走</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i<span class="number">-1</span>,j):</span><br><span class="line">                <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i<span class="number">-1</span>] = [j]</span><br><span class="line">                    move(i - <span class="number">1</span>, j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i<span class="number">-1</span>]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i<span class="number">-1</span>] += [j]</span><br><span class="line">                        move(i - <span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 往下走</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;rows<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i+<span class="number">1</span>,j):</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i+<span class="number">1</span>] = [j]</span><br><span class="line">                    move(i + <span class="number">1</span>, j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i+<span class="number">1</span>]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i+<span class="number">1</span>] += [j]</span><br><span class="line">                        move(i + <span class="number">1</span>, j)</span><br><span class="line">        <span class="comment"># 往左</span></span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i,j<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i] = [j<span class="number">-1</span>]</span><br><span class="line">                    move(i, j<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i] += [j<span class="number">-1</span>]</span><br><span class="line">                        move(i, j<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">if</span> j&lt;cols<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i,j+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i] = [j+<span class="number">1</span>]</span><br><span class="line">                    move(i, j+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i] += [j+<span class="number">1</span>]</span><br><span class="line">                        move(i, j+<span class="number">1</span>)</span><br><span class="line">    move(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> sum(count)+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p><strong>题目：</strong><br>设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><strong>思路：</strong><br>想把输出按照行列换成对应的矩阵，然后找到所有的开头点，对于每个开头点：<br>先把指针cur指向path的下一个字符</p><ul><li>递归，上下左右查看</li><li>如果满足边界内并且非重复并且是cur当前所指的字符</li><li>指针+1，横纵坐标对应操作一并当做参数进行下一轮递归，坐标加入已经走过的坐标字典<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> path <span class="keyword">in</span> matrix:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">finalfind</span><span class="params">()</span>:</span></span><br><span class="line">            result.append(<span class="number">1</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findStr</span><span class="params">(i,j,cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur == len(path):</span><br><span class="line">                finalfind()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> cur &lt; len(path):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 往上</span></span><br><span class="line">                    <span class="keyword">if</span> M[i<span class="number">-1</span>][j] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i<span class="number">-1</span>]:</span><br><span class="line">                                GoneDict[i<span class="number">-1</span>]+=[j]</span><br><span class="line">                                <span class="comment">#print('shang',i-1,j)</span></span><br><span class="line">                                findStr(i<span class="number">-1</span>,j,cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i<span class="number">-1</span>] = [j]</span><br><span class="line">                            <span class="comment">#print('shang', i - 1, j)</span></span><br><span class="line">                            findStr(i - <span class="number">1</span>, j, cur+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> i&lt;rows<span class="number">-1</span>:</span><br><span class="line">                    <span class="comment"># 往下</span></span><br><span class="line">                    <span class="keyword">if</span> M[i + <span class="number">1</span>][j] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i + <span class="number">1</span> <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i + <span class="number">1</span>]:</span><br><span class="line">                                GoneDict[i + <span class="number">1</span>] += [j]</span><br><span class="line">                                <span class="comment">#print('xia', i + 1, j)</span></span><br><span class="line">                                findStr(i + <span class="number">1</span>, j, cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i + <span class="number">1</span>] = [j]</span><br><span class="line">                            findStr(i + <span class="number">1</span>, j, cur+<span class="number">1</span>)</span><br><span class="line">                            </span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 左</span></span><br><span class="line">                    <span class="keyword">if</span> M[i][j<span class="number">-1</span>] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i]:</span><br><span class="line">                                GoneDict[i] += [j<span class="number">-1</span>]</span><br><span class="line">                                <span class="comment">#print('zuo', i, j-1)</span></span><br><span class="line">                                findStr(i, j<span class="number">-1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i] = [j<span class="number">-1</span>]</span><br><span class="line">                            <span class="comment">#print('zuo', i, j - 1)</span></span><br><span class="line">                            findStr(i, j<span class="number">-1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                            </span><br><span class="line">                <span class="keyword">if</span> j&lt;cols<span class="number">-1</span>:</span><br><span class="line">                    <span class="comment"># 右</span></span><br><span class="line">                    <span class="keyword">if</span> M[i][j+<span class="number">1</span>] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i]:</span><br><span class="line">                                GoneDict[i] += [j+<span class="number">1</span>]</span><br><span class="line">                                <span class="comment">#print('you', i, j + 1)</span></span><br><span class="line">                                findStr(i, j+<span class="number">1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i] = [j+<span class="number">1</span>]</span><br><span class="line">                            <span class="comment">#print('you', i, j + 1)</span></span><br><span class="line">                            findStr(i, j+<span class="number">1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                            </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        GoneDict = &#123;&#125;</span><br><span class="line">        M = []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = cols</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            M.append([x <span class="keyword">for</span> x <span class="keyword">in</span> matrix[start:end]])</span><br><span class="line">            start = end</span><br><span class="line">            end += cols</span><br><span class="line">        <span class="comment"># 记录当前查询的位置</span></span><br><span class="line">        startPoint = []</span><br><span class="line">        <span class="comment"># 找到所有开头的节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> M[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                    startPoint.append([i,j])</span><br><span class="line">        <span class="keyword">if</span> startPoint:</span><br><span class="line">            <span class="keyword">for</span> point <span class="keyword">in</span> startPoint:</span><br><span class="line">                <span class="comment"># 对于每一个头重置字典</span></span><br><span class="line">                GoneDict = &#123;&#125;</span><br><span class="line">                <span class="comment"># 先把开头的节点放入字典</span></span><br><span class="line">                GoneDict[point[<span class="number">0</span>]] = [point[<span class="number">1</span>]]</span><br><span class="line">                findStr(point[<span class="number">0</span>],point[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> result ==<span class="keyword">True</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><p><strong>题目：</strong><br>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> size==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> size &gt; len(num):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num) -size+ <span class="number">1</span>):</span><br><span class="line">        result.append(max(num[i:i + size]))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="二叉搜索树的第K个节点"><a href="#二叉搜索树的第K个节点" class="headerlink" title="二叉搜索树的第K个节点"></a>二叉搜索树的第K个节点</h1><p>二叉搜索数的中序遍历是有序的，因此只要把第k个节点返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 特殊情况1</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">middle</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            middle(root.left)</span><br><span class="line">            result.append(root)</span><br><span class="line">            middle(root.right)</span><br><span class="line">        middle(pRoot)</span><br><span class="line">        <span class="comment"># 特殊情况2</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;len(result):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> result[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)剑指offer&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
