<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨一瓶</title>
  
  <subtitle>非常に広い肩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-11T13:27:55.064Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yangyiqing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;center&gt;决策树原理&lt;/center&gt;</title>
    <link href="http://yoursite.com/2088/03/09/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2088/03/09/决策树/</id>
    <published>2088-03-09T08:10:10.000Z</published>
    <updated>2018-03-11T13:27:55.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>[该博客为本网站作者: yangyiqing 原创，转载请注明出处]</p><h1 id="决策树概念"><a href="#决策树概念" class="headerlink" title="决策树概念"></a>决策树概念</h1><p>1.决策树学习通常分为三个步骤：</p><ul><li>特征选择</li><li>决策树生成</li><li>剪枝</li></ul><p>2.可以将决策树看成一个if-else规则的集合，其特点是<strong>所有的路径互斥且完备</strong>，给出一个测试用例，有且只有一条路径满足条件。<br>3.决策树还表示给定特征条件下的条件概率分布，这一条件概率分布定义特征空间的一个划分上，决策树的一条路径对应于划分中的一个单元，<strong>决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成</strong>。<br><img src="/2088/03/09/决策树/tree1.jpg" alt=""><br>4.<strong>决策树的学习的损失函数通常是正则化的极大似然函数</strong>，决策树学习的策略是以损失函数为目标函数的最小化<br>5.<br>“从所有可能的决策树种选择最优决策树是NP完全问题，所以现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题，这样得到的决策数是‘次最优’的” – 《统计学习方法》<br><strong>我的理解是由于最优决策树是不可推导的(只能列举全部可能情况)，所以只能通过局部最优解来递归的解决，在特征选择的过程中每次选择信息增益最大的特征来作为当前划分区域的特征,也就是递归的解局部最优</strong></p><h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>特征选择是选择对数据具有良好区分度的特征，通常对决策树来说衡量特征对label区分度的能力用信息增益或信息增益比来表示。<br>以书上的数据表作为例子：<br><img src="/2088/03/09/决策树/5.1.png" alt=""><br>为了从中找出更有区分度的特征，这里引入信息增益的概念:</p><h2 id="熵-entropy"><a href="#熵-entropy" class="headerlink" title="熵(entropy)"></a><strong>熵(entropy)</strong></h2><p>是表示随机变量不确定性的度量，对熵的定义:<br>在信息论与概率统计中，熵是表示随机变量不确定性的度量。设X是一个取有限个值得离散随机变量，其概率分布为<br><strong>$$P(X = x_i)=p_i,i=1,2,3..n$$</strong><br>则随机变量X的熵定义为<br><strong>$$H(x)=-\sum_{i=1}^np_ilog_2p_i$$</strong><br>熵越大，随机变量的不确定性就越大，举例当随机变量只有两个取值的时候:<br>$$H(p)=-plog_2p-(1-p)log_2(1-p)$$<br>这个时候，熵随着概率p的变化曲线如下图所示，当概率为0.5的时候，也就是取两个值得概率相等时，熵的值最大。这也很容易理解，<strong>因为当两个值取值相等时，不确定性最大，而熵又是衡量随机变量的不确定性的，所以此时熵最大</strong>。<br><img src="/2088/03/09/决策树/4.png" alt=""></p><h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a><strong>条件熵</strong></h2><p>随机变量X给定条件下随机变量Y的条件熵H(Y|X)，定义为X为给定条件下的Y的条件概率分布的熵对X的数学期望:<br>$$H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)$$</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a><strong>信息增益</strong></h2><p>表示得到特征X的信息以后使得类Y的信息不确定性减少的程度。<br>比如有个本来的经验熵为H(D),这个时候又加入了一个特征A，那么加入特征A以后的经验熵就是H(D|A),则信息增益：$g(D,A) = H(D) - H(D|A)$<br><strong>假设本来的经验熵为1，加入特征A以后的经验熵变为0.8,那么信息熵就减少了0.2,说明类别的不确定性减少了，那么对于分类来说就更准确了</strong><br>一般来说，熵与条件熵之差称为<strong>互信息</strong>，决策树学习中的信息增益等价于训练数据集中类与特征的互信息</p><h3 id="信息增益算法"><a href="#信息增益算法" class="headerlink" title="信息增益算法"></a>信息增益算法</h3><p>(1) 计算数据集D的<strong>经验熵H(D)</strong><br>其中k是指一共多少个类别，Ck是该类别在数据集D中出现的次数</p><p>$$H(D)=-\sum_{k=1}^K\frac{|C_k|}{D}log_2\frac{|C_k|}{|D|}$$</p><p>(2) 计算特征A对数据集D的条件经验熵H(D|A)<br>其中n是指特征A中的类别，k是指label的类别</p><p>$$H(D|A)=\sum_{i=1}^n\frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^n\frac{|D_i|}{|D|}\sum_{k=1}^K\frac{|D_ik|}{|D_i|}log_2\frac{|D_ik|}{|D_i|}$$</p><p>(3) 计算信息增益</p><p>根据以上公式，可以计算上面例子数据集中每个特征的信息增益：<br>$$-\frac{2}{5}log\frac{2}{5}-\frac{3}{5}log\frac{3}{5}=0.971$$<br>然后计算每个特征的信息增益:<br>以年龄特征为例：<br>$$g(D,A_1)=H(D)-[\frac{5}{15}H(D_1)+\frac{5}{15}H(D_2)+\frac{5}{15}H(D_2)]$$<br>其中以$H(D_1)$为例：<br><img src="/2088/03/09/决策树/9.png" alt=""><br>$$H(D_1)=-\frac{2}{5}log\frac{2}{5}-\frac{3}{5}log\frac{3}{5}$$<br>其余同理，这样最终算出的信息增益:<br>$g(D,A1) = 0.083$<br>$g(D,A2) = 0.324$<br>$g(D,A3) = 0.420$<br>$g(D,A4) = 0.363$<br>这样，特征A3的信息增益最大，所以选择A3作为最优特征。</p><h2 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h2><h3 id="引入信息增益比的原因"><a href="#引入信息增益比的原因" class="headerlink" title="引入信息增益比的原因"></a>引入信息增益比的原因</h3><p>只依赖信息增益来选择特征可能会出现问题，会存在偏向于选择取值较多的特征，就是哪个特征中的类别越多，可能其信息增益就会越大，<strong>原因是分类越多，那么在子数据集中lable全部相同的概率就越大（一种极端情况），在这种情况下，该子数据集的熵为0，如果这种子数据集多的话，那么其条件熵$H(D|A)$就会越小,那么$g(D,A) = H(D) - H(D|A)$就会越大。</strong></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>$$信息增益比 = \frac{信息增益}{特征A的熵}$$<br>一目了然，引入了特征A的熵最为分母，特征A的取值(类别数)越多，那么其熵值越大，这样就防止了因为取值多而造成的偏向问题</p><h1 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h1><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><p><strong>核心思想：</strong>从跟节点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，然后在其子结点上递归使用此方法，直到达不到信息增益阈值或没有特征可以选择为止。</p><p><strong>使用ID3算法对例子进行二叉树的构建</strong><br>首先根据上面的计算结果选取信息增益最大的特征(有没有房子)，然后根据有无房子分为左右子节点，发现左子数据集所有的lable都是是，所以左子树结束。<br><img src="/2088/03/09/决策树/10.png" alt=""><br><img src="/2088/03/09/决策树/11.png" alt=""><br>继续对右节点进行划分，剩下的特征有“年龄”，“工作”，“信贷情况”，这个时候需要重新计算$D_2$(没有房子数据集)的信息熵，以及各个特征的信息增益：<br>$g(D_2,A_1)=H(D_2)-H(D_2|A_1)=0.251$<br>$g(D_2,A_2)=0.918$<br>$g(D_2,A_4)=0.474$<br>可以发现$A_2$的信息增益最大，选择是否有工作作为当前最优特征对数据集进行划分，后面依次递归。<br><img src="/2088/03/09/决策树/12.png" alt=""><br><strong>这样就仅基于信息增益生成了一颗决策树，但是仅仅这样还不够，容易产生过拟合</strong></p><h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h2><p>与ID3算法类似，不同的地方是在特征选择的时候利用<strong>信息增益比</strong>来选择特征，这样可以在防止ID3算法的过拟合方面上有了改进。</p><blockquote></blockquote><p><strong>查看ID3算法的决策树生成代码<a href="http://yangyiqing.cn/2017/12/13/DTree/" target="_blank" rel="noopener">点击这里</a></strong></p><h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><p>按照ID3或C4.5算法生成的决策树，可能对训练数据集有比较好的准确度，但是<strong>对未知数据的预测能力却不一定比较好</strong>，因为在训练过程中为了拟合训练数据而构造了很复杂的决策树的话，就会产生<strong>过拟合</strong>。解决这一问题的方法就是对决策树进行剪枝。<br><strong>剪枝</strong>的目的是为了同时兼顾模型对训练集的拟合程度以及减少模型的复杂度来提高预测能力，那就不能仅仅使用信息增益来判别，还要加入<strong>带有模型复杂度的项对过于复杂的模型进行惩罚</strong>。<br>在这里定义决策树的<strong>损失函数</strong>(代价函数)：<br>设数的叶节点个数为$|T|$,$t$是$T$的叶节点，该叶节点有$N_t个$样本，其中$k$类的样本有$N_{tk}$个，$k=1,2,3,…K$,$H_t(T)$为叶节点上$t$的经验熵，$α&gt;=0$为参数,则决策树学习的<strong>损失函数</strong>可以定义为：<br>$$C_α(T) = \sum_{t=1}^{|T|}N_tH_t(T)+α|T| $$<br>其中<strong>经验熵</strong>为：<br>$$H_t(T) = -\sum_k \frac{N_{tk}}{N_t}\log\frac{N_{tk}}{N_t}$$</p><p><strong>解释</strong><br>损失函数计算的是<strong>每个叶节点的样本数和每个叶节点的经验熵的乘积</strong>的累加和最终加上<strong>以叶节点个数为基础的惩罚项</strong>，经验熵就是之前介绍计算数据集D的经验熵的公式。<br><strong>为什么每个叶节点可以计算经验熵呢，叶节点不是都属于同一类吗？其实每个叶节点并不一定都属于同一个类</strong>，因为在树的生成过程中，生成叶子节点的条件并不仅仅是划分到子数据集只剩下一个类，<strong>如果小于某个信息增益(ID3)或信息增益比(C4.5)的话，也会直接生成叶节点</strong>，这个时候按照子数据集中占比最大的类作为叶子节点的类别</p><p>对于$C_α(T)$来说，左半边表示的训练数据的误差，也就是<strong>训练数据的拟合程度</strong>，而$|T|$表示<strong>模型复杂度</strong>，$α$来控制两者之间的关系，相当于一个<strong>惩罚系数</strong>。当$α$确定以后，剪枝的策略就是<strong>使得损失函数$C_α(T)$最小化</strong>。可以看出，决策树生成学习局部的模型，而决策树剪枝学习整体的模型。</p><p><strong>决策树的损失函数最小化相当于正则化的极大似然估计</strong><br><strong>决策树的剪枝算法：</strong><br>输入：生成算法产生的整个树T，参数α：<br>输出：修建后的子树Tα<br>（1） 计算每个结点的经验熵<br>（2） 递归地从树的叶结点向上回缩<br>设一组叶结点回缩到其父结点之前与之后的整体树分别为$T_B$与$T_A$，其对应的损失函数值分别为$C_α(T_B)$与$C_α(T_A)$，<strong>如果</strong><br><strong>$$C_{\alpha}(T_A)\le C_{\alpha}(T_B)$$</strong><br><strong>则进行剪枝</strong>，即将父结点变为新的叶结点。(3)返回(2)，直至不能继续为止，得到损失函数最小的子树$T_α$</p><h2 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h2><p><strong>CART(classification and regression tree)是指分类与回归树</strong>，同样特征选择，树的生成，树的剪枝构成，既可以用于<strong>分类也可以用于回归</strong>，<strong>CART是二叉树</strong>。<br>得到D以后，CART算法<strong>递归的二分每个特征</strong>，将数据集划分为有限个单元，给定一个测试用例，则其预测依据为<strong>给定条件下的条件概率分布</strong>。<br><strong>(1) 决策树的生成</strong><br>CART算法在树的生成过程中递归的二分特征，要求构建的树要尽量大，关于特征选择的评估指标，在ID3算法中是信息增益，在C4.5算法中是信息增益比，而在CART算法中，特征选择的评估标准是：<br>$$\begin{cases}<br>分类树：基尼系数\<br>回归树：平方误差\<br>\end{cases}<br>$$<br>依据最小化这两个评估标准的原则进行特征选择，在选择完特征以后把特征划分为<strong>两部分</strong>。<br><strong>那么怎么样根据这个评估标准来选择最优特征呢</strong>，在ID3和C4.5算法中，可以根据每个特征计算其信息增益和信息增益比，平方误差和基尼系数的在CART的生成树算法中是这样运用的：<br><strong>1.1 最小二乘回归树算法</strong><br>选择最优切分特征j和最优切分点，根据以下公式：<br>$$min_{j,s}[min_{c1}\sum_{x_i∈R_1(j,s)}(y_i-c_1)^2+min_{c2}\sum_{x_i∈R_2(j,s)}(y_i-c_2)^2]$$<br>（<strong>$c_1,c_2$是切分点左右部分的y的均值</strong>）<br>其含义是遍历每个特征j，在j确定的条件下，遍历切分点s，这样就找到了$minL(j,s)$,<strong>比较所有的局部最优平方误差，找到最优的特征及其切分点作为当前的特征和划分依据</strong>。<br>然后对当前的数据集进行划分：<br>$$R_1(j,s)={x|x^{(j)}≤s},R_2(j,s)={x|x^{(j)}≥s}$$<br>然后<strong>每个单元的输出值为当前单元的子数据集的label的平均值</strong><br>$$C_m = \frac{1}{N_m}\sum_{x_i∈R_m(j,s)}y_i,x∈R_m,m=1,2$$<br>重复上述步骤直到达到停止条件，最后划分树的叶节点个数为M，在最终的回归树模型为：<br>$$f(x)=\sum_{m=1}^Mc_mI(x∈R_m)$$<br><strong>解释：</strong>这里的累加并不是真正意义上的累加，因为后面跟了一个<strong>Indicator函数</strong>，当输入落在哪个小区域(叶节点)上的时候，其<strong>对应的值为改区域的子数据集的label均值$c_m$</strong>。</p><p><strong>1.2 分类树的生成</strong><br>首先引入<strong>基尼指数</strong>的概念：<br>假设有K个类，样本点属于第k类的概率为$p_k$,则该数据集的基尼指数为：<br>$$Gini(p)=\sum_{k=1}^Kp_k(1-p_k)=1-\sum_{k=1}^K(\frac{|D_k|}{|D|})^2$$<br><strong>即：1-(各类别占比平方和累加)</strong></p><p><strong>基尼指数的意义：</strong>基尼指数表示数据集的不确定性，基尼指数越大，数据集的不确定性越大，和熵类似。下图是在二分类中基尼指数和熵，分类误差率的关系：<br><img src="/2088/03/09/决策树/14.png" alt=""></p><p><strong>CART分类树生成算法</strong><br>与回归树类似，也是递归的进行特征选择，然后分左右节点，因为都是二叉树嘛。下面着重讲讲不同的地方。<br>第一个点当然是特征选择的依据不同，回归树在进行特征选择的时候是嵌套循环遍历每一个特征和每一个特征中可能的切分点。对于分类算法来说同样适用，不同点在于<strong>选取切分点的判断依据不同</strong>。<br>在分类树算法中，遍历到的每一个特征中的每一个值，都按照该值将数据集分为取该值$D_1$和不取该值$D_2$,然后根据$D_1$和$D_2$计算<strong>在特征A的条件下，集合D的基尼指数</strong>：<br>$$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$<br>循环遍历每个特征的每个切分点以后，就可以找到最优的特征和最优的切分点(使得上式最小)，递归的进行上述过程直到<strong>满足停止条件</strong>(没有特征，子数据集特征的取值只有一个，没有特征和切分点满足GIni阈值),最终生成的CART分类树：<br>$$f(x)=\sum_{m=1}^MV_mI(x∈R_m)$$<br>其中$V_m$是投票函数。</p><h1 id="CART剪枝算法"><a href="#CART剪枝算法" class="headerlink" title="CART剪枝算法"></a>CART剪枝算法</h1><p>之前在说CART数生成的时候，谈到要生成的树尽量完全，这样剪枝的时候就有比较大空间。CART剪枝主要分为两步：</p><ol><li>从数的底端开始不断的向上剪枝，知道树的根节点，<strong>这期间生成了n个子树</strong>，{$T_0,T_1,T_2…$}</li><li>通过<strong>交叉验证在独立的验证集</strong>上验证每颗子树的性能，选择最优子树</li></ol><p>那自下而上剪枝的时候，有这么多的节点，怎么确定先剪哪一个呢，或者说，<strong>怎么剪才是最优的呢(使得损失函数更小)</strong>。因此，确定减掉一个结点t以后，整体的损失函数变为了多少，或者减少了多少是衡量是否应该减掉某个结点的标准。<br>当前的树模型是在原来的数据集$D_{train}$上构建而成的，它在原来的数据集上的损失函数已经足够小了，但是<strong>现在数据集更换为了$D_{test}$</strong>，这个时候仍能计算出当前树模型的损失函数，然而它已经不一定是小的损失函数了(<strong>预测能力不确定，如果过拟合，则预测能力很差</strong>)，所以需要用剪枝的手段来<strong>减小在测试集上的损失函数(或者说提高预测能力)</strong>。</p><p><strong>CART剪枝算法步骤：</strong></p><p> 1.设$k=0,T=T_k,(k表示第几颗子树)$<br> 2.$α=+∞$<br> 3.自下而上的对每个内部结点$t$计算<br> $$C(T_t):子树的损失函数，|T_t|:子树的叶节点个数$$<br> $$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1},g(t)表示损失函数较少的程度,对于单结点数,C_α(t)=C(t)+α,$$<br> $$α=min(α,g(t))$$<br> 4.对$g(t)=α$的结点进行剪枝(即在计算过程中得到的$g(t)&lt;原α$),并对结点t以多数表决决定其类别，<br> 更新:$k=k+1,α_k=α,T_k=T$<br> 5.重复以上步骤直到成为一个只有两个叶节点的树，在形成的子树序列{${T_0,T_1,T_2…,T_n}$}用验证集选取最优子树</p><blockquote><p><strong>对公式$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$的解释：</strong><br>首先需要明确的一点是剪枝的策略，在减掉某个结点的时候，我们希望它尽量不对模型的损失函数造成坏的影响，也就是它单节点的损失函数最好是小于等于以它为根节点的子树的损失函数，这样我们就可以轻松的把它的子树剪掉，既减小了模型复杂度，又没影响损失函数是最好的，其中，单结点数的损失函数为：<br>$$C_α(t)=C(t)+α,because |T_t|为1$$<br>以它为根节点的子树的损失函数为:<br>$$C_α(T_t)=C(T_t)+α|T_t|$$<br>我们希望是：<br>$$C_α(t)≤C_α(T_t)$$<br>即:<br>$$C(t)+α≤C(T_t)+α|T_t|$$<br>两边稍微变换一下：<br>$$\frac{C(t)-C(T_t)}{|T_t|-1}≤α$$<br>这是我自己的理解的，和书上稍微有一点点出入，这样，在某种一般情况下，我们可以得到一个等号，这个时候该结点的单节点树损失函数和其子树损失函数相等，那么肯定是直接剪成单节点树，那如果左边更小的话就更好了，所以就要对于每一个当前树$T_k$的结点计算一下<br> $$\frac{C(t)-C(T_t)}{|T_t|-1}$$<br> 然后保存其值，如果它的值比α还小，那么就更新全局变量的$min_α$值，然后最后找到$g(t)=min_α$的那个结点(你也可以辅助理解为保存键值对，最后找到值最小的那个键，虽然这和它的操作有点偏差)，把它剪成一个子结点，这样就完成了一轮剪枝，得到一颗子树$T_{k+1}$,然后将此时的α作为下颗子树的起始值。</p></blockquote><p>如果有后续延伸或更深入的问题再补充，还有下面的问题没有完全理解：<br><strong>1.如何理解决策树剪枝过程中损失函数最小化等价于正则化的极大似然估计</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;特征选择,生成,剪枝,ID3,C4.5,CART算法&lt;/center&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>对生成模型与判别模型的理解</title>
    <link href="http://yoursite.com/2018/03/11/%E7%94%9F%E6%88%90%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/11/生成判别模型/</id>
    <published>2018-03-11T15:18:21.000Z</published>
    <updated>2018-03-11T17:29:30.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[该博客为本网站作者: “yangyiqing”原创，转载请注明出处]</p></blockquote><h1 id="书中介绍"><a href="#书中介绍" class="headerlink" title="书中介绍"></a>书中介绍</h1><p>在《统计学习方法》中，对生成模型和判别模型的介绍篇幅比较少：</p><blockquote><p><strong>1.生成方法</strong><br>监督学习方法可以分为生成方法和判别方法，生成的模型分别对应为<strong>生成模型</strong>和<strong>判别模型</strong><br><strong>生成方法</strong>由<strong>数据联合概率分布$P(X,Y)$,</strong>然后求出<strong>条件概率分布$P(Y|X)$</strong>作为预测的模型，即生成模型：<br>$$P(Y|X)=\frac{P(X,Y)}{P(X)}$$<br><strong>称之为生成方法的原因是：模型表示了给定输入X产生输Y的生成关系</strong>。典型的生成方法有：</p><ul><li>朴素贝叶斯</li><li>隐马尔科夫模型</li></ul><hr><p> <strong>2.判别方法</strong><br> 判别方法由数据直接学习决策函数$f(x)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。<strong>判别模型关心的是对于给定的输入X，应该预测什么样的Y</strong>。典型的判别模型有：</p><ul><li>k近邻(knn)</li><li>感知机</li><li>决策树</li><li>逻辑斯蒂回归</li><li>最大熵模型</li><li>支持向量机</li><li>提升方法</li><li>条件随机场</li></ul><hr><p> <strong>生成方法和判别方法的区别：</strong><br> 1.生成方法可以还原出<strong>联合概率分布</strong>，而判别方法不可以<br> 2.通常情况下，<strong>生成方法</strong>的学习<strong>收敛速度快</strong>，而<strong>判别方法的准确率更高</strong><br> 3.当存在隐变量的时候，仍然可以用生成方法，但是不能用判别方法<br> 4.由于直接学习$P(Y|X)$或$f(X)$，可以对数据进行各种程度上的抽象，定义特征并使用特征，因此可以简化学习问题。</p></blockquote><h1 id="个人补充"><a href="#个人补充" class="headerlink" title="个人补充"></a>个人补充</h1><h2 id="决策函数和条件概率函数"><a href="#决策函数和条件概率函数" class="headerlink" title="决策函数和条件概率函数"></a>决策函数和条件概率函数</h2><p>先说说<strong>决策函数$f(x)$和条件概率分布$P(Y|X)$:</strong><br>举个例子来说，有一个分类问题，要求判断给定特征下判断是篮球，足球，还是乒乓球。<br>1.在<strong>决策函数</strong>中：<br>对于每一个特征有一个阈值(分类边界)，对于输入的特征每个去判断属于边界的哪一边，最后<strong>直接得到一个对应的输出$Y$就是对应的分类结果</strong>。<br>2.在<strong>条件概率分布</strong>中：<br>会去计算在对应特征条件下是每个类的概率，也就是依次计算：$$P(篮球|X),P(足球|X),P(乒乓球|X)$$<br>然后<strong>从中选择输出概率最大的那个最为对应的分类结果。</strong><br>再说的详细一点儿，每个条件概率分布式是怎么求出来的呢：<br>$$P(Y|X)=\frac{P(X,Y)}{P(X)}=\frac{P(X|Y)P(Y)}{P(X)}$$<br>从以上的例子应该可以看出决策函数和条件概率分布的不同，一个是给定X直接产生一个对应输出Y，而另一个是首先计算其可能为每个Y的概率，然后再输出一个概率最大的Y。</p><p><strong>那决策函数$f(x)$和条件概率分布$P(Y|X)$有什么联系呢？</strong></p><blockquote><p>实际上<strong>通过条件概率分布P(Y|X)进行预测也是隐含着表达成决策函数Y=f(X)的形式</strong>的。例如也是两类w1和w2，那么我们求得了P(w1|X)和P(w2|X)，那么实际上判别函数就可以表示为Y= P(w1|X)/P(w2|X)，如果Y大于1或者某个阈值，那么X就属于类w1，如果小于阈值就属于类w2。<u><strong>而同样，很神奇的一件事是，实际上决策函数Y=f(X)也是隐含着使用P(Y|X)的</strong></u>。因为一般决策函数Y=f(X)是通过学习算法使你的预测和训练数据之间的误差平方最小化，而贝叶斯告诉我们，虽然它没有显式的运用贝叶斯或者以某种形式计算概率，但它实际上也是在隐含的输出极大似然假设（MAP假设）。也就是说学习器的任务是在所有假设模型有相等的先验概率条件下，输出极大似然假设。</p></blockquote><h2 id="简化学习问题"><a href="#简化学习问题" class="headerlink" title="简化学习问题"></a>简化学习问题</h2><p><strong>如何理解判别模型可以简化学习问题？</strong></p><blockquote><p>分类器的设计就是在给定训练数据的基础上估计其概率模型P(Y|X)。如果可以估计出来，那么就可以分类了。<u><strong>但是一般来说，概率模型是比较难估计的。给一堆数给你，特别是数不多的时候，你一般很难找到这些数满足什么规律吧。</strong></u>那能否不依赖概率模型直接设计分类器呢？事实上，分类器就是一个决策函数（或决策面），<u><strong>如果能够从要解决的问题和训练样本出发直接求出判别函数，就不用估计概率模型了</strong></u>，这就是决策函数Y=f(X)的伟大使命了。<u><strong>例如支持向量机，我已经知道它的决策函数（分类面）是线性的了，也就是可以表示成Y=f(X)=WX+b的形式，那么我们通过训练样本来学习得到W和b的值就可以得到Y=f(X)了</strong></u>。还有一种<strong>更直接的分类方法</strong>，它不用事先设计分类器，而是只确定分类原则，根据已知样本（训练样本）直接对未知样本进行分类。包括<u><strong>近邻法，它不会在进行具体的预测之前求出概率模型P(Y|X)或者决策函数Y=f(X)</strong></u>，而是在真正预测的时候，将X与训练数据的各类的Xi比较，和哪些比较相似，就判断它X也属于Xi对应的类。</p></blockquote><p>所以判别模型的可以简化学习问题的优势就在于，我不一定硬要去找数据中的规律或计算条件概率，我只要找到一种判别规则就可以了，而且由于<strong>不需要计算类别的条件概率，可以对数据进行降维等抽象操作</strong>。</p><h2 id="其它联系"><a href="#其它联系" class="headerlink" title="其它联系"></a>其它联系</h2><p><strong>生成模型和判别模型还有什么联系？</strong><br>由生成模型可以得到判别模型，但由判别模型得不到生成模型。生成模型可以反应数据本身的特性，而判别模型不可以。<br>来源于同一个原因：</p><blockquote><p><u><strong>生成模型可以求出数据的联合概率分布，而判别模型不可以。</strong></u></p></blockquote><h2 id="区别和优缺点"><a href="#区别和优缺点" class="headerlink" title="区别和优缺点"></a>区别和优缺点</h2><p><strong>再通俗的解释一下两者的区别？</strong></p><p>生成算法尝试去找到底这个数据是怎么生成的（产生的），然后再对一个信号进行分类。<u>基于你的生成假设，那么那个类别最有可能产生这个信号，这个信号就属于那个类别</u>。判别模型不关心数据是怎么生成的，<u>它只关心信号之间的差别</u>，然后用差别来简单对给定的一个信号进行分类。</p><p><strong>生成模型的优点和缺点？</strong><br><strong>优点：</strong><br>1.可以还原联合概率分布$P(X,Y)$，得到数据集更多的特性。<br>2.生成模型收敛速度比较快，即当样本数量较多时，生成模型能更快地收敛于真实模型。<br>3.生成模型能够应付存在隐变量的情况<br>4.研究单类问题比判别模型灵活性强<br><strong>缺点：</strong><br>1.准确率一般没有判别模型高</p><p><strong>判别模型的优点和缺点？</strong><br><strong>优点：</strong><br>1.需要的样本数量少，计算量小<br>2.直接面对预测，准确率高<br>3.直接学习$P(Y|X)$，不需要求解条件概率，所以允许我们对输入进行抽象（比如降维、构造等），从而能够简化学习问题。<br><strong>缺点：</strong><br>1.无法反映数据集的特性，无法求解联合概率分布</p><h2 id="过拟合？"><a href="#过拟合？" class="headerlink" title="过拟合？"></a>过拟合？</h2><p><strong>过拟合问题</strong><br>直接摘自<a href="http://helloyuan.com/2018/03/09/%E8%AF%B4%E8%AF%B4%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">大鼻子的博客</a></p><h3 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a><strong>生成模型</strong></h3><p>‘‘没有考虑正则化很简单，因为他们很少过拟合’’。生成模型学习$X,Y$的联合概率分布$P(X,Y)$，直接学习的就是数据的分布，从整个数据的整体着手，很少会出现过拟合。<br>基本上属于高偏差/低方差分类器，当样本数量小于特征数量或样本数量不足时，应选用这种模型</p><h3 id="判别模型"><a href="#判别模型" class="headerlink" title="判别模型"></a><strong>判别模型</strong></h3><p>判别模型应当有正则化过程，因为是直接生成$f(x)$或者$p(y|x)$，所以很容易比较$y$跟$f(x)$的关系，按照现有数据照葫芦画瓢来判别，容易过拟合，所以正则化便有存在的意义。<br>基本上属于低偏差/高方差分类器，容易过拟合，需要正则项。数据量充足时选用判别模型</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>随着训练集的增大，低偏差/高方差分类器（判别模型）相对于高偏差/低方差分类器（生成模型）准确率高，因为随着数据量的增大，现有训练集数据的分布更接近于真实分布，此时生成模型优势变小，同时生成模型不能提高足够的准确率，此时，判别模型优势更大。</p><h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子：</strong></h3><p>当一份分类数据的特征维度大于样本数量时。如果采用判别模型，极端情况下每条样本都有唯一的特征（或特征组合），此时如果正则化不够给力，那么该判别模型将极大限度拟合当前数据，训练集AUC可能将近1，那么就可能得到训练数据上准确率100%，测试数据准确率不如XJB猜的模型。</p><hr><p><strong>一张图总结生成模型与判别模型</strong><br><img src="/2018/03/11/生成判别模型/2.png" width="600" height="500" alt="图片名称" align="center"></p><hr><p><strong>仍有以下问题没有完全搞懂：</strong></p><ol><li>关于隐变量的问题<br>贴一张知乎的图作为初步理解。<br><img src="/2018/03/11/生成判别模型/1.png" width="639" height="985" alt="图片名称" align="center"><br>2.”而贝叶斯告诉我们，虽然它没有显式的运用贝叶斯或者以某种形式计算概率，但它实际上也是在隐含的输出极大似然假设（MAP假设）”</li></ol><hr><p>参考链接:<br>1.<a href="http://blog.csdn.net/zouxy09/article/details/8195017" target="_blank" rel="noopener">CSDN</a><br>2.<a href="https://www.zhihu.com/search?type=content&amp;q=%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">知乎1</a><br>3.<a href="https://zhuanlan.zhihu.com/p/30941701" target="_blank" rel="noopener">知乎2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;生成模型与判别模型的区别和各自的应用场景&lt;/center&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2017 CCF 大数据竞赛top4%</title>
    <link href="http://yoursite.com/2018/02/08/2017CCF/"/>
    <id>http://yoursite.com/2018/02/08/2017CCF/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-03-11T13:40:30.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2017-CCF-大数据竞赛思路及源码分享"><a href="#2017-CCF-大数据竞赛思路及源码分享" class="headerlink" title="2017 CCF 大数据竞赛思路及源码分享"></a>2017 CCF 大数据竞赛思路及源码分享</h1><p><strong><a href="https://github.com/NeoAlex18up" target="_blank" rel="noopener">源码见我的Github</a> </strong>比赛：蚂蚁金服：精准室内定位**，线下赛最终经过作弊筛选后是前100，共有2845支队伍，因为当时和小伙伴都不太会MapReduce，加上还有两个周期末考试了然而我为了比赛完全没有复习，所以复赛就弃了。</p><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给出用户在商场使用手机支付时所采集到的信息，包括用户信息，店铺信息，商场信息等，要求预测给出上述信息后精准预测用户所在店铺。具体给出的数据表可以点击<a href="https://tianchi.aliyun.com/competition/information.htm?spm=5176.100067.5678.2.647adc0v8Xce5&amp;raceId=231620" target="_blank" rel="noopener">这里</a>来看。</p><h2 id="2-大致分析与思路"><a href="#2-大致分析与思路" class="headerlink" title="2.大致分析与思路"></a>2.大致分析与思路</h2><p>虽然给出了比较多的信息，包括很多的用户信息和商店类别之类的看似有用的信息，但是做过这个比赛的都知道，其实是一个Wifi定位的问题，当然其他的信息经过正确的特征提取也会给模型带来增益，但是绝大程度上的精确度都是由wifi信息来提供的。所以，如何有效的提取wifi信息，去除其中的噪音，构造与wifi信息相关的特征，就是比赛的关键。</p><h2 id="3-具体做法"><a href="#3-具体做法" class="headerlink" title="3.具体做法"></a>3.具体做法</h2><h3 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1.数据预处理"></a>1.数据预处理</h3><ul><li>删除公共wifi，因为本题中给出了mall信息，当两个mall距离较远的情况下，同一个wifiId在这两个mall或多个mall都出现过的话，那么就可以判定这个wifiId是公共wifi或者是个人热点。</li><li>训练集和测试集wifi取交集，因为对于wifi指纹或我们后来构造的wifi特征来说，只在train中出现过或只在test中出现过的wifi都是无用的，甚至可能是噪音。</li><li>离群值的去除，没发现有什么离群点，部分wifi强度值有缺失，这里没有进行处理，因为模型对缺失值自动处理的效果比较好<h3 id="2-经纬度信息"><a href="#2-经纬度信息" class="headerlink" title="2.经纬度信息"></a>2.经纬度信息</h3>给了两种经纬度信息，一种是店铺经纬度（固定值），一种是买家付款时的经纬度，两种经纬度理论上差距应该很小，实际部分差距很大<br><img src="/2018/02/08/2017CCF/data.png" alt="pic1"></li><li>通过对精度的调整做了一个小的离散化处理</li><li>欧氏距离特征</li><li>曼哈顿距离特征</li><li>经纬度聚类（效果一般）<h3 id="3-时间特征的处理"><a href="#3-时间特征的处理" class="headerlink" title="3.时间特征的处理"></a>3.时间特征的处理</h3></li><li>提取饭点特征</li><li>提取早晨和深夜指示特征，因为这两种店可能比较固定<h3 id="4-用户特征"><a href="#4-用户特征" class="headerlink" title="4.用户特征"></a>4.用户特征</h3></li><li>用户购买力</li><li>用户常去商店<br>这里的用户特征是个坑，奥斯卡之夜也有人演过这一出，用户特征的提取会使得本地验证的分数提高不少，但是实际上可能是个噪音，因为测试集里的用户更换了绝大多数，记得好像只有不到1/5之一的旧用户吧，但是在训练集里用户特征会占很高的重要性，所以在将来会出现一些预测上的偏差，它们是要负责任的。<h3 id="5-Wifi特征"><a href="#5-Wifi特征" class="headerlink" title="5.Wifi特征"></a>5.Wifi特征</h3>wifi特征是最主要的部分，这里我们主要构建了如下的wifi特征<br><strong>(1)当前用户连接到的最强wifi</strong><br>转换成规则的话其实是一个极大似然估计，举个例子来说，当我能搜索到的最强wifi是wifi0的时候，在历史上最强wifi是wifi0的时候有80个人在A店铺，5个人在B店铺，10个人在C店铺，那么我最大可能当前在A店铺。这个特征算是一个比较强的特征了。<br><strong>(2)wifi出现的次数</strong><br>搜索到的wifi数，wifi历史计数<br><strong>(3)店铺wifi指纹</strong><br>根据每个店铺历史上出现过的wifi和强度建立wifi强度指纹库，取每个wifi出现过的所有值得中位数作为最终指纹值，比对当前强度wifi和指纹库<br><strong>(4)商场wifi原点</strong><br>根据整个商场历史上出现过的wifi和强度（统计频率，只取出现频率前50的wiif）建立一个原点wiif，计算每条数据wiif的wifi序列到wifi原点的欧氏距离<br><strong>(5)高频wifi强度特征</strong><br>也是先统计所有wifi出现过的次数，选其中出现频率高的wifi，每一个wifi及其强度作为一个特征，效果较好。<br><strong>后处理</strong>除了特征以外，还用了一些简单的规则来对预测数据进行后处理，相对于模型预测来说，后处理可处理的数据很少，但是相对于模型来说更加准确。</li><li>wiif强度序列完全相同</li><li>当前连接的wifi在历史上所在店铺的极大似然<br>其实在作比赛的时候远远试了比这些更多的特征，但是因为效果不好都去掉了，最后提交模型一共使用了以上特征。<h2 id="4-数据集划分"><a href="#4-数据集划分" class="headerlink" title="4.数据集划分"></a>4.数据集划分</h2>因为这是个时间相关的预测问题，所以应该和大多数人一样，最终我选取了最后一个周进行训练，特征提取是在整个训练集上进行的<h2 id="5-模型"><a href="#5-模型" class="headerlink" title="5.模型"></a>5.模型</h2>最开始我们使用了xgb的多分类模型，分mall进行预测，效果一般，然后转而使用二分类实现多分类，依然分mall进行预测，提升显著。<br>具体做法是使用N个二分类器，分别对每个mall的每个店铺进行二分类得到一个二分类器，然后对数据进行预测，这样对于每一个二分类器都可以得到一个预测概率值，选取其中预测最大的概率值对应的店铺作为最终分类结果。</li></ul><table><thead><tr><th>样本</th><th style="text-align:right">分类器1</th><th style="text-align:center">分类器2</th></tr></thead><tbody><tr><td>1</td><td style="text-align:right">0.12</td><td style="text-align:center">0.131</td></tr><tr><td>2</td><td style="text-align:right">0.13</td><td style="text-align:center">0.03</td></tr><tr><td>3</td><td style="text-align:right">0.94</td><td style="text-align:center">0.001</td></tr></tbody></table><p>大概就是表格里这种（值是我瞎写的）<br>这样做的好处还有一个是模型融合的时候会很快捷和高效，直接将模型概率加权相加即可<br><strong>模型融合:</strong>最后我们取了 0.65<em>xgb + 0.35</em>lgb 加权融合</p><p>就写这么多，比赛过去两个月了好多东西都忘了，以后想到再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;比赛记录和思路&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="比赛" scheme="http://yoursite.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>DTree</title>
    <link href="http://yoursite.com/2018/02/01/DTree/"/>
    <id>http://yoursite.com/2018/02/01/DTree/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-03-11T13:46:37.931Z</updated>
    
    <content type="html"><![CDATA[<p>习题为课程作业:<br><img src="/2018/02/01/DTree/13.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">D = pd.DataFrame()</span><br><span class="line">D[<span class="string">'A'</span>] = [<span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'H'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, ]</span><br><span class="line">D[<span class="string">'B'</span>] = [<span class="string">'X'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Y'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>, <span class="string">'Z'</span>, <span class="string">'Z'</span>, <span class="string">'X'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>, <span class="string">'Z'</span>, <span class="string">'Z'</span>]</span><br><span class="line">D[<span class="string">'C'</span>] = [<span class="string">'T'</span>, <span class="string">'F'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>, <span class="string">'F'</span>, <span class="string">'T'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>, <span class="string">'F'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>, <span class="string">'F'</span>]</span><br><span class="line">D[<span class="string">'class'</span>] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEntropy</span><span class="params">(Dataset, fea, cate)</span>:</span></span><br><span class="line">    print(<span class="string">'$$ ----------------------------$$'</span>)</span><br><span class="line">    print(<span class="string">'Father Node:'</span>, fea, <span class="string">'，| category of FatherNode：'</span>, cate,<span class="string">'|'</span>)</span><br><span class="line">    nowFeature = &#123;&#125;</span><br><span class="line">    label_list = Dataset[<span class="string">'class'</span>].tolist()</span><br><span class="line">    label = set(label_list)</span><br><span class="line">    entropy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> label:</span><br><span class="line">        label_count = label_list.count(v)</span><br><span class="line">        label_len = len(label_list)</span><br><span class="line">        entropy += -(label_count / label_len) * np.log2((label_count / label_len))</span><br><span class="line">    print(<span class="string">'H(D):'</span>, entropy)</span><br><span class="line">    <span class="keyword">if</span> entropy == <span class="number">0.0</span>:</span><br><span class="line">        print(<span class="string">'End,the label is'</span>, np.unique(Dataset[<span class="string">'class'</span>])[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 计算每个特征的信息增益</span></span><br><span class="line">    feature_list = Dataset.columns.tolist()</span><br><span class="line">    feature_list.remove(<span class="string">'class'</span>)</span><br><span class="line">    <span class="keyword">if</span> feature_list:</span><br><span class="line">        <span class="keyword">for</span> feature <span class="keyword">in</span> feature_list:</span><br><span class="line">            <span class="comment"># 条件熵</span></span><br><span class="line">            conEntropy = <span class="number">0</span></span><br><span class="line">            tempList = Dataset[feature].tolist()</span><br><span class="line">            feature_cat = set(tempList)</span><br><span class="line">            <span class="comment"># 保存计算条件熵的字符串</span></span><br><span class="line">            mathCon = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> cat <span class="keyword">in</span> feature_cat:</span><br><span class="line">                conEntropy += (tempList.count(cat) / len(tempList)) * Entropy(Dataset[Dataset[feature] == cat])[<span class="number">0</span>]</span><br><span class="line">                mathCon += <span class="string">'-'</span> + <span class="string">'\\frac&#123;'</span>+str(tempList.count(cat))+<span class="string">'&#125;&#123;'</span>+str(len(tempList))+<span class="string">'&#125;'</span> +<span class="string">'*'</span>+Entropy(Dataset[Dataset[feature] == cat])[<span class="number">1</span>]</span><br><span class="line">            conEntropy = conEntropy</span><br><span class="line">            increaseInfor = entropy - conEntropy</span><br><span class="line">            mathCon = <span class="string">'$$'</span>+str(increaseInfor) + mathCon+<span class="string">'='</span>+ str(increaseInfor)+<span class="string">'$$'</span></span><br><span class="line">            print(<span class="string">'Feature'</span>, feature, <span class="string">'Information gain：'</span>)</span><br><span class="line">            print(mathCon)</span><br><span class="line">            <span class="keyword">if</span> float(increaseInfor) &gt;= <span class="number">0.3</span>:</span><br><span class="line">                nowFeature[feature] = increaseInfor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nowFeature:</span><br><span class="line">            print(<span class="string">'There is no feature g(D,A)&gt;0.3'</span>)</span><br><span class="line">            <span class="keyword">if</span> Dataset[<span class="string">'class'</span>].tolist().count(<span class="number">0</span>) &gt;= Dataset[<span class="string">'class'</span>].tolist().count(<span class="number">1</span>):</span><br><span class="line">                print(<span class="string">'Label：0'</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'Label:1'</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        sorted(nowFeature.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</span><br><span class="line">        biggest_feature = <span class="string">''</span></span><br><span class="line">        biggest_gain = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> f, v <span class="keyword">in</span> nowFeature.items():</span><br><span class="line">            <span class="keyword">if</span> v &gt; biggest_gain:</span><br><span class="line">                biggest_feature = f</span><br><span class="line">                biggest_gain = v</span><br><span class="line">        print(<span class="string">'Feature has biggest information Gain:'</span>, biggest_feature)</span><br><span class="line">        feature_list.remove(biggest_feature)</span><br><span class="line">        <span class="keyword">if</span> feature_list:</span><br><span class="line">            feature_list.append(<span class="string">'class'</span>)</span><br><span class="line">            biggest_cat = set(Dataset[biggest_feature].tolist())</span><br><span class="line">            <span class="keyword">for</span> cat <span class="keyword">in</span> biggest_cat:</span><br><span class="line">                getEntropy(Dataset[feature_list][Dataset[biggest_feature] == cat], biggest_feature, cat)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Entropy</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    label_list = Dataset[<span class="string">'class'</span>].tolist()</span><br><span class="line">    label = set(label_list)</span><br><span class="line">    entropy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> label:</span><br><span class="line">        label_count = label_list.count(v)</span><br><span class="line">        label_len = len(label_list)</span><br><span class="line">        entropy += -(label_count / label_len) * np.log2((label_count / label_len))</span><br><span class="line">        mathJax = <span class="string">'-\\frac&#123;'</span>+str(label_count)+<span class="string">'&#125;&#123;'</span>+str(label_len)+<span class="string">'&#125;'</span> +<span class="string">'*log2\\frac&#123;'</span>+str(label_count)+<span class="string">'&#125;&#123;'</span>+str(label_len)+<span class="string">'&#125;'</span></span><br><span class="line">    <span class="keyword">return</span> [entropy,mathJax]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getEntropy(D, <span class="string">'no'</span>, <span class="string">'no'</span>)</span><br></pre></td></tr></table></figure><p>运行代码以后可以得到如下结果:<br><code>`</code> python<br>$$ —————————-$$<br>Father Node: no ，| category of FatherNode： no |<br>H(D): 0.940285958671<br>Feature A Information gain：<br>$$0.00133974240444-\frac{6}{14}<em>-\frac{2}{6}</em>log2\frac{2}{6}-\frac{8}{14}<em>-\frac{3}{8}</em>log2\frac{3}{8}=0.00133974240444$$<br>Feature B Information gain：<br>$$0.314936851373-\frac{4}{14}<em>-\frac{1}{4}</em>log2\frac{1}{4}-\frac{6}{14}<em>-\frac{4}{6}</em>log2\frac{4}{6}-\frac{4}{14}<em>-\frac{4}{4}</em>log2\frac{4}{4}=0.314936851373$$<br>Feature C Information gain：<br>$$0.0902763493928-\frac{8}{14}<em>-\frac{4}{8}</em>log2\frac{4}{8}-\frac{6}{14}<em>-\frac{1}{6}</em>log2\frac{1}{6}=0.0902763493928$$<br>Feature has biggest information Gain: B<br>$$ —————————-$$<br>Father Node: B ，| category of FatherNode： Y |<br>H(D): 0.811278124459<br>Feature A Information gain：<br>$$0.122556248918-\frac{1}{4}<em>-\frac{1}{1}</em>log2\frac{1}{1}-\frac{3}{4}<em>-\frac{1}{3}</em>log2\frac{1}{3}=0.122556248918$$<br>Feature C Information gain：<br>$$0.122556248918-\frac{3}{4}<em>-\frac{1}{3}</em>log2\frac{1}{3}-\frac{1}{4}<em>-\frac{1}{1}</em>log2\frac{1}{1}=0.122556248918$$<br>There is no feature g(D,A)&gt;0.3<br>Label：0<br>$$ —————————-$$<br>Father Node: B ，| category of FatherNode： Z |<br>H(D): 0.918295834054<br>Feature A Information gain：<br>$$0.0-\frac{3}{6}<em>-\frac{2}{3}</em>log2\frac{2}{3}-\frac{3}{6}<em>-\frac{2}{3}</em>log2\frac{2}{3}=0.0$$<br>Feature C Information gain：<br>$$0.459147917027-\frac{3}{6}<em>-\frac{3}{3}</em>log2\frac{3}{3}-\frac{3}{6}<em>-\frac{1}{3}</em>log2\frac{1}{3}=0.459147917027$$<br>Feature has biggest information Gain: C<br>$$ —————————-$$<br>Father Node: C ，| category of FatherNode： F |<br>H(D): 0.0<br>End,the label is 1<br>$$ —————————-$$<br>Father Node: C ，| category of FatherNode： T |<br>H(D): 0.918295834054<br>Feature A Information gain：<br>$$0.251629167388-\frac{1}{3}<em>-\frac{1}{1}</em>log2\frac{1}{1}-\frac{2}{3}<em>-\frac{1}{2}</em>log2\frac{1}{2}=0.251629167388$$<br>There is no feature g(D,A)&gt;0.3<br>Label：0<br>$$ —————————-$$<br>Father Node: B ，| category of FatherNode： X |<br>H(D): 0.0<br>End,the label is 0</p><p>使用markdown编辑器或者mathjax编辑器可以看到效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;自动生成“树生成过程”的运算&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/2018/01/07/%E5%89%91%E6%8C%87offer-1/"/>
    <id>http://yoursite.com/2018/01/07/剑指offer-1/</id>
    <published>2018-01-07T13:57:10.000Z</published>
    <updated>2018-03-11T13:40:56.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二位数组中的查找"><a href="#二位数组中的查找" class="headerlink" title="二位数组中的查找"></a>二位数组中的查找</h1><p><strong>题目描述</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>My solution</strong>:用递归来解，从右下向左上对角线遍历，每次把大矩阵分为左下右上两个小矩阵进行递归，终止条件是target位于对角线或矩阵只剩一行或一列遍历target（矩阵可能行列数不相同）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self,target, array)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">FindTarget</span><span class="params">(target, array)</span>:</span></span><br><span class="line">            <span class="comment"># 如果只有一行</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> target <span class="keyword">in</span> array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(array) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果只有一列</span></span><br><span class="line">                <span class="keyword">if</span> len(array[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> len(array[<span class="number">1</span>]) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> target <span class="keyword">in</span> [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="comment"># 其它情况</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    height = len(array)</span><br><span class="line">                    width = len(array[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">while</span> (height &gt; <span class="number">0</span> <span class="keyword">and</span> width &gt; <span class="number">0</span>):</span><br><span class="line">                        v = array[height - <span class="number">1</span>][width - <span class="number">1</span>]</span><br><span class="line">                        height -= <span class="number">1</span></span><br><span class="line">                        width -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> v == target:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">if</span> v &gt; target <span class="keyword">and</span> height!=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            remain1 = [x[width + <span class="number">1</span>:len(array[<span class="number">0</span>])] <span class="keyword">for</span> x <span class="keyword">in</span> array[:height+<span class="number">1</span>]]</span><br><span class="line">                            remain2 = [x[:width + <span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array[height + <span class="number">1</span>:len(array)]]</span><br><span class="line">                            <span class="keyword">return</span> (FindTarget(target, remain1)) <span class="keyword">or</span> (FindTarget(target, remain2))</span><br><span class="line">        result = <span class="keyword">False</span></span><br><span class="line">        result = FindTarget(target, array)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>简单做法：</strong><br>从左下开始遍历，比target大就往上，比target小就往下（妈的，看完很气，还特么辛苦写了个递归，这个简单做法太简单就不写了，╭(╯^╰)╮）</p><hr><h1 id="从尾到头打印列表"><a href="#从尾到头打印列表" class="headerlink" title="从尾到头打印列表"></a>从尾到头打印列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l = []</span><br><span class="line">        head = listNode</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l.insert(<span class="number">0</span>, head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p>很简单，注意是<strong>while head</strong> 不是 <strong>while head.next</strong></p><hr><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><strong>题目描述：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><strong>思路</strong><br>就是一个数组，把从后面切片放到前面来，让找最小数字，最简单的做法是直接min()函数，但是耗时<br>我的做法是使用递归，如果数组中间的数比开头的小，那么说明最小的数在这个切片里，不然就在后半切片里<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array)&lt;<span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> min(array)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&gt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[int(len(array)/<span class="number">2</span>):])</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&lt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[:int(len(array)/<span class="number">2</span>)+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> findMin(rotateArray)</span><br></pre></td></tr></table></figure></p><p>再优化一点就是从左到右找，找到下一个比当前的小了说明下一个就是最小值</p><hr><h1 id="输出斐波那契数列第n个数"><a href="#输出斐波那契数列第n个数" class="headerlink" title="输出斐波那契数列第n个数"></a>输出斐波那契数列第n个数</h1><p><strong>递归做法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getN</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getN(n - <span class="number">1</span>) + getN(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> getN(n)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**数组做法**</span><br><span class="line">``` python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> a[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">                a.append(a[<span class="number">-1</span>]+a[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p><strong>三个变量做法</strong>最快</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">        int one = <span class="number">0</span>;</span><br><span class="line">        int two = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> one;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> two;</span><br><span class="line">        int result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            result = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="斐波那契数列扩展"><a href="#斐波那契数列扩展" class="headerlink" title="斐波那契数列扩展"></a>斐波那契数列扩展</h1><p><strong>问题</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路</strong><br>一个青蛙跳到第k个台阶，对于k-1个台阶来说只有一种跳法，就是跳1级，对k-2级台阶来说就是跳两级，也只有一种跳法，所以跳到第k个台阶的做法就是跳到第k-1个台阶的做法+跳到第k-2个台阶的做法<br>也就是 <strong>斐波那契数列！</strong><br>精彩</p><hr><h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><p><strong>问题：</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路：</strong><br>跟上题类似，但是青蛙上次的位置不限于k-1和k-2了，可以在任何位置，用递归来实现，核心思想是：<br>**递归的加上一次所有可能的位置（1到k-1）加上从0直接到当前位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAlljumps</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sum([findAlljumps(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n)],<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> findAlljumps(number)</span><br></pre></td></tr></table></figure><hr><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><p><strong>题目：</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？<br><strong>思路：</strong>用从后往前的递归方法想一下，先填满，然后依次往外拿，行已经知道是2了，列为n列，那么就是求f(n),递归往前一步想，有两类往外拿的方法，一个是拿一个横的，一个是拿一个竖着的，如果拿出一个竖着的，那么其实就是f(n-1)然后填一个竖着的到f(n),如果拿一个横着的（其实相当于拿出两个横着的，因为不管拿上面还是下面的横着的，它对应的上面或下面的那个横着的没有其它拿法，所以相当于f(n-2),所以这道题其实又是一个斐波那契数列的问题了）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last = <span class="number">1</span></span><br><span class="line">        current = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> number<span class="number">-2</span>&gt;<span class="number">0</span>:</span><br><span class="line">            temp = current</span><br><span class="line">            current = last + current</span><br><span class="line">            last = temp</span><br><span class="line">            number-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure></p><hr><h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p><strong>题目：</strong><br>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><strong>思路：</strong>用递归上下左右的满足条件去走，每走一步count+1，具体的条件：<br>1.下一步不超边界<br>2.下一步满足横纵坐标各个位数之和不大于k<br>3.下一步不重复（可以把走过的位置用字典存起来）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(threshold, rows, cols)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> rows==cols==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    count = []</span><br><span class="line">    hasGone = &#123;&#125;</span><br><span class="line">    hasGone[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSmaller</span><span class="params">(n, x, y)</span>:</span></span><br><span class="line">        xSum = <span class="number">0</span></span><br><span class="line">        ySum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str(x))):</span><br><span class="line">            xSum += int(str(x)[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(str(y))):</span><br><span class="line">            ySum += int(str(y)[j])</span><br><span class="line">        <span class="keyword">if</span> xSum+ySum &gt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'调用'</span>)</span><br><span class="line">        count.append(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(i,j)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="comment"># 往上走</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i<span class="number">-1</span>,j):</span><br><span class="line">                <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i<span class="number">-1</span>] = [j]</span><br><span class="line">                    move(i - <span class="number">1</span>, j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i<span class="number">-1</span>]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i<span class="number">-1</span>] += [j]</span><br><span class="line">                        move(i - <span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 往下走</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;rows<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i+<span class="number">1</span>,j):</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i+<span class="number">1</span>] = [j]</span><br><span class="line">                    move(i + <span class="number">1</span>, j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i+<span class="number">1</span>]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i+<span class="number">1</span>] += [j]</span><br><span class="line">                        move(i + <span class="number">1</span>, j)</span><br><span class="line">        <span class="comment"># 往左</span></span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i,j<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i] = [j<span class="number">-1</span>]</span><br><span class="line">                    move(i, j<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i] += [j<span class="number">-1</span>]</span><br><span class="line">                        move(i, j<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">if</span> j&lt;cols<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> isSmaller(threshold,i,j+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hasGone:</span><br><span class="line">                    fuck()</span><br><span class="line">                    hasGone[i] = [j+<span class="number">1</span>]</span><br><span class="line">                    move(i, j+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone[i]:</span><br><span class="line">                        fuck()</span><br><span class="line">                        hasGone[i] += [j+<span class="number">1</span>]</span><br><span class="line">                        move(i, j+<span class="number">1</span>)</span><br><span class="line">    move(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> sum(count)+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p><strong>题目：</strong><br>设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><strong>思路：</strong><br>想把输出按照行列换成对应的矩阵，然后找到所有的开头点，对于每个开头点：<br>先把指针cur指向path的下一个字符</p><ul><li>递归，上下左右查看</li><li>如果满足边界内并且非重复并且是cur当前所指的字符</li><li>指针+1，横纵坐标对应操作一并当做参数进行下一轮递归，坐标加入已经走过的坐标字典<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> path <span class="keyword">in</span> matrix:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">finalfind</span><span class="params">()</span>:</span></span><br><span class="line">            result.append(<span class="number">1</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findStr</span><span class="params">(i,j,cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur == len(path):</span><br><span class="line">                finalfind()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> cur &lt; len(path):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 往上</span></span><br><span class="line">                    <span class="keyword">if</span> M[i<span class="number">-1</span>][j] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i<span class="number">-1</span>]:</span><br><span class="line">                                GoneDict[i<span class="number">-1</span>]+=[j]</span><br><span class="line">                                <span class="comment">#print('shang',i-1,j)</span></span><br><span class="line">                                findStr(i<span class="number">-1</span>,j,cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i<span class="number">-1</span>] = [j]</span><br><span class="line">                            <span class="comment">#print('shang', i - 1, j)</span></span><br><span class="line">                            findStr(i - <span class="number">1</span>, j, cur+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> i&lt;rows<span class="number">-1</span>:</span><br><span class="line">                    <span class="comment"># 往下</span></span><br><span class="line">                    <span class="keyword">if</span> M[i + <span class="number">1</span>][j] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i + <span class="number">1</span> <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i + <span class="number">1</span>]:</span><br><span class="line">                                GoneDict[i + <span class="number">1</span>] += [j]</span><br><span class="line">                                <span class="comment">#print('xia', i + 1, j)</span></span><br><span class="line">                                findStr(i + <span class="number">1</span>, j, cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i + <span class="number">1</span>] = [j]</span><br><span class="line">                            findStr(i + <span class="number">1</span>, j, cur+<span class="number">1</span>)</span><br><span class="line">                            </span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 左</span></span><br><span class="line">                    <span class="keyword">if</span> M[i][j<span class="number">-1</span>] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i]:</span><br><span class="line">                                GoneDict[i] += [j<span class="number">-1</span>]</span><br><span class="line">                                <span class="comment">#print('zuo', i, j-1)</span></span><br><span class="line">                                findStr(i, j<span class="number">-1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i] = [j<span class="number">-1</span>]</span><br><span class="line">                            <span class="comment">#print('zuo', i, j - 1)</span></span><br><span class="line">                            findStr(i, j<span class="number">-1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                            </span><br><span class="line">                <span class="keyword">if</span> j&lt;cols<span class="number">-1</span>:</span><br><span class="line">                    <span class="comment"># 右</span></span><br><span class="line">                    <span class="keyword">if</span> M[i][j+<span class="number">1</span>] == path[cur]:</span><br><span class="line">                        <span class="keyword">if</span> i <span class="keyword">in</span> GoneDict:</span><br><span class="line">                            <span class="keyword">if</span> j+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> GoneDict[i]:</span><br><span class="line">                                GoneDict[i] += [j+<span class="number">1</span>]</span><br><span class="line">                                <span class="comment">#print('you', i, j + 1)</span></span><br><span class="line">                                findStr(i, j+<span class="number">1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            GoneDict[i] = [j+<span class="number">1</span>]</span><br><span class="line">                            <span class="comment">#print('you', i, j + 1)</span></span><br><span class="line">                            findStr(i, j+<span class="number">1</span>, cur+<span class="number">1</span>)</span><br><span class="line">                            </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        GoneDict = &#123;&#125;</span><br><span class="line">        M = []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = cols</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            M.append([x <span class="keyword">for</span> x <span class="keyword">in</span> matrix[start:end]])</span><br><span class="line">            start = end</span><br><span class="line">            end += cols</span><br><span class="line">        <span class="comment"># 记录当前查询的位置</span></span><br><span class="line">        startPoint = []</span><br><span class="line">        <span class="comment"># 找到所有开头的节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> M[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                    startPoint.append([i,j])</span><br><span class="line">        <span class="keyword">if</span> startPoint:</span><br><span class="line">            <span class="keyword">for</span> point <span class="keyword">in</span> startPoint:</span><br><span class="line">                <span class="comment"># 对于每一个头重置字典</span></span><br><span class="line">                GoneDict = &#123;&#125;</span><br><span class="line">                <span class="comment"># 先把开头的节点放入字典</span></span><br><span class="line">                GoneDict[point[<span class="number">0</span>]] = [point[<span class="number">1</span>]]</span><br><span class="line">                findStr(point[<span class="number">0</span>],point[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> result ==<span class="keyword">True</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><p><strong>题目：</strong><br>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> size==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> size &gt; len(num):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num) -size+ <span class="number">1</span>):</span><br><span class="line">        result.append(max(num[i:i + size]))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="二叉搜索树的第K个节点"><a href="#二叉搜索树的第K个节点" class="headerlink" title="二叉搜索树的第K个节点"></a>二叉搜索树的第K个节点</h1><p>二叉搜索数的中序遍历是有序的，因此只要把第k个节点返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 特殊情况1</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">middle</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root==<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            middle(root.left)</span><br><span class="line">            result.append(root)</span><br><span class="line">            middle(root.right)</span><br><span class="line">        middle(pRoot)</span><br><span class="line">        <span class="comment"># 特殊情况2</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;len(result):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> result[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><hr><h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p>输入一个整数，可能为负数，求其二进制中1的个数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum([<span class="number">1</span> &amp; n&gt;&gt;i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>)])</span><br></pre></td></tr></table></figure></p><p>其二进制长度为32位，依次右移i位，也就是每次比较最后一位 &amp; 1 ，判断最后一位是否为0.</p><hr><h1 id="调整数组使得奇数位于偶数前"><a href="#调整数组使得奇数位于偶数前" class="headerlink" title="调整数组使得奇数位于偶数前"></a>调整数组使得奇数位于偶数前</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x%<span class="number">2</span>!=<span class="number">0</span>] + [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><hr><h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><p><strong>做法一</strong>，遍历一遍，把每个节点保存下来，最后返回第-k个<br><strong>做法二</strong>，用两个指针，第一个先走k步，然后一起走，第一个到尾节点的时候后面的那个指针应该正好倒数第k个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        if not head:</span><br><span class="line">            return </span><br><span class="line">        pre = head</span><br><span class="line">        l = [head]</span><br><span class="line">        while pre.next!=None:</span><br><span class="line">            pre = pre.next</span><br><span class="line">            l.append(pre)</span><br><span class="line">        if len(l) &lt; k or k &lt;= 0:</span><br><span class="line">            return</span><br><span class="line">        return l[-k]</span><br></pre></td></tr></table></figure></p><hr><h1 id="输入一个链表，反转链表后，输出链表的所有元素。"><a href="#输入一个链表，反转链表后，输出链表的所有元素。" class="headerlink" title="输入一个链表，反转链表后，输出链表的所有元素。"></a>输入一个链表，反转链表后，输出链表的所有元素。</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">revLinked</span><span class="params">(pre,after)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> after == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            <span class="keyword">if</span> pre == pHead:</span><br><span class="line">                pre.next = <span class="keyword">None</span></span><br><span class="line">            temp = after.next</span><br><span class="line">            after.next = pre</span><br><span class="line">            <span class="keyword">if</span> after.next == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> after</span><br><span class="line">            <span class="keyword">return</span> revLinked(after,temp)</span><br><span class="line">        <span class="keyword">return</span> revLinked(pHead,pHead.next)</span><br></pre></td></tr></table></figure><h2 id="递归，每次输入两个节点，让后面的节点指向前面的节点-别忘了处理头结点"><a href="#递归，每次输入两个节点，让后面的节点指向前面的节点-别忘了处理头结点" class="headerlink" title="递归，每次输入两个节点，让后面的节点指向前面的节点,别忘了处理头结点"></a>递归，每次输入两个节点，让后面的节点指向前面的节点,别忘了处理头结点</h2><h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><p><strong>题目：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        pre = head</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> p1!=<span class="keyword">None</span> <span class="keyword">and</span> p2!=<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                    pre.next = ListNode(p1.val)</span><br><span class="line">                    p1 = p1.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = ListNode(p2.val)</span><br><span class="line">                    p2 = p2.next</span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="keyword">elif</span> p1==<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">while</span> p2:</span><br><span class="line">                    pre.next = ListNode(p2.val)</span><br><span class="line">                    p2 = p2.next</span><br><span class="line">                    pre = pre.next</span><br><span class="line">            <span class="keyword">elif</span> p2==<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">while</span> p1:</span><br><span class="line">                    pre.next = ListNode(p1.val)</span><br><span class="line">                    p1 = p1.next</span><br><span class="line">                    pre = pre.next</span><br><span class="line">            <span class="keyword">if</span> p1==<span class="keyword">None</span> <span class="keyword">and</span> p2==<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></p><p>每次从两个链表当前指针所在位置选一个最小的，如果一条链表为空，添加剩余链表</p><hr><h1 id="魔法币"><a href="#魔法币" class="headerlink" title="魔法币"></a>魔法币</h1><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一行,包括一个正整数n(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">9</span>),表示小易需要的魔法币数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符<span class="string">'1'</span>和<span class="string">'2'</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = int(input()) </span><br><span class="line">arr=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStr</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 奇数</span></span><br><span class="line">            arr.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 偶数</span></span><br><span class="line">            arr.append(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-2</span>)/<span class="number">2</span>))</span><br><span class="line">getStr(n)</span><br><span class="line">arr.reverse()</span><br><span class="line">finalStr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalStr += str(x)</span><br><span class="line">print(finalStr)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong> 递归，如果最终结果是偶数，那么上一步一定用了机器2，奇数机器1同理</p><hr><h1 id="”相反数“”"><a href="#”相反数“”" class="headerlink" title="”相反数“”"></a>”相反数“”</h1><p>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一个整数n,(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个整数,表示n的相反数</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">1325</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">6556</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> str(n)]</span><br><span class="line">arr.reverse()</span><br><span class="line">finalNumber = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalNumber+=x</span><br><span class="line">finalNumber = int(finalNumber)</span><br><span class="line"><span class="keyword">print</span> (finalNumber + n)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单</p><hr><h1 id="字符串碎片"><a href="#字符串碎片" class="headerlink" title="字符串碎片"></a>字符串碎片</h1><p>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个字符串s,字符串s的长度length(<span class="number">1</span> ≤ length ≤ <span class="number">50</span>),s只含小写字母(<span class="string">'a'</span>-<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。</span><br><span class="line"></span><br><span class="line">如样例所示: s = <span class="string">"aaabbaaac"</span></span><br><span class="line">所有碎片的平均长度 = (<span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span>) / <span class="number">4</span> = <span class="number">2.25</span></span><br><span class="line"></span><br><span class="line">输入例子<span class="number">1</span>:</span><br><span class="line">aaabbaaac</span><br><span class="line"></span><br><span class="line">输出例子<span class="number">1</span>:</span><br><span class="line"><span class="number">2.25</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = str(input())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findS</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    sum=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i]!=s[i+<span class="number">1</span>]:</span><br><span class="line">            sum+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(s)/sum</span><br><span class="line">print(<span class="string">'%.2f'</span>%findS(s))</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单的题目，就注意格式化的时候，我一开始用round，报错3.50要求不能3.5，于是用了%.2f</p><hr><h1 id="重排数列"><a href="#重排数列" class="headerlink" title="重排数列"></a>重排数列</h1><p>小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。<br>牛博士给小易出了一个难题:<br>对数列A进行重新排列,使数列A满足所有的A[i] * A<a href="1 ≤ i ≤ N - 1">i + 1</a>都是4的倍数。<br>小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line"><span class="comment">#输入的第一行为数列的个数t(1 ≤ t ≤ 10),</span></span><br><span class="line"><span class="comment">#接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)</span></span><br><span class="line"><span class="comment">#第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line"><span class="comment">#对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。</span></span><br><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="comment">#输入</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = int(input())</span><br><span class="line">resultArr = []</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = [int(y) <span class="keyword">for</span> y <span class="keyword">in</span> str(input()).split(<span class="string">' '</span>)]</span><br><span class="line">    dic[n] = arr</span><br><span class="line">    arr = [int(x%<span class="number">4</span>) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br><span class="line">    ji = arr.count(<span class="number">1</span>)+arr.count(<span class="number">3</span>)<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 有能被2整除的</span></span><br><span class="line">    <span class="keyword">if</span> arr.count(<span class="number">2</span>)&gt;<span class="number">0</span>:</span><br><span class="line">        arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x != <span class="number">2</span>]</span><br><span class="line">        arr.append(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#如果存在能被2整除的，这些数必须紧邻在一起当做一个奇数</span></span><br><span class="line">    <span class="keyword">if</span> float(arr.count(<span class="number">0</span>))&gt;=(len(arr)<span class="number">-1</span>)/<span class="number">2</span>:</span><br><span class="line">        resultArr.append(<span class="string">'Yes'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resultArr.append(<span class="string">'No'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> resultArr:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong> 如果有能被2整除的，那为了满足条件，它们必须紧挨着，那就相当于一个奇数，所以可以删除它们加进来一个奇数，那么数组就只剩下奇数和能被4整除的数了，那么满足被4整除的数插在奇数中间即可，即 n* &gt;= (len(array)-1)/2 或者 大于等于奇数-1，都一样.</p><hr><h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><strong>思路</strong>队列是先进先出，栈是先进后出，每次要pop的时候，把stack1中的值按顺序压入到stack2，再按顺序出，这样先进的就可以先出了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2 == []:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                <span class="comment"># 注意这里的pop是list的pop，弹出list的队尾元素，原list改变</span></span><br><span class="line">                a = self.stack1.pop()</span><br><span class="line">                self.stack2.append(a)</span><br><span class="line">        <span class="keyword">if</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure></p><hr><h1 id="判断树的子结构"><a href="#判断树的子结构" class="headerlink" title="判断树的子结构"></a>判断树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 注意这里第一个是subTree来判断根节点，然后下面后面两个or接的是依次遍历的A的左右子树</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subTree(pRoot1,pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left,pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right,pRoot2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_subTree</span><span class="params">(self,p1,p2)</span>:</span></span><br><span class="line">        <span class="comment"># 在这个路线上p1和p2的值一直相等知道p2到头了，返回true</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 如果路线出现p1到头了或者p1,p2值不相等，那么构不成子树，返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">or</span> p1.val != p2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 如果p1,p2都没到头并且值相等，继续判断(p1左，p2左),(p1右，p2右)</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subTree(p1.left,p2.left) <span class="keyword">and</span> self.is_subTree(p1.right,p2.right)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>代码是从讨论区看到的，理解后自己又写了一遍，思路很简单，但是实现用的递归很巧妙，从根节点开始一次遍历判断A的左右子树是否可以作为B的头结点而形成一颗和B一样的子树。</p><hr><h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">            <span class="number">8</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">6</span>   <span class="number">10</span></span><br><span class="line">         / \  / \</span><br><span class="line">        <span class="number">5</span>  <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br><span class="line">        镜像二叉树</span><br><span class="line">            <span class="number">8</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">10</span>   <span class="number">6</span></span><br><span class="line">         / \  / \</span><br><span class="line">        <span class="number">11</span> <span class="number">9</span> <span class="number">7</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left,root.right = root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>直接递归，从上到下每个节点的左右互换即可</p><hr><h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    length = len(matrix[<span class="number">0</span>])</span><br><span class="line">    width = len(matrix)</span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>]</span><br><span class="line">    result = [matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">    hasGone = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(width):</span><br><span class="line">        hasGone[i] = []</span><br><span class="line">    hasGone[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">    x0, y0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> len(result) &gt;= width*length:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> y0 &lt; length - <span class="number">1</span> <span class="keyword">and</span> y0+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone[x0]:</span><br><span class="line">            hasGone[x0] += [y0 + <span class="number">1</span>]</span><br><span class="line">            result.append(matrix[x0][y0 + <span class="number">1</span>])</span><br><span class="line">            y0 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x0 &lt; width - <span class="number">1</span> <span class="keyword">and</span> y0 <span class="keyword">not</span> <span class="keyword">in</span> hasGone[x0+<span class="number">1</span>]:</span><br><span class="line">            hasGone[x0 + <span class="number">1</span>] += [y0]</span><br><span class="line">            result.append(matrix[x0 + <span class="number">1</span>][y0])</span><br><span class="line">            x0 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> y0 &gt; <span class="number">0</span> <span class="keyword">and</span> y0<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> hasGone[x0]:</span><br><span class="line">            hasGone[x0] += [y0 - <span class="number">1</span>]</span><br><span class="line">            result.append(matrix[x0][y0 - <span class="number">1</span>])</span><br><span class="line">            y0 -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 编写的时候这里出过错，不是matrix[x0-1][y0] not in ,而是y0,注意点</span></span><br><span class="line">        <span class="keyword">while</span> x0 &gt; <span class="number">0</span> <span class="keyword">and</span> y0 <span class="keyword">not</span> <span class="keyword">in</span> hasGone[x0<span class="number">-1</span>]:</span><br><span class="line">            hasGone[x0 - <span class="number">1</span>] += [y0]</span><br><span class="line">            result.append(matrix[x0 - <span class="number">1</span>][y0])</span><br><span class="line">            x0 -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>还是老方法，按右下左上的顺序前进直到result长度达到预期，注意判别条件。</p><hr><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 偷懒写法</span></span><br><span class="line">        <span class="keyword">return</span> min(self.stack)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>注意在python中stack的写法，在<strong>init</strong>中用一个list来表示栈，队尾就是栈顶，pop就是从栈顶往外弹，整好对应着list的pop默认参数</p><hr><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(pushV, popV)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pushV <span class="keyword">or</span> <span class="keyword">not</span> popV <span class="keyword">or</span> len(pushV) != len(popV):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pushV)):</span><br><span class="line">        stack.append(pushV[i])</span><br><span class="line">        <span class="keyword">while</span> len(stack) <span class="keyword">and</span> stack[<span class="number">-1</span>] == popV[<span class="number">0</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">            popV.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> len(stack):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">print(IsPopOrder([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>已知栈的压入顺序和弹出顺序，如果是正确的，那么按照顺序来一遍的话栈应该完全弹空，所以就按照压入顺序和弹出顺序模拟一遍，如果栈无法弹空，那么弹出顺序就是有错的，discuss里有个Alias写的不错：</p><p>Alias头像Alias<br>【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><p>举例：</p><p>入栈1,2,3,4,5</p><p>出栈4,5,3,2,1</p><p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p><p>此时栈顶2≠4，继续入栈3</p><p>此时栈顶3≠4，继续入栈4</p><p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p><p>此时栈顶3≠5，继续入栈5</p><p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p><p>….</p><p>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><hr><h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = [root.val]</span><br><span class="line">        NodeLs = [root]</span><br><span class="line">        <span class="keyword">while</span> NodeLs:</span><br><span class="line">            current = NodeLs.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> current.left:</span><br><span class="line">                result.append(current.left.val)</span><br><span class="line">                NodeLs.append(current.left)</span><br><span class="line">            <span class="keyword">if</span> current.right:</span><br><span class="line">                result.append(current.right.val)</span><br><span class="line">                NodeLs.append(current.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>用一个队列来存储节点，从根节点开始，依次弹出，然后弹出节点的左右子节点依次入队</p><hr><h1 id="判断二叉搜索树的后序遍历序列"><a href="#判断二叉搜索树的后序遍历序列" class="headerlink" title="判断二叉搜索树的后序遍历序列"></a>判断二叉搜索树的后序遍历序列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.Verify(sequence)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Verify</span><span class="params">(self,sequence)</span>:</span></span><br><span class="line">        <span class="comment"># 终止的正确条件是左右子树队列为1(子节点)或者为0(无左右子树)</span></span><br><span class="line">        <span class="keyword">if</span> len(sequence)==<span class="number">0</span> <span class="keyword">or</span> len(sequence)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 从左边开始的指针0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 队尾是根节点的值</span></span><br><span class="line">        root_val = sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 左半部分的值应该都小于跟节点的值</span></span><br><span class="line">        <span class="keyword">while</span> sequence[left] &lt; root_val:</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果剩下的部分(右子树部分)有小于跟节点值的节点，说明有错，返回False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left,len(sequence)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> sequence[i] &lt; root_val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 从根节点开始左右子序列必须全部满足条件才行</span></span><br><span class="line">        <span class="keyword">return</span> self.Verify(sequence[:left]) <span class="keyword">and</span> self.Verify(sequence[left:len(sequence)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>Discuss里有一个总结的不错：BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : )，具体的注释看代码里</p><hr><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">goPath</span><span class="params">(root,exNumber,subList)</span>:</span></span><br><span class="line">            <span class="comment"># 这里一定要重新开辟一个内存建一个新的暂时列表，不然递归的过程中一直用同一个subList</span></span><br><span class="line">            tempLst = subList[:]+[root.val]</span><br><span class="line">            <span class="keyword">if</span> root.val == exNumber:</span><br><span class="line">                <span class="comment"># 根据题意，要判断是否是叶节点，不加这个判别条件的话可以有更多的路径满足</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    result.append(tempLst)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                goPath(root.left,exNumber-root.val,tempLst)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                goPath(root.right,exNumber-root.val,tempLst)</span><br><span class="line">        goPath(root,expectNumber,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>思路没什么新颖的地方，依然是常规的递归，遍历每一条路径，把子节点，target-子节点的值，subList作为参数进行递归，如果有正确的路径就加入到result，但是有两点需要注意下：</p><ul><li>tempLst = subList[:]+[root.val]，每个递归体内的subList复制给一个新空间的list，否则sublist只有一个，结果会造成相当于一个前序遍历输出了</li><li>注意题目条件是路径必须从根到叶子，所以最后需要判别下改路径的尾是不是到叶了</li></ul><hr><h1 id="复杂链表的复制☆"><a href="#复杂链表的复制☆" class="headerlink" title="复杂链表的复制☆"></a>复杂链表的复制☆</h1><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br>先上代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 追加相同链表</span></span><br><span class="line">        pHeadTemp = pHead</span><br><span class="line">        <span class="keyword">while</span> pHeadTemp:</span><br><span class="line">            newNode = RandomListNode(pHeadTemp.label)</span><br><span class="line">            newNode.random = pHeadTemp.random</span><br><span class="line">            temp = pHeadTemp.next</span><br><span class="line">            pHeadTemp.next = newNode</span><br><span class="line">            newNode.next = temp</span><br><span class="line">            pHeadTemp = pHeadTemp.next.next</span><br><span class="line">        <span class="comment"># 处理复制后的链表的random</span></span><br><span class="line">        pHeadTemp = pHead</span><br><span class="line">        <span class="keyword">while</span> pHeadTemp.next:</span><br><span class="line">            <span class="keyword">if</span> pHeadTemp.random:</span><br><span class="line">                pHeadTemp.next.random = pHeadTemp.next.random.next</span><br><span class="line">            <span class="keyword">if</span> pHeadTemp.next.next:</span><br><span class="line">                pHeadTemp = pHeadTemp.next.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pHeadTemp.next.next:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 拆分</span></span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        preNew = newHead</span><br><span class="line">        preOld = pHead</span><br><span class="line">        <span class="keyword">while</span> preOld:</span><br><span class="line">            <span class="keyword">if</span> preNew.next:</span><br><span class="line">                preOld.next = preNew.next</span><br><span class="line">                preNew.next = preNew.next.next</span><br><span class="line">                preOld = preOld.next</span><br><span class="line">                preNew = preNew.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不要忘记断掉最后的那个连接处</span></span><br><span class="line">                preOld.next = <span class="keyword">None</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>思路其实还是很简单的，借鉴下面这种说法：<br>        1、复制每个节点，如：复制节点A得到A1，将A1插入节点A后面<br>        2、遍历链表，A1-&gt;random = A-&gt;random-&gt;next;<br>        3、将链表拆分成原链表和复制后的链表<br>第一步：复制每个节点，意思是复制value和random，但是next不一样，插入在每个原节点后面<br>第二步：处理random，恰好复制的每个节点的random的正确指向的位置是他们复制过来指向位置的next，所以只需要A1-&gt;random = A-&gt;random-&gt;next就可以处理好random<br>第三步：拆分列表，这一步也是我出错比较多的地方，主要两个点<strong>1：不能改变原本的链表，我一开始疏忽了这一点，只管复制后的链表对了 2：拆分的最后位置要注意是否还有连接处</strong><br><img src="https://uploadfiles.nowcoder.net/images/20160724/961875_1469289666488_886555C4C4726220976FEF4D3A32FFCD" alt="1"></p><hr><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self,ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        ss = [s <span class="keyword">for</span> s <span class="keyword">in</span> ss]</span><br><span class="line">        length = len(ss)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printAll</span><span class="params">(subStr, string)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(subStr) == length:</span><br><span class="line">                <span class="keyword">if</span> subStr <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                    result.append(subStr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            newString = string[:]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(string)):</span><br><span class="line">                printAll(subStr+newString[i],newString[<span class="number">0</span>:i]+newString[i+<span class="number">1</span>:len(newString)])</span><br><span class="line"></span><br><span class="line">        printAll(<span class="string">''</span>, ss)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>之前做过类似的，非常简单的一个递归，但是在操作过程中还是犯错了：<br>1.没注意传入的参数会改变的问题，应该通过[:]新建变量<br>2.没注意字符重复使用问题，比如aa-&gt;[‘aa’,’aa’]是错误的<br>3.递归的时候变量修改直接放参数中，不要在外部赋值，不然for循环过程中就无法控制变量了<br>4.list.remove()返回的不是list!</p><hr><h1 id="数组中出现超过一半的数字"><a href="#数组中出现超过一半的数字" class="headerlink" title="数组中出现超过一半的数字"></a>数组中出现超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        countDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> countDict:</span><br><span class="line">                countDict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                countDict[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> countDict[num] &gt; int(len(numbers)/<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单的循环计数，用字典</p><hr><h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(tinput)[:k] <span class="keyword">if</span> k &lt;= len(tinput) <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>python大法吼！</p><hr><h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><p>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        curSum = <span class="number">0</span></span><br><span class="line">        maxSum = <span class="number">-999</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> curSum &gt;= <span class="number">0</span>:</span><br><span class="line">                curSum += num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curSum = num</span><br><span class="line">            <span class="keyword">if</span> curSum &gt; maxSum:</span><br><span class="line">                maxSum = curSum</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>动态规划，重点是curSum,它是num之前的子向量的和，如果是个非负数，那么加上num肯定比num本身大或者相等，如果是个负数，那么对于num来说前面的子序列已经没有价值了，令curSum=num,然后判断代替maxSum。</p><hr><h1 id="整数中1出现的次数-从1到n"><a href="#整数中1出现的次数-从1到n" class="headerlink" title="整数中1出现的次数(从1到n)"></a>整数中1出现的次数(从1到n)</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 从个位开始</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">            <span class="comment"># 计算weight</span></span><br><span class="line">            weight = int(n / (i * <span class="number">10</span>))</span><br><span class="line">            <span class="comment"># 当前数</span></span><br><span class="line">            current = (n / i) % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 剩下的数</span></span><br><span class="line">            rest = n % i</span><br><span class="line">            <span class="keyword">if</span> current == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果当前位为1，那么当前位可能为1的个数由高位和地位共同决定，等于(高位的数*当前i + 地位数 + 1)</span></span><br><span class="line">                count += weight * i + rest + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> current &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果当前位大于1，那么当前可能为1的个人仅由高位决定，等于(高位+1) * 当前位数i</span></span><br><span class="line">                count += (weight+<span class="number">1</span>) * i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前位位0，仅由高位决定，等于(高位*当前位数i)</span></span><br><span class="line">                count += weight * i</span><br><span class="line">            i *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong><br>编程之美上给出的规律：</p><ol><li>如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），<strong>等于更高位数字X当前位数的权重10i-1。</strong></li><li>如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），<strong>等于更高位数字X当前位数的权重10i-1+（低位数字+1）。</strong></li><li>如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），<strong>等于（更高位数字+1）X当前位数的权重10i-1。</strong><br>然后从个位到最高位，依次按照上面的规则计算每一位出现1的次数累加即可</li></ol><hr><h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 依次找最小的数，这个最小的数从每个数的开头第一个找，如果有相同的依次往下顺</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        numbers = [str(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(A,B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> A+B &lt;= B+A:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># cmp定义一个比较函数，接收两个函数，如果A&lt;B，返回负值</span></span><br><span class="line">        newNumber = sorted(numbers,cmp=compare)</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> newNumber:</span><br><span class="line">            result += x</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>按照字符串排序，但是排序的规则是如果字符串A+B &lt; B+A,那么字符串A比较小</p><hr><h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self,index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        A = [<span class="number">1</span>]</span><br><span class="line">        twoIndex = <span class="number">0</span></span><br><span class="line">        threeIndex = <span class="number">0</span></span><br><span class="line">        fiveIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>):</span><br><span class="line">            newNumber = min(A[twoIndex]*<span class="number">2</span>,A[threeIndex]*<span class="number">3</span>,A[fiveIndex]*<span class="number">5</span>)</span><br><span class="line">            A += [newNumber]</span><br><span class="line">            <span class="keyword">if</span> newNumber%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                twoIndex +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> newNumber%<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                threeIndex +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> newNumber%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                fiveIndex +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> A[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>先上个详细思路：<br>对于任何丑数p：<br>（一）那么2<em>p,3</em>p,5<em>p都是丑数，并且2</em>p&lt;3<em>p&lt;5</em>p<br>（二）如果p&lt;q, 那么2<em>p&lt;2</em>q,3<em>p&lt;3</em>q,5<em>p&lt;5</em>q<br>现在说说算法思想：<br>    由于1是最小的丑数，那么从1开始，把2<em>1，3</em>1，5<em>1，进行比较，得出最小的就是1<br>的下一个丑数，也就是2</em>1，<br>    这个时候，多了一个丑数‘2’，也就又多了3个可以比较的丑数，2<em>2，3</em>2，5<em>2，<br>这个时候就把之前‘1’生成的丑数和‘2’生成的丑数加进来也就是<br>(3</em>1,5<em>1,2</em>2，3<em>2，5</em>2)进行比较，找出最小的。。。。如此循环下去就会发现，<br>每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。<br>    上面的暴力方法也应该能解决，但是如果在面试官用这种方法，估计面试官只会摇头吧<br>。下面说一个O（n）的算法。<br>    在上面的特（fei）点（hua）中，既然有p&lt;q, 那么2<em>p&lt;2</em>q，那么<br>“我”在前面比你小的数都没被选上，你后面生成新的丑数一定比“我”大吧，那么你乘2<br>生成的丑数一定比我乘2的大吧，那么在我选上之后你才有机会选上。<br>其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的<br>数。也就是比较(2<em>x , 3</em>y, 5<em>z) ，x&gt;=y&gt;=z的，<br>重点说说下面代码中p的作用：int p[] = new int[] { 0, 0, 0 }; p[0]表示最小用于<br>乘2比较数在数组a中的【位置】<br><strong>讲的通俗一点就是：</strong>重点是所有的丑数都是由它前面的丑数</em>2,3,5得到的，最开始数组中只有[1]，那么下个数肯定是1<em>2,3,5得到的小的数2，那么我把新得到的丑数2也放入数组，这时候[1,2]都有资格去</em>2,3,5得到下一个丑数，那么下一个比较的是不是1<em>2,1</em>3,1<em>5,2</em>2,2<em>3,2</em>5呢？不是。<br>因为如果2<em>3能得到下一个最小的数，那么1</em>3就更有资格了，所以每次只需要记录每一个用来乘以2,3,5的最小的数就可以了。最开始只有1，然后<em>2得到了2，这个时候用来乘以2的最小的数就往后移一位，用来乘以3和5的最小的数依然是1,所以这时候比较的是[1</em>3,1<em>5,2</em>2],把3加入数组。<br>这时候用来乘以2的最小的数依然是2，用来乘以3的最小的数往后移一位变成了2，用来乘以5的最小的数依然是1，所以比较的三个数乘是[2<em>2,2</em>3,1*5],得到最小的丑数4加入数组…………</p><hr><h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置<br>python一行解法：就是挨个调用count统计次数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)) <span class="keyword">if</span> s.count(s[i])==<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>标准书本解法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        charDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        checkList = []</span><br><span class="line">        <span class="comment"># 第一遍遍历，计数并存入字典</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> charDict:</span><br><span class="line">                charDict[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                checkList += [c]</span><br><span class="line">                charDict[c] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 第二遍遍历，查询字典是否为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> charDict <span class="keyword">and</span> charDict[s[i]]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        pHead1Add = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            pHead1Add[id(pHead1)] = <span class="number">0</span></span><br><span class="line">            pHead1 = pHead1.next</span><br><span class="line">        <span class="keyword">while</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> id(pHead2) <span class="keyword">in</span> pHead1Add:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pHead2 = pHead2.next</span><br><span class="line">        <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>遍历一遍第一个链表，把地址存入字典，遍历第二个字典，如果有相同地址就返回,取地址 id(obj)</p><hr><h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><p>统计一个数字在排序数组中出现的次数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无赖写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> data.count(k)</span><br></pre></td></tr></table></figure></p><p>其实这个题肯定是二分查找了，下面分别给出循环和递归的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">循环写法</span><br><span class="line">``` python</span><br><span class="line">def GetNumberOfK(data, k):</span><br><span class="line">    # write code here</span><br><span class="line">    start = 0</span><br><span class="line">    end = len(data) - 1</span><br><span class="line">    # 二分查找固定格式记住，while必须是&lt;=，因为相等的时候可以判断最后的那个边界值</span><br><span class="line">    while start &lt;= end:</span><br><span class="line">        print start,end</span><br><span class="line">        mid = (start + end) / 2</span><br><span class="line">        if data[mid] == k:</span><br><span class="line">            start = mid</span><br><span class="line">            end = mid</span><br><span class="line">            # 注意边界值 注意条件判别条件</span><br><span class="line">            # 找到开头</span><br><span class="line">            while start &gt; 0 and data[start-1] == k:</span><br><span class="line">                start -= 1</span><br><span class="line">            # 找到结尾</span><br><span class="line">            while end &lt; len(data) - 1 and data[end+1] == k:</span><br><span class="line">                end += 1</span><br><span class="line">            print start,end</span><br><span class="line">            break</span><br><span class="line">        elif data[mid] &gt; k:</span><br><span class="line">            start = mid + 1</span><br><span class="line">        elif data[mid] &lt; k:</span><br><span class="line">            end = mid - 1</span><br><span class="line">    return end - start + 1</span><br></pre></td></tr></table></figure></p><hr><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 注意这里不用加self</span></span><br><span class="line">    totalDepth = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findDepth</span><span class="params">(root,depth)</span>:</span></span><br><span class="line">            temp = depth</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 注意这里的判别条件</span></span><br><span class="line">            <span class="keyword">if</span> (root.left <span class="keyword">or</span> root.right) <span class="keyword">and</span> temp &gt;= self.totalDepth:</span><br><span class="line">                self.totalDepth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                findDepth(root.left,temp+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                findDepth(root.right,temp+<span class="number">1</span>)</span><br><span class="line">        findDepth(pRoot,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.totalDepth</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>递归，递归过程中记录当前路径的参数，全局变量记录当前最深路径参数，替换。<br><strong>还有一种更加巧妙的方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> pRoot == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    nLeft = self.TreeDepth(pRoot.left)</span><br><span class="line">    nRight = self.TreeDepth(pRoot.right)</span><br><span class="line">    <span class="keyword">return</span> max(nLeft+<span class="number">1</span>,nRight+<span class="number">1</span>)<span class="comment">#(nLeft+1 if nLeft &gt; nRight else nRight +1)</span></span><br><span class="line"><span class="comment"># 这里返回值一定是数值，而且是从下到上递归的选最大的那个数</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>输入一颗二叉树，判断该二叉树是否是平衡二叉树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAVL</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> root.right.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDepth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nLeft = self.findDepth(root.left)</span><br><span class="line">        nRight = self.findDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(nLeft+<span class="number">1</span>,nRight+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.findDepth(pRoot.left) - self.findDepth(pRoot.right)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong><br>判断是否是平衡二叉树主要判断两个点</p><ul><li>是否平衡，即左右两个子树的深度不能相差超过1。</li><li>是否为二叉搜索树，这个可以通过递归判断每个节点或者判断中序遍历是否有序来判断。</li></ul><hr><h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行流氓解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> array.count(x)==<span class="number">1</span>] <span class="keyword">if</span> array <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure></p><p><strong>正规解法:</strong>两次遍历，存查字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> array</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = []</span><br><span class="line">    numDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> numDict:</span><br><span class="line">            numDict[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numDict[num] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num,count <span class="keyword">in</span> numDict.items():</span><br><span class="line">        <span class="keyword">if</span> numDict[num] == <span class="number">1</span>:</span><br><span class="line">            result += [num]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h1><p>输入一个数S，输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> tsum &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        small = <span class="number">1</span></span><br><span class="line">        big = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> small &lt; (tsum + <span class="number">1</span>)/<span class="number">2</span> <span class="keyword">and</span> big &lt; tsum:</span><br><span class="line">            nowList = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(small,big+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">if</span> sum(nowList) == tsum:</span><br><span class="line">                result.append(nowList)</span><br><span class="line">                big += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum(nowList) &lt; tsum:</span><br><span class="line">                big += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                small += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>small和big两个数，因为是正数，所以初始化为1和2，如果从small到big的序列和大于sum，那么就去掉前面的值，small+=1,如果小于sum，那么就在后面加上一个值，big+=1</li><li>循环条件是 small &lt; (tSum+1)/2 并且 big &lt; tSum否则结束，因为比如100,到50的时候，50,51和后面的数的和必定不满足条件了。</li></ul><hr><h1 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h1><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。对应每个测试案例，输出两个数，小的先输出。<br><strong>我自己的基于twoSum的做法，遍历一遍即可</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    array = set(array)</span><br><span class="line">    sumDict = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> sumDict:</span><br><span class="line">            result.append([num, sumDict[num]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sumDict[tsum-num] = num</span><br><span class="line">    dd = float(<span class="string">"inf"</span>)</span><br><span class="line">    final = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">0</span>]*item[<span class="number">1</span>] &lt; dd:</span><br><span class="line">            dd = item[<span class="number">0</span>]*item[<span class="number">1</span>]</span><br><span class="line">            final = item</span><br><span class="line">    <span class="keyword">return</span> min(final[<span class="number">0</span>],final[<span class="number">1</span>]),max(final[<span class="number">0</span>],final[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p><strong>主流做法：</strong><br>左右夹逼，这样做的好处就是，因为距离越远的两个数乘积越小，这样夹逼找到的第一组数肯定是最优解，这也应该是这个问题的最优做法，比我的做法要好<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(array)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        nowSum = array[left] + array[right]</span><br><span class="line">        <span class="keyword">if</span>  nowSum == tsum:</span><br><span class="line">            <span class="keyword">return</span> array[left],array[right]</span><br><span class="line">        <span class="keyword">elif</span> nowSum &lt; tsum:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nowSum &gt; tsum:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></p><p>但是看运行时间我的做法更快？</p><hr><h1 id="左旋转字符"><a href="#左旋转字符" class="headerlink" title="左旋转字符"></a>左旋转字符</h1><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[:n] <span class="keyword">if</span> n &lt;= s <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><p>这个东西对python来说可能不算一道题把….</p><hr><h1 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h1><p>例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s.split(<span class="string">" "</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p><p>python只需要一行代码就够了，” “.join指的是用空格作为分隔符，后面的list中的元素必须为字符串，思路就是先分割，再倒序，再用空格做分隔符连起来<br>ps:<br>print(reversed(“hello”)) 应该为 print(‘’.join(reversed(“hello”)))<br><strong>常规做法</strong><br>先翻转整个句子，然后，依次翻转每个单词。依据空格来确定单词的起始和终止位置</p><hr><h1 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h1><p>题目说的乱七八糟的，意思是就给5个数，从0-13，0可以变成任何数，问这五个数可不可以变成一个连续序列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        numbers = sorted(numbers)</span><br><span class="line">        zerocount = <span class="number">0</span></span><br><span class="line">        gapcount = <span class="number">0</span></span><br><span class="line">        usedNum = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i]==<span class="number">0</span>:</span><br><span class="line">                zerocount+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 先判断是否重复</span></span><br><span class="line">                <span class="keyword">if</span> numbers[i] <span class="keyword">in</span> usedNum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    usedNum.append(numbers[i])</span><br><span class="line">                <span class="comment"># 累加gapcount</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; len(numbers)<span class="number">-1</span>:</span><br><span class="line">                    gapcount+=numbers[i+<span class="number">1</span>]-numbers[i]<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 判断所有的大小王是否够来填补空缺</span></span><br><span class="line">        <span class="keyword">if</span> zerocount &gt;= gapcount:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>主要思路有两点：</p><ul><li>非0数字不能重复</li><li>先排序，然后看看非0数字之间的间隔有几个坑，这些坑必须用0来填，然后看看0的个数够不够填这些坑即可。</li></ul><hr><h1 id="圆圈中最后剩下的数"><a href="#圆圈中最后剩下的数" class="headerlink" title="圆圈中最后剩下的数"></a>圆圈中最后剩下的数</h1><p><strong>有名的约瑟夫环问题，有两种解法</strong><br>1.第一种就是利用循环列表来求解，删除一个数字需要m步，一共有n个数字，时间复杂度为O(mn)，同时需要一个链表来辅助，空间复杂度为O(n)，代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self,n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        head = linkedList(<span class="number">0</span>)</span><br><span class="line">        pre = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            newNode = linkedList(i)</span><br><span class="line">            pre.next = newNode</span><br><span class="line">            pre = pre.next</span><br><span class="line">        pre.next = head</span><br><span class="line">        <span class="comment"># 构造好循环链表</span></span><br><span class="line">        <span class="comment"># 一共有n个数，需要循环n-1次才能剩下一个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            temp = head</span><br><span class="line">            <span class="comment"># 每次删除第m个数字，也就是前进m-1步删掉当前节点，也就是前进m-2步删掉后面的节点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-2</span>):</span><br><span class="line">                temp = temp.next</span><br><span class="line">            temp.next = temp.next.next</span><br><span class="line">            <span class="comment"># 然后下次循环从被删掉的节点后面的那个节点开始</span></span><br><span class="line">            head = temp.next</span><br><span class="line">        <span class="keyword">return</span> head.val</span><br></pre></td></tr></table></figure></p><p>第二种解法，数学归纳法<br><img src="/2018/01/07/剑指offer-1/circle.png" alt=""><br><strong>循环实现方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self,n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">            f = (f+m)%i</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure></p><p><strong>递归实现方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self,n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> (self.LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n</span><br></pre></td></tr></table></figure></p><p>关于约瑟夫环的问题一定要牢牢记住递归公式：</p><h2 id="f-N-M-f-N-1-M-M-N"><a href="#f-N-M-f-N-1-M-M-N" class="headerlink" title="$$f(N,M)=(f(N-1,M)+M)\%N$$"></a>$$f(N,M)=(f(N-1,M)+M)\%N$$</h2><h1 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+….+n"></a>求1+2+3+….+n</h1><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.Sum_Solution(n<span class="number">-1</span>)+n <span class="keyword">if</span> n!=<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong> 一个简单的递归:(1+2+3….+n-1) + n</p><hr><h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入： “+2147483647” 输出 2147483647<br>输入：“1a33” 输出：0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        final = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一位允许有符号位</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">            flag = <span class="number">-1</span></span><br><span class="line">            start =<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] ==<span class="string">'+'</span>:</span><br><span class="line">            start = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从start开始就不准有其他符号了</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[start:]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c.isdigit():</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            result.append(int(c))</span><br><span class="line">        <span class="comment"># 没有数字返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = len(result)</span><br><span class="line">        <span class="comment"># 按所在位数乘以10的k次方</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            final += result[i] * ( <span class="number">10</span> ** (length - i <span class="number">-1</span>) )</span><br><span class="line">        <span class="keyword">return</span> final*flag</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>允许的正确格式为 一位符号位[可以无]+只剩下连续的数字字符，违反格式就错。</p><hr><h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><p>感觉没太大意义，用位运算，如何用python来写？</p><hr><h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        numbers = sorted(numbers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> i != numbers[i]:</span><br><span class="line">                <span class="keyword">if</span> numbers[numbers[i]] == numbers[i]:</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>因为所有的数都是0到n-1，所以可以先排好序，如果完全没重复的数字，那么下标和值一一对应，如果出现值和下标不一样了，看看这个值作为下标对应的值是否和当前值一样，如果是的话就返回这个重复的数字，而且肯定是第一个。<br>比如[0,1,2,3,4,4,5]<br>前面都是一一对应，到下标为为5的时候，值为4，看下标为4的值，果然等于4，所以重复，返回。</p><hr><h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        B = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        C,D = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(len(A))],[<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(len(A))]</span><br><span class="line">        <span class="comment"># 这里只遍历了一次就存满了两个数组，注意这里的操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                C[i] = <span class="number">1</span></span><br><span class="line">                D[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                C[i] = C[i<span class="number">-1</span>]*A[i<span class="number">-1</span>]</span><br><span class="line">                D[i] = D[i<span class="number">-1</span>]*A[-i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="comment"># C[i]从头乘,D[i]从尾乘，注意下标</span></span><br><span class="line">            B.append(C[i]*D[-(i+<span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>利用矩阵，图见剑指offer第313页。</p><hr><h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> pattern:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.matchPattern(s, pattern)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchPattern</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> s,pattern</span><br><span class="line">        <span class="comment"># pattern or s 为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pattern <span class="keyword">and</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> pattern:</span><br><span class="line">            <span class="keyword">if</span> len(pattern) &gt;=<span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> self.matchPattern(s,pattern[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pattern <span class="keyword">and</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># pattern &lt; 1</span></span><br><span class="line">        <span class="keyword">if</span> len(pattern) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">return</span> self.matchPattern(s[<span class="number">1</span>:],pattern[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">elif</span> pattern[<span class="number">0</span>] != s[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">elif</span> pattern[<span class="number">0</span>]==s[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.matchPattern(s[<span class="number">1</span>:],pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="comment"># (1) 模式第二个字符不为*</span></span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">            <span class="comment"># 如果第一个字符相等，继续匹配</span></span><br><span class="line">            <span class="keyword">if</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span> <span class="keyword">or</span> pattern[<span class="number">0</span>] == s[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.matchPattern(s[<span class="number">1</span>:],pattern[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">            <span class="comment"># (2) 模式第二个字符为*</span></span><br><span class="line">            <span class="comment"># 如果第一个字符不匹配，后移两个继续匹配</span></span><br><span class="line">            <span class="keyword">if</span> pattern[<span class="number">0</span>]!=<span class="string">'.'</span> <span class="keyword">and</span> pattern[<span class="number">0</span>]!=s[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.matchPattern(s,pattern[<span class="number">2</span>:])</span><br><span class="line">            <span class="comment"># 如果第一个字符匹配 (.也算？) 有三种匹配方式 or or</span></span><br><span class="line">            <span class="keyword">if</span> pattern[<span class="number">0</span>]==<span class="string">'.'</span> <span class="keyword">or</span> pattern[<span class="number">0</span>] == s[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.matchPattern(s,pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.matchPattern(s[<span class="number">1</span>:],pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.matchPattern(s[<span class="number">1</span>:],pattern)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>其实直接把原来的函数写成递归行了，这里没改。<br>这个题就是大量的if-else判断，分情况，我在做的时候分成了以下的几种情况，递归做法：<br>1.判断pattern或s或两者都为空的情况作为结束条件<br>2.判断pattern长度为1的情况(因为后面有个&gt;1的情况需要详细讨论)<br>3.判断pattern长度&gt;=2的情况<br>    3.1 pattern第二个字符不为”<em>“的情况<br>        3.1.1 如果第一个字符相等，s和pattern各自向后移一位，继续递归(注意”.”的情况)<br>        3.1.2 如果第一个字符不相等，直接返回False<br>    3.2 pattern第二个字符为’</em>‘的情况<br>        3.2.1 如果第一个字符不相等，s往后移一位，pattern移两位，相当于跳过这个X*<br>        3.2.2 如果第一个字符相等，可以有以下三种处理方法继续递归：<br>        (1) s 移一位， pattern不变<br>        (2) s 不移， pattern 移两位<br>        (3) s 移一位 ,pateern 移两位</p><hr><h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dotCount = <span class="number">0</span></span><br><span class="line">        digitCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">print</span> s[i]</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">'+'</span> <span class="keyword">or</span> s[i]==<span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">if</span> i!=<span class="number">0</span> <span class="keyword">and</span> (s[i<span class="number">-1</span>]!=<span class="string">'e'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>]!=<span class="string">'E'</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> s[i]==<span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">if</span> dotCount:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                dotCount+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> s[i]==<span class="string">'e'</span> <span class="keyword">or</span> s[i]==<span class="string">'E'</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i==len(s)<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> s[i<span class="number">-1</span>].isdigit():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> s[i]==<span class="string">'+'</span> <span class="keyword">or</span> s[i]==<span class="string">'-'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                digitCount+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i&lt;len(s)<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> s[i].isdigit():</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    digitCount+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                digitCount+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> digitCount <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>就是根据规则写if-else，感觉意义不是很大，规则如下：<br>循环从头遍历一遍：</p><ul><li>‘+’or ‘-:只能在开头第一个或者前面必须有E(e)</li><li>‘.’只能有一个</li><li>‘E’只能有一个，必须不能在开头结尾，后面可以接一个+(-)，然后后序的必须全是连续整数</li><li>‘x’其他符号，直接返回False</li></ul><hr><h1 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h1><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    s= <span class="string">''</span></span><br><span class="line">    cDict = &#123;&#125;</span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> self.cDict <span class="keyword">and</span> self.cDict[c] ==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s = self.s+char</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> char:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> self.cDict:</span><br><span class="line">                self.cDict[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.cDict[c] = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>遍历两边，每次的时间都是O(n)*O(1),第一遍遍历来存每个字符的次数，第二遍遍历找第一个出现为1次的字符<br><strong>注意第二遍遍历的不是字典，因为字典不是按照存储顺序排列的，所以遍历的是s</strong></p><hr><h1 id="链表中环的入口点"><a href="#链表中环的入口点" class="headerlink" title="链表中环的入口点"></a>链表中环的入口点</h1><p>一个链表中包含环，请找出该链表的环的入口结点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        linkAdd = set()</span><br><span class="line">        pre = pHead</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> id(pre) <span class="keyword">in</span> linkAdd:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                linkAdd.add(id(pre))</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单的一道题，循环遍历往下找，一遍把地址存HashTable中(这里用的set)，如果发现自己的地址被存过，那么这个节点就是入口点。</p><hr><h1 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h1><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> (<span class="keyword">not</span> pHead.next):</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.next <span class="keyword">and</span> (pHead.val == pHead.next.val):</span><br><span class="line">            pHead = self.getNewpHead(pHead)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        pre = pHead</span><br><span class="line">        <span class="keyword">while</span> pre.next:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre.next.next:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> pre.next.val == pre.next.next.val:</span><br><span class="line">                <span class="comment"># 消除重复数字</span></span><br><span class="line">                tempNum = pre.next.val</span><br><span class="line">                <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.val == tempNum:</span><br><span class="line">                    pre.next = pre.next.next</span><br><span class="line">                <span class="comment"># 如果是消除重复数字结束，那么不用往后移</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            pre = pre.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNewpHead</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pre = pHead</span><br><span class="line">        <span class="comment"># 处理头结点</span></span><br><span class="line">        <span class="keyword">if</span> pre.val == pre.next.val:</span><br><span class="line">            temp = pre.val</span><br><span class="line">            <span class="keyword">while</span> pre <span class="keyword">and</span> (pre.val == temp):</span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="comment"># 如果直接到头了，返回None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        pHead = pre</span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong><br>首先要把头结点拿出单独处理，头结点一定是不能重复的，做完去重操作以后，得到新的头结点，然后跳过重复的节点往后指，然后主要注意的问题有</p><ul><li><strong>边界问题，时刻要注意是否对一个None引用了val或next等方法</strong></li><li><strong>or 和 and 的先后问题，先决条件要放到前面，编译器是按照先后顺序来看的</strong></li><li><strong>头结点处理完以后要判断是否直接结束了(全都是同样的值)</strong></li><li><strong>再就是消除链表除头结点意外的操作的时候的下标边界和循环逻辑等问题了。</strong></li></ul><hr><h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 如果有右子树</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            node = pNode.right</span><br><span class="line">            <span class="keyword">while</span> node.left:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># 如果是跟节点</span></span><br><span class="line">        <span class="keyword">if</span> pNode.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 如果没右子树，自己是父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> pNode.next.left == pNode:</span><br><span class="line">            <span class="keyword">return</span> pNode.next</span><br><span class="line">        <span class="comment"># 如果没右子树，自己是父节点的右节点</span></span><br><span class="line">        <span class="keyword">if</span> pNode.next.right == pNode:</span><br><span class="line">            node = pNode.next</span><br><span class="line">            <span class="keyword">while</span> node == node.next.right:</span><br><span class="line">                node = node.next</span><br><span class="line">                <span class="comment"># 如果一直追溯到根节点，那么说明遍历完了，返回None</span></span><br><span class="line">                <span class="keyword">if</span> node.next == <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> node.next</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>中序遍历的特点是先遍历完左子树所有部分，再遍历本身节点，再遍历右子树所有部分。<br>给出当前节点(已经遍历完)，求下个节点分如下几种情况：<br>1.有右子树，那么下个节点肯定在右子树里，找的方法也很简单，从该节点的右节点开始，如果有左子树就一直延伸，直到没有左子树为止。<br>2.没有右子树<br>(1) 是跟节点，直接返回None，已经结束了<br>(2) 是父节点的左子节点，那么下个点肯定是父节点<br>(3) 是父节点的右子节点，<strong>那对这个节点的父节点来说，它作为根节点的这颗子树已经遍历完了，往回再找它的父节点，如果它的父节点也是它的父节点的父节点的右节点，那么同理说明那颗子树也遍历完了，直到往回找到一个节点它是它父节点的左节点的时候，诶！这个时候它的父节点就是下一个节点啦</strong>，那如果一直都到根节点都找不到这样的节点，说明遍历已经结束了，不存在下个节点</p><hr><h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><strong>第一种方法</strong>，任何一种遍历顺序，调换left和right的位置，如果序列依然相同，则对称。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    preSort =[]</span><br><span class="line">    afterSort = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        pre = pRoot</span><br><span class="line">        self.preSortBT(pre)</span><br><span class="line">        pre = pRoot</span><br><span class="line">        self.afterSortBT(pre)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.preSort)):</span><br><span class="line">            <span class="keyword">if</span> self.preSort[i]!=self.afterSort[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preSortBT</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.left:</span><br><span class="line">            self.preSortBT(pRoot.left)</span><br><span class="line">        self.preSort.append(pRoot.val)</span><br><span class="line">        <span class="keyword">if</span> pRoot.right:</span><br><span class="line">            self.preSortBT(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">afterSortBT</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.right:</span><br><span class="line">            self.afterSortBT(pRoot.right)</span><br><span class="line">        self.afterSort.append(pRoot.val)</span><br><span class="line">        <span class="keyword">if</span> pRoot.left:</span><br><span class="line">            self.afterSortBT(pRoot.left)</span><br></pre></td></tr></table></figure></p><p><strong>第二种方法：</strong><br>递归，每次判断对称的两个点的对称的两组点是否对称，依次递归，二刷写代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 需要两个栈来实现，当前打印是奇数层的时候，先左后右入栈，当前是偶数层的时候，先右后左入栈</span></span><br><span class="line">    stack1 = []</span><br><span class="line">    stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.stack1.append(pRoot)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> self.stack1 <span class="keyword">or</span> self.stack2:</span><br><span class="line">            tempResult = []</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                nowNode = self.stack1.pop()</span><br><span class="line">                tempResult.append(nowNode.val)</span><br><span class="line">                <span class="keyword">if</span> nowNode.left:</span><br><span class="line">                    self.stack2.append(nowNode.left)</span><br><span class="line">                <span class="keyword">if</span> nowNode.right:</span><br><span class="line">                    self.stack2.append(nowNode.right)</span><br><span class="line">            <span class="keyword">if</span> tempResult:</span><br><span class="line">                result.append(tempResult)</span><br><span class="line">            tempResult = []</span><br><span class="line">            <span class="keyword">while</span> self.stack2:</span><br><span class="line">                nowNode = self.stack2.pop()</span><br><span class="line">                tempResult.append(nowNode.val)</span><br><span class="line">                <span class="keyword">if</span> nowNode.right:</span><br><span class="line">                    self.stack1.append(nowNode.right)</span><br><span class="line">                <span class="keyword">if</span> nowNode.left:</span><br><span class="line">                    self.stack1.append(nowNode.left)</span><br><span class="line">            <span class="keyword">if</span> tempResult:</span><br><span class="line">                result.append(tempResult)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>按照剑指思路来的，利用两个栈来实现，引用一下一篇博客里的说法：<br><img src="/2018/01/07/剑指offer-1/1111.jpg" alt=""><br><img src="/2018/01/07/剑指offer-1/22222.jpg" alt=""><br>以题目中的二叉树为例，一步步分析。</p><ul><li>当二叉树的根结点（结点1）打印之后，它的左子结点（结点2）和右子结点（结点3）先后保存到一个容器中。值得注意的是，在打印第二层的结点时，先打印结点3，后打印结点2。由此可见结点在这个容器中是后进先出的，因此该容器可以用栈来实现。</li><li>接着打印第二层的两个节点。根据题目定义，先打印结点3，再打印结点2，并把他们的子结点放入一个容器中。注意到，打印第三层时，先打印结点2的两个结点，后打印结点3的两个结点。这意味着，我们还可以用一个栈来保存结点2和结点3的子结点。</li><li>此外我们还注意到，第三层的结点是从左向右打印的。按照栈后进先出的特点，应该先保存7到栈中，再保存结点6，之后再分别保存结点5和结点4。也就是说，在打印第二层的时候，我们先保存右子结点到栈中，再保存左子结点到栈中。保存子结点的顺序和打印第一层时不一样。</li><li>接下来打印第三层。与之前一样，在打印第三层的同时，我们要把第四层的结点保存到一个栈中。由于第四层的打印顺序是从右到左，因此保存的顺序是从左到右。这和保存根结点的两个子结点的顺序是一样的。</li></ul><hr><h1 id="把二叉树打印成多行-按层打印二叉树"><a href="#把二叉树打印成多行-按层打印二叉树" class="headerlink" title="把二叉树打印成多行(按层打印二叉树)"></a>把二叉树打印成多行(按层打印二叉树)</h1><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    quene1 = []</span><br><span class="line">    quene2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.quene1 = [pRoot]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> self.quene1 <span class="keyword">or</span> self.quene2:</span><br><span class="line">            tempResult = []</span><br><span class="line">            <span class="keyword">while</span> self.quene1:</span><br><span class="line">                nowNode = self.quene1.pop(<span class="number">0</span>)</span><br><span class="line">                tempResult.append(nowNode.val)</span><br><span class="line">                <span class="keyword">if</span> nowNode.left:</span><br><span class="line">                    self.quene2.append(nowNode.left)</span><br><span class="line">                <span class="keyword">if</span> nowNode.right:</span><br><span class="line">                    self.quene2.append(nowNode.right)</span><br><span class="line">            <span class="keyword">if</span> tempResult:</span><br><span class="line">                result.append(tempResult)</span><br><span class="line">            tempResult = []</span><br><span class="line">            <span class="keyword">while</span> self.quene2:</span><br><span class="line">                nowNode = self.quene2.pop(<span class="number">0</span>)</span><br><span class="line">                tempResult.append(nowNode.val)</span><br><span class="line">                <span class="keyword">if</span> nowNode.left:</span><br><span class="line">                    self.quene1.append(nowNode.left)</span><br><span class="line">                <span class="keyword">if</span> nowNode.right:</span><br><span class="line">                    self.quene1.append(nowNode.right)</span><br><span class="line">            <span class="keyword">if</span> tempResult:</span><br><span class="line">                result.append(tempResult)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>因为这道题跟上面那个非常像，稍微改一下就A了，很舒服。之字形式倒着打么，就用两个栈，那这个先进先打就换成队列就OK了。</p><hr><h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    head = <span class="keyword">None</span></span><br><span class="line">    pre = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            templeft = root.left</span><br><span class="line">            tempright = root.right</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.Convert(templeft)</span><br><span class="line">            <span class="comment"># 如果是头结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">                self.head = root</span><br><span class="line">                self.pre = root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 因为是中序遍历的，所以当前root肯定是pre的下一个节点</span></span><br><span class="line">                root.left = self.pre</span><br><span class="line">                self.pre.right = root</span><br><span class="line">                self.pre = root</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.Convert(tempright)</span><br><span class="line">        trans(pRootOfTree)</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>pre存中序遍历的上一个节点，root是当前节点，递归处理左右子树，根节点不处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;剑指刷题及思路&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2017-JDD京东金融算法大赛15th解决方案</title>
    <link href="http://yoursite.com/2017/12/30/JDD/"/>
    <id>http://yoursite.com/2017/12/30/JDD/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-03-11T13:42:01.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDD-2017"><a href="#JDD-2017" class="headerlink" title="JDD-2017"></a>JDD-2017</h1><p><strong>JDD-2017 京东金融大数据竞赛-销量预测-15th解决方案</strong><br><img src="/2017/12/30/JDD/1.png" alt="Markdown"></p><h2 id="比赛说明"><a href="#比赛说明" class="headerlink" title="比赛说明"></a>比赛说明</h2><p>通过竞赛数据中店铺过往的销售记录，商品信息，商品评价，以及广告费用等信息来建立预测模型，预测店铺未来90天内的销售额。<br>训练数据包含2017-04-30日之前270天之内若干店铺的每日订单量、销售额、顾客数、评价数、广告费用等数据，下架时间在2017-04-30之后或者未下架的商品数据，以及这些店铺2016年6月-2017年1月每月末后90天内的销售额。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>特殊的数据主要包含以下几部分</p><ul><li><strong>活动促销</strong>：比如双11和618</li><li><strong>特殊月份</strong>：比如过年前后</li><li><strong>店铺刷单</strong>：有些店铺平时销量很低，会有几天莫名其妙的很高</li><li><strong>下降商品</strong>：某些店铺会在短时间内下架大量的商品</li></ul><h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p>我们试过非常多的方案，最终选择了使用一个月作为训练区间，该月的前三个月作为特征提取区间</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="商品特征"><a href="#商品特征" class="headerlink" title="商品特征"></a>商品特征</h3><ul><li>在售总商品数</li><li>平均每个商品的订单量</li><li>平均每个商品的实际销量</li><li>平均每个商品的退货订单数</li><li>未售商品占总商品的比例</li></ul><h3 id="订单特征"><a href="#订单特征" class="headerlink" title="订单特征"></a>订单特征</h3><ul><li>总销售金额</li><li>平均每个订单销售金额</li><li>总优惠金额</li><li>平均每笔订单优惠金额</li><li>总优惠金额占总销售金额比</li><li>总订单量</li><li>总退货订单量</li><li>总实际订单量</li><li>总退货订单金额</li><li>退货金额占总销售额金额的比</li><li>总实际销售金额</li><li>平均每笔订单实际销售金额</li><li>总顾客数</li><li>平均每个顾客的订单量</li><li>平均每个顾客的购买金额</li><li>平均每个顾客的退货订单数</li><li>平均每个顾客的退货金额</li><li>总优惠笔数</li><li>总优惠金额占总退货金额比例</li><li>平均每笔订单总优惠金额占总退货金额比例</li><li>平均每笔优惠金额</li><li>平均销售金额增长率（每个月和前一个月算增长率，所有增长率取平均）</li><li>平均订单量增长率</li><li>平均退货订单增长率</li><li>平均退货金额增长率</li></ul><h3 id="评价特征（取平均的时候是按照有效评论日期取平均）"><a href="#评价特征（取平均的时候是按照有效评论日期取平均）" class="headerlink" title="评价特征（取平均的时候是按照有效评论日期取平均）"></a>评价特征（取平均的时候是按照有效评论日期取平均）</h3><ul><li>总好评数</li><li>总中评数</li><li>总差评数</li><li>总评论数</li><li>平均好评数</li><li>平均中评数</li><li>平均差评数</li><li>好评率</li><li>差评率</li><li>中评率</li><li>平均好评率增长率</li></ul><h3 id="交叉特征"><a href="#交叉特征" class="headerlink" title="交叉特征"></a>交叉特征</h3><ul><li>平均每个月的充值广告费用占总销售金额比</li><li>平均每个月的充值广告费用占实际销售金额比</li><li>平均每个订单的好评率</li><li>平均每个订单的差评率</li><li>平均每个订单的好评数</li><li>平均每个订单的差评数</li></ul><h3 id="销售额和下架特征"><a href="#销售额和下架特征" class="headerlink" title="销售额和下架特征"></a>销售额和下架特征</h3><ul><li>总销售额</li><li>当月销售额</li><li>前一个月总销售金额</li><li>前两个月总销售金额</li><li>前三个月总销售金额</li><li>前一个周总销售金额</li><li>前两个周总销售金额</li><li>前三个周总销售金额</li><li>前一个月下架商品数</li><li>前两个月下架商品数</li><li>前三个月下架商品数</li><li>最近一周下架商品数</li></ul><p>一开始加的特征比较多，因为效果还不错吧，所以也没有根据线上去判断一下哪些特征是否有用，而且这个比赛想构建一个比较稳定的线下验证是非常困难的，因为销量波动还是比较大的，所以更多的时候是以线上来验证我的一些想法。根据特征的重要性来看，跟销售金额有关的特征比较强一些，某些特征重要性非常低但是我也没删除。</p><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>因为某些店铺的销量波动实在是太大了，所以除了预测销量的模型之外，我还尝试构建了一个二分类模型，主要来区别销量比较平稳和销量波动很大的商铺，所以最终的模型为：<br><img src="http://i2.bvimg.com/620746/1b1eaf565bb477cas.png" alt="Markdown"></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;比赛记录和思路&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="比赛" scheme="http://yoursite.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2017/12/28/leetcode/"/>
    <id>http://yoursite.com/2017/12/28/leetcode/</id>
    <published>2017-12-27T16:00:00.000Z</published>
    <updated>2018-03-11T13:42:22.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-Two-sum"><a href="#Array-Two-sum" class="headerlink" title="(Array)Two sum"></a>(Array)Two sum</h1><p>**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.**</p><p>Example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p><p>给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解）</p><p>Sample solution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    buff_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> buff_dict:</span><br><span class="line">            <span class="keyword">return</span> [buff_dict[nums[i]], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buff_dict[target - nums[i]] = i</span><br></pre></td></tr></table></figure></p><p><strong>思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index]</strong></p><hr><h1 id="Array-Reverse-Integer"><a href="#Array-Reverse-Integer" class="headerlink" title="(Array)Reverse Integer"></a>(Array)Reverse Integer</h1><p>Q:Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output:  <span class="number">-321</span></span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output:  <span class="number">21</span></span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>My Answer:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(str(nums))&gt;<span class="number">0</span> <span class="keyword">and</span> nums != <span class="number">0</span> <span class="keyword">and</span> nums &lt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">            nums = str(nums)</span><br><span class="line">            newStr = <span class="string">''</span></span><br><span class="line">            <span class="comment"># len(nums)-1 to -1 , -1 not included , interval is -1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                newStr = newStr + nums[i]</span><br><span class="line">            print(newStr)</span><br><span class="line">            <span class="keyword">while</span> newStr[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                newStr= newStr[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> newStr[<span class="number">-1</span>]==<span class="string">'-'</span>:</span><br><span class="line">                newStr=<span class="string">'-'</span>+newStr[:len(newStr)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> math.fabs(int(newStr)) &gt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span>(int(newStr))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：主要注意几点</strong><br>1.32位有符号整数范围判断<br>2.逆序以后0的处理<br>3.切片时注意索引是否会超范围，也就是只输入0的情况<br>4.对于是否为负的处理</p><hr><h1 id="Array-Palindrome-Number"><a href="#Array-Palindrome-Number" class="headerlink" title="(Array)Palindrome Number"></a>(Array)Palindrome Number</h1><p><strong>判断是否是回文数字</strong><br><strong>注意</strong><br>1.负数不为回文数<br>2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性</p><p>Mysolution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> nums&lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> math.pow(<span class="number">10</span>,length) &lt;= nums:</span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(math.ceil(length/<span class="number">2</span>)):</span><br><span class="line">                status = math.isclose((math.floor(nums/math.pow(<span class="number">10</span>,i))%<span class="number">10</span>),(math.floor(nums/math.pow(<span class="number">10</span>,length-i<span class="number">-1</span>))%<span class="number">10</span>),abs_tol = <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="keyword">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p><strong>Hint:</strong> 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。</p><hr><h1 id="Array-Non-decreasing-Array"><a href="#Array-Non-decreasing-Array" class="headerlink" title="(Array)Non-decreasing Array"></a>(Array)Non-decreasing Array</h1><p><strong>非下降数组</strong><br><strong>Q:</strong>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<strong></strong>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could modify the first </span><br><span class="line"><span class="number">4</span></span><br><span class="line"> to </span><br><span class="line"><span class="number">1</span></span><br><span class="line"> to get a non-decreasing array.</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">False</span></span><br><span class="line">Explanation: You can<span class="string">'t get a non-decreasing array by modify at most one element.</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>:The n belongs to [1, 10,000].</p><p><strong>题意:</strong>给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。</p><p> <strong>Mysolution:</strong><br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">       num1 = nums.copy()</span><br><span class="line">       num2 = nums.copy()</span><br><span class="line">       <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">           <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">               num1[i] = num1[i+<span class="number">1</span>]</span><br><span class="line">               num2[i+<span class="number">1</span>] = num2[i]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">return</span> num1==sorted(num1) <span class="keyword">or</span> num2==sorted(num2)</span><br></pre></td></tr></table></figure></p><p><strong>借鉴了Discuss里 -Yangshun的思路:</strong>First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting.</p><hr><h1 id="Array-k-diff-Pairs-in-an-Array"><a href="#Array-k-diff-Pairs-in-an-Array" class="headerlink" title="(Array)k-diff Pairs in an Array"></a>(Array)k-diff Pairs in an Array</h1><p><strong>Q:</strong>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.<br><strong>Example 1:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: There are two <span class="number">2</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">and</span> (<span class="number">3</span>, <span class="number">5</span>).</span><br><span class="line">Although we have two <span class="number">1</span>s <span class="keyword">in</span> the input, we should only <span class="keyword">return</span> the number of unique pairs.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], k = <span class="number">1</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: There are four <span class="number">1</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>) <span class="keyword">and</span> (<span class="number">4</span>, <span class="number">5</span>).</span><br></pre></td></tr></table></figure></p><p><strong>Example 3:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], k = <span class="number">0</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> one <span class="number">0</span>-diff pair <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">1</span>).</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong><br>1.(1,3),(3,1)属于同一个数值对<br>2.k为负的时候返回0<br>3.注意处理k=0的情况<br>4.不要使用循环嵌套，必超时<br><strong> Mysolution </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 精简版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums))))</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">        <span class="keyword">return</span> len(set(sorted(nums)) &amp; set(map(<span class="keyword">lambda</span> x:x+k,nums)))</span><br></pre></td></tr></table></figure></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样写会好理解一些</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">           <span class="comment">#nums = list(filter(lambda x:nums.count(x)&gt;1,nums))</span></span><br><span class="line">           <span class="comment">#return len(set(nums))</span></span><br><span class="line">       nums = set(sorted(nums))</span><br><span class="line">       nums1 = set(map(<span class="keyword">lambda</span> x:x+k,nums))</span><br><span class="line">       <span class="keyword">return</span> len(nums &amp; nums1)</span><br></pre></td></tr></table></figure><p>思路：将数组中每个数+k后与原数组取交集</p><hr><h1 id="Hash-Table-Count-Primes"><a href="#Hash-Table-Count-Primes" class="headerlink" title="(Hash Table)Count Primes"></a>(Hash Table)Count Primes</h1><p><strong>Description:</strong><br>Count the number of prime numbers less than a non-negative number, <strong>n.</strong><br>计算小于正整数n的素数的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 一个长度为n的，值为True的list</span></span><br><span class="line">    primes = [<span class="keyword">True</span>] * n</span><br><span class="line">    <span class="comment"># 前两位置为False 0和1 都不是素数，最小的素数是2</span></span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数</span></span><br><span class="line">        <span class="comment"># 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了</span></span><br><span class="line">        <span class="keyword">if</span> primes[i]:</span><br><span class="line">            <span class="comment"># 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数</span></span><br><span class="line">            <span class="comment"># 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了</span></span><br><span class="line">            primes[i * i: n: i] = [<span class="keyword">False</span>] * len(primes[i * i: n: i])</span><br><span class="line">    <span class="comment"># 返回剩余的True的个数</span></span><br><span class="line">    <span class="keyword">return</span> sum(primes)</span><br></pre></td></tr></table></figure><p>这个算法实现的是<strong>埃拉托斯特尼筛法</strong>：<br>算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于  的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了）</p><hr><h1 id="Array-Medium-Insert-Delete-GetRandom-O-1"><a href="#Array-Medium-Insert-Delete-GetRandom-O-1" class="headerlink" title="(Array-Medium)Insert Delete GetRandom O(1)"></a>(Array-Medium)Insert Delete GetRandom O(1)</h1><p><strong>Description:</strong><br>Design a data structure that supports all following operations in average O(1) time.<br> 1.insert(val) : Inserts an item val to the set if not already present.<br> 2.remove(val) : Removes an item val from the set if present.<br> 3.getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned.</p><p><strong>Example：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">1</span> to the set. Returns true <span class="keyword">as</span> <span class="number">1</span> was inserted successfully.</span><br><span class="line">randomSet.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// Returns false <span class="keyword">as</span> <span class="number">2</span> does <span class="keyword">not</span> exist <span class="keyword">in</span> the set.</span><br><span class="line">randomSet.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">2</span> to the set, returns true. Set now contains [<span class="number">1</span>,<span class="number">2</span>].</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// getRandom should <span class="keyword">return</span> either <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes <span class="number">1</span> <span class="keyword">from</span> the set, returns true. Set now contains [<span class="number">2</span>].</span><br><span class="line">randomSet.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="number">2</span> was already <span class="keyword">in</span> the set, so <span class="keyword">return</span> false.</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Since <span class="number">2</span> <span class="keyword">is</span> the only number <span class="keyword">in</span> the set, getRandom always <span class="keyword">return</span> <span class="number">2.</span></span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p><p><strong> My Solution*</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Rset,self.Rlist = set(),[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Rset.add(val)</span><br><span class="line">            self.Rlist.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            self.Rset.remove(val)</span><br><span class="line">            self.Rlist.remove(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.Rlist)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素<br>再添加一个discuss里用<strong>字典</strong>和list来实现的代码，更快一些：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums, self.pos = [], &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.pos:</span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            self.pos[val] = len(self.nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.pos:</span><br><span class="line">            idx, last = self.pos[val], self.nums[<span class="number">-1</span>]</span><br><span class="line">            self.nums[idx], self.pos[last] = last, idx</span><br><span class="line">            self.nums.pop(); self.pos.pop(val, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[random.randint(<span class="number">0</span>, len(self.nums) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p><hr><h1 id="Array-medium-4Sum-拓展为Nsum问题"><a href="#Array-medium-4Sum-拓展为Nsum问题" class="headerlink" title="(Array-medium)4Sum(拓展为Nsum问题)"></a>(Array-medium)4Sum(拓展为Nsum问题)</h1><p><strong>Description</strong><br>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br><strong>Note:</strong> The solution set must not contain duplicate quadruplets.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Solution</strong>借鉴discuss的思路，很不错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N,nums,target,result,results)</span>:</span></span><br><span class="line">            <span class="comment"># 特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> N&gt;len(nums) <span class="keyword">or</span> target&gt;N*nums[<span class="number">-1</span>] <span class="keyword">or</span> target&lt;N*nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 高效的2Sum</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                        <span class="comment"># 补充到最终结果</span></span><br><span class="line">                        results.append(result + [nums[l], nums[r]])</span><br><span class="line">                        <span class="comment"># 左指针右移，同时右指针左移，因为已经排好序了，一个值不变另一个值变一定不会得到target</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 解决重复问题</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> r &gt; l <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 注意这里的范围，是到len(nums)-N+1,因为最后N个数为最后一组，无须再进行递归</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 结合sorted可解决重复问题</span></span><br><span class="line">                    <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> (i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]!=nums[i]):</span><br><span class="line">                        <span class="comment"># 递归，将nSum问题降为n-1Sum问题</span></span><br><span class="line">                        Nsum(N<span class="number">-1</span>,nums[i+<span class="number">1</span>:],target-nums[i],result+[nums[i]],results)</span><br><span class="line">        results = []</span><br><span class="line">        Nsum(<span class="number">4</span>,sorted(nums),target,[],results)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：给定一个list和一个target，求所有n个list中的数和为target的不重复组合。本题是4Sum，代码拓展为了nSum问题，主要思路是通过迭代来把问题转换为高效的2Sum问题，即nSum-&gt;n-1Sum-&gt;….-&gt;4Sum-&gt;3Sum-&gt;2Sum,具体细节在代码注释中。</p><hr><h1 id="Hash-Table-Repeated-DNA-Sequences"><a href="#Hash-Table-Repeated-DNA-Sequences" class="headerlink" title="(Hash-Table)Repeated DNA Sequences"></a>(Hash-Table)Repeated DNA Sequences</h1><p><strong>Description</strong>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.<br>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.<br>For example,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given s = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>].</span><br></pre></td></tr></table></figure></p><p>就是求一个字符串里的所有指定长度的重复子字符串。<br><strong>Mysolution</strong><br>class Solution(object):<br>    def findRepeatedDnaSequences(self, s):<br>        “””<br>        :type s: str<br>        :rtype: List[str]<br>        “””<br>        if len(s)&lt;10:<br>            return []<br>        results = []<br>        DNAdict = {}<br>        for i in range(len(s)-9):<br>            if s[i:i+10] in DNAdict:<br>                DNAdict[s[i:i+10]] +=1<br>            else:<br>                DNAdict[s[i:i+10]] =0<br>        for key,value in DNAdict.items():<br>            if value&gt;0:<br>                results.append(key)<br>        return results<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**思路** 循环切片判断是否重复，数据结构用的字典，注意的就是range的范围和切片的范围问题。将10替换为N可以变为求一个字符串中长度为N的重复子串。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># Longest Palindromic Substring</span><br><span class="line">经典的最大回文子字符串问题</span><br><span class="line">样例：</span><br><span class="line">``` python</span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>从左到右依次把每个字符当做中心，然后依次判断两边的字符是否相等，最后取最大的那个就行了，唯一要注意的一点是连续字符的情况，比如 abccbd,这个时候要把cc整体作为一个字符串，这里用了两个位置变量，left和right，每次判断两边的相同字符之前要确定right的值，也就是相同字符的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            right = <span class="number">1</span></span><br><span class="line">            left = <span class="number">1</span></span><br><span class="line">            <span class="comment"># get the step length</span></span><br><span class="line">            <span class="keyword">while</span> i + right &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i + right] == s[i]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ((i -left ) &gt;= <span class="number">0</span> <span class="keyword">and</span> (i + right) &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i - left] == s[i + right]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            longest = s[i - left+<span class="number">1</span>:i + right]</span><br><span class="line">            <span class="keyword">if</span> len(longest) &gt; len(result):</span><br><span class="line">                result = longest</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h1 id="链表-Add-Two-Numbers"><a href="#链表-Add-Two-Numbers" class="headerlink" title="(链表)Add Two Numbers"></a>(链表)Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></p><p><strong>思路:</strong>就是由两个链表逆序表示的整数的和，没什么思路可言，这里主要考察的是对链表的操作，具体看代码，讲的很通俗易懂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s1 = str(l1.val)</span><br><span class="line">        s2 = str(l2.val)</span><br><span class="line">        <span class="keyword">while</span> l1.next:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            s1 = str(l1.val)+s1</span><br><span class="line">        <span class="keyword">while</span> l2.next:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            s2 = str(l2.val)+s2</span><br><span class="line">        result = str(int(s1)+int(s2))</span><br><span class="line">        <span class="comment"># 头节点</span></span><br><span class="line">        head = ListNode(int(result[<span class="number">-1</span>]))</span><br><span class="line">        after = head</span><br><span class="line">        <span class="comment"># 这里是对数组的操作，[-2::-1]表示从倒数第二个元素向后-1的取全部，注意这里[-2:0:-1]和[-2::-1]是不同的，前者取到下标为1，因为:左右就是[)的，后者取到数组头</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> result[<span class="number">-2</span>::<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># 新开辟一块内存空间</span></span><br><span class="line">            node = ListNode(int(c))</span><br><span class="line">            <span class="comment"># 让after.next指向这个内存空间，相当于把两个节点连接起来</span></span><br><span class="line">            after.next = node</span><br><span class="line">            <span class="comment"># after指向这块内存空间，方便下一个节点建立以后after代表这块内存空间去实行指向下一块新的节点的任务</span></span><br><span class="line">            after = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h1 id="字符串-最大字符不重复子串问题-Longest-Substring-Without-Repeating-Characters"><a href="#字符串-最大字符不重复子串问题-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="(字符串)最大字符不重复子串问题 Longest Substring Without Repeating Characters"></a>(字符串)最大字符不重复子串问题 Longest Substring Without Repeating Characters</h1><p>Given a string, find the length of the longest substring without repeating characters.<br><strong>Examples:</strong><br>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.<br>给定一个字符串，求其最大子串，要求子串中无重复字符</p><p><strong>思路:</strong>一开始我使用简单的从左到右每一个字符遍历最大子串，最后一个测试用例超时了，这里discuss里给出了一个特别好的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        usedChar = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="comment"># start是一个下表，表示这一轮新的字符串的开始下标</span></span><br><span class="line">        <span class="comment"># if s[i] in userChar 表示遍历到的当前字符曾经用过，有跟我当前新字符串重复的嫌疑</span></span><br><span class="line">        <span class="comment"># start &lt;= userChar[s[i]]就是说我去查查你上次出现的下标，如果是在start以后，也就是说在当前新字符串你已经出现过一次了，那么这次就算重复了</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">            <span class="comment"># 那么这次新字符串的遍历到此结束，start更新为上次这个下标出现的后一位字符，下面会有详细解释</span></span><br><span class="line">                start = usedChar[s[i]]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength = max(maxLength,i-start+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 每次都更新下标</span></span><br><span class="line">            usedChar[s[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">**举个例子说明**</span><br><span class="line">abczkoz543q</span><br><span class="line"></span><br><span class="line">从左到右遍历：(used 误拼为 user 了)</span><br><span class="line">a -&gt; not in userChar ; max(0,1)=1 ; userChar[a] = 0</span><br><span class="line">b -&gt; not in userChar ; max(1,2)=2 ; userChar[b] = 1</span><br><span class="line">c -&gt; not in userChar ; max(2,3)=3 ; userChar[c] = 2</span><br><span class="line">z -&gt; not in userChar ; max(3,4)=4 ; userChar[z] = 3</span><br><span class="line">k -&gt; not in userChar ; max(4,5)=5 ; userChar[k] = 4</span><br><span class="line">o -&gt; not in userChar ; max(5,6)=6 ; userChar[b] = 5</span><br><span class="line">(到这儿为止，字符串一直是从start=<span class="number">0</span>到当前下标，所以长度为<span class="number">6</span>)</span><br><span class="line">z -&gt; in userChar and start &lt; userChar[z]</span><br><span class="line">在这里z在下标为<span class="number">3</span>的时候出现过的，而当前字符串是从下标为<span class="number">0</span>开始的，所以这个字符串到此为止了，它贡献了maxLength=<span class="number">6</span></span><br><span class="line">然后更新start为<span class="number">3</span>+<span class="number">1</span>，也就是从z后面的k作为下一个字符串的开始下标</span><br><span class="line">这里就要从第二个开始继续遍历了，因为没必要从b开始再遍历，因为b也肯定会遍历第一个z然后遍历到第二个z，它形成的最大子串其实是a形成的最大子串的子串，即 bczko 属于 abzko</span><br><span class="line">所以直接从z的下一个元素，也就是k开始作为start即可，同时这里用到了字典，也降低了时间复杂度</span><br></pre></td></tr></table></figure><hr><h1 id="分治-两个数组的中位数-Median-of-Two-Sorted-Arrays"><a href="#分治-两个数组的中位数-Median-of-Two-Sorted-Arrays" class="headerlink" title="(分治)两个数组的中位数 Median of Two Sorted Arrays"></a>(分治)两个数组的中位数 Median of Two Sorted Arrays</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>限制时间复杂度是O(log(m+n))<br><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>思路:</strong>非常简单的一道题目，先用+连起来，sorted一下，如果是偶数就输出中间两个的均值，如果是奇数长度就输出中间那个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = sorted(nums1+nums2)</span><br><span class="line">        <span class="keyword">if</span> len(l)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (l[int(len(l)/<span class="number">2</span>)] + l[int(len(l)/<span class="number">2</span><span class="number">-1</span>)])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(l[int((len(l)<span class="number">-1</span>)/<span class="number">2</span>)])</span><br></pre></td></tr></table></figure></p><p><strong>但是</strong>其实这个复杂度是O(m+n),这种做法的思想基于下面这种做法一样，而且应该花的时间更长，是最优化最差也是最简单的做法：<br>依次遍历两个数组，每次取最小那个，直到遍历到第i个，这个i就是我们要的中位数或中间两个数，时间复杂度为O(m+n)<br><strong>有更好的做法：分治</strong><br>思路是分治常用的“割”，关键点是一条线割开两个数组，使得左边部分全部小于右边部分，这样就可以确定虚拟数组（两个数组合并排序）的前k个值了，妙啊妙啊。<br>这是O(min(m,n))的做法(感觉不够简练)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1)+len(nums2)&lt;=<span class="number">10</span>:</span><br><span class="line">            l = sorted(nums1 + nums2)</span><br><span class="line">            <span class="keyword">if</span> len(l) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> (float(l[int(len(l) / <span class="number">2</span>)]) + float(l[int(len(l) / <span class="number">2</span> - <span class="number">1</span>)])) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(l[int((len(l) - <span class="number">1</span>) / <span class="number">2</span>)])</span><br><span class="line">        <span class="keyword">if</span> len(nums1)&lt;len(nums2):</span><br><span class="line">            long = nums2</span><br><span class="line">            short = nums1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            long = nums1</span><br><span class="line">            short = nums2</span><br><span class="line">        <span class="keyword">if</span> (len(long)+len(short))%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 前面找k个数</span></span><br><span class="line">            k = ((len(nums1)+len(nums2))<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">            k1 = <span class="number">0</span></span><br><span class="line">            k2 = k - <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> ((k2 + <span class="number">1</span> &lt;= len(long) - <span class="number">1</span> <span class="keyword">and</span> short[k1] &gt; long[k2 + <span class="number">1</span>]) <span class="keyword">or</span> (</span><br><span class="line">                        k1 + <span class="number">1</span> &lt;= len(short) - <span class="number">1</span> <span class="keyword">and</span> long[k2] &gt; short[k1 + <span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">if</span> short[k1]&gt;long[k2+<span class="number">1</span>]:</span><br><span class="line">                    k1-=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k1+=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">            <span class="keyword">if</span> k1 + <span class="number">1</span> &lt;= len(short) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> min(short[k1 + <span class="number">1</span>], long[k2 + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> long[k2 + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = (len(nums1)+len(nums2))/<span class="number">2</span> <span class="number">-1</span></span><br><span class="line">            <span class="comment"># 割少的那个尾巴，注意下标</span></span><br><span class="line">            k1 = <span class="number">0</span></span><br><span class="line">            k2 = k<span class="number">-2</span></span><br><span class="line">            <span class="keyword">while</span>((k2+<span class="number">1</span>&lt;= len(long)<span class="number">-1</span> <span class="keyword">and</span> short[k1]&gt;long[k2+<span class="number">1</span>]) <span class="keyword">or</span> (k1+<span class="number">1</span> &lt;= len(short)<span class="number">-1</span> <span class="keyword">and</span> long[k2]&gt;short[k1+<span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">if</span> short[k1]&gt;long[k2+<span class="number">1</span>]:</span><br><span class="line">                    k1-=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k1+=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">            compareL = []</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k1+<span class="number">1</span>&lt;=len(short)<span class="number">-1</span> <span class="keyword">and</span> count &lt;<span class="number">2</span>:</span><br><span class="line">                compareL.append(short[k1+<span class="number">1</span>])</span><br><span class="line">                k1+=<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k2+<span class="number">1</span>&lt;=len(long)<span class="number">-1</span> <span class="keyword">and</span> count &lt;<span class="number">2</span>:</span><br><span class="line">                compareL.append(long[k2+<span class="number">1</span>])</span><br><span class="line">                k2+=<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            x1 = min(compareL)</span><br><span class="line">            compareL.remove(x1)</span><br><span class="line">            x2 = min(compareL)</span><br><span class="line">            <span class="keyword">return</span> (float(x1)+float(x2))/<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以加个二分查找就变为了O(log(min(m,n))),有空再更新吧</p><hr><h1 id="3Sum问题"><a href="#3Sum问题" class="headerlink" title="3Sum问题"></a>3Sum问题</h1><p>第二次重写Nsum问题，花了一个小时调试边界值，虽然基本思想没忘，但是对细节的处理很差，后面写上注意事项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N, L, subResult, target)</span>:</span></span><br><span class="line">            <span class="comment"># 这种写法的复杂度是nlog(n),超时了，改写为排序数组的2Sum写法</span></span><br><span class="line">            <span class="comment"># if N == 2:</span></span><br><span class="line">            <span class="comment">#     sumDict = &#123;&#125;</span></span><br><span class="line">            <span class="comment">#     for i in L:</span></span><br><span class="line">            <span class="comment">#         if i not in sumDict:</span></span><br><span class="line">            <span class="comment">#             sumDict[target - i] = i</span></span><br><span class="line">            <span class="comment">#         else:</span></span><br><span class="line">            <span class="comment">#             # 这里用了一个sorted来解决重复问题，不知道有没有更好的办法</span></span><br><span class="line">            <span class="comment">#             if sorted(subResult+[target-i,i]) not in result:</span></span><br><span class="line">            <span class="comment">#                 print subResult+[target-i,i]</span></span><br><span class="line">            <span class="comment">#                 result.append(sorted(subResult+[target-i,i]))</span></span><br><span class="line">            <span class="comment">#     return</span></span><br><span class="line">            <span class="keyword">if</span> N==<span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(L)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> r&gt;l:</span><br><span class="line">                    <span class="keyword">if</span> L[l]+L[r] == target:</span><br><span class="line">                        result.append(subResult+[L[r],L[l]])</span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> L[l] == L[l+<span class="number">1</span>]:</span><br><span class="line">                            l+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> L[r] == L[r<span class="number">-1</span>]:</span><br><span class="line">                            r-=<span class="number">1</span></span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L[l]+L[r] &gt; target:</span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L[l]+L[r] &lt; target:</span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 每次跳过重复字符</span></span><br><span class="line">                    <span class="comment"># while i&gt;1 and i&lt;len(L)-1 and L[i]==L[i-1]:</span></span><br><span class="line">                    <span class="comment">#     i+=1</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] != L[i]):</span><br><span class="line">                        Nsum(N - <span class="number">1</span>, L[i + <span class="number">1</span>:], subResult + [L[i]], target - L[i])</span><br><span class="line">        Nsum(<span class="number">3</span>,sorted(nums),[],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>1：</strong>思路依然是递归的将Nsum问题转化为2Sum问题，这里2Sum因为要找的值是不用管下标的，所以可以将数组排好序，这样可以将2Sum问题的时间<br>复杂度降为O(n),而找两个下标的2Sum问题的复杂度是O(nlogN),我一开始将两者弄混了，所以一开始用的找下标的那种方法，然后就超时了<br><strong>2：</strong>注意2Sum问题的时候，指针移动的时候，要先跳过所以重复值，加上l&lt;r就可以防止边界问题<br><strong>3：</strong>递归的地方我注释掉的部分，<strong>while i&gt;1 and i&lt;len(L)-1 and L[i]==L[i-1]:</strong>如果用这种方法来去掉遍历时候的重复值，会出现一些问题，比如[0,0,0,0,0]，<br>虽然跳过了0，但是最后一个0还是会进，这样就会出现输出为[[0,0,0],[0,0,0]]的情况，所以用if可以防止这种情况，只要和前面重复都不进。</p><hr><h1 id="NSum-Closest问题"><a href="#NSum-Closest问题" class="headerlink" title="NSum Closest问题"></a>NSum Closest问题</h1><p>是Nsum问题的变形，但是原理差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 全局变量问题</span></span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    <span class="keyword">global</span> Min</span><br><span class="line">    Min = <span class="number">9999</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(N, L, Sum, target)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> result</span><br><span class="line">        <span class="keyword">global</span> Min</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 从L里找两个数，使得min(|(x1+x2+sum)-1|)</span></span><br><span class="line">            l, r = <span class="number">0</span>, len(L) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 先替换</span></span><br><span class="line">                <span class="keyword">if</span> Min &gt; abs(L[r] + L[l] + Sum - target):</span><br><span class="line">                    Min = abs(L[r] + L[l] + Sum - target)</span><br><span class="line">                    result = L[r] + L[l] + Sum</span><br><span class="line">                <span class="comment"># 是否特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> abs(L[r] + L[l] + Sum - target) ==<span class="number">0</span>:</span><br><span class="line">                    result = L[r] + L[l] + Sum</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># 移动指针</span></span><br><span class="line">                <span class="keyword">if</span> L[r] + L[l] + Sum &gt; target <span class="keyword">and</span> l&lt;r:</span><br><span class="line">                    r-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> L[r] + L[l] + Sum &lt;target <span class="keyword">and</span> l&lt;r:</span><br><span class="line">                    l+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L) - N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i] != L[i - <span class="number">1</span>]):</span><br><span class="line">                    findSum(N - <span class="number">1</span>, L[i + <span class="number">1</span>:], Sum + L[i], target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    findSum(<span class="number">3</span>, sorted(nums), <span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>还是递归的思想减少的2Sum问题，每次左右指针先算一次去替换最小，如果出现最优情况直接return，否则根据情况移动左右指针，跟Nsum还是有所区别。</p><hr><h1 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h1><p>数字组合，给出手机上的号码，每个号码对应着一组字母，求之间的有多少种组合方式<br>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="图片"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>就是一个简单的递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        kvmaps = &#123;</span><br><span class="line">            <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">            <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">            <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">            <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">            <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">            <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">            <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">            <span class="string">'9'</span>: <span class="string">'wxyz'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">comLetter</span><span class="params">(number, L)</span>:</span></span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">if</span> number == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> L == []:result = [x <span class="keyword">for</span> x <span class="keyword">in</span> kvmaps[number[<span class="number">0</span>]]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> kvmaps[number[<span class="number">0</span>]]:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> L:</span><br><span class="line">                        result.append(y+x)</span><br><span class="line">            <span class="keyword">if</span> len(number) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> comLetter(number[<span class="number">1</span>:], result)</span><br><span class="line">        <span class="keyword">return</span> comLetter(digits, [])</span><br></pre></td></tr></table></figure><hr><h1 id="动态规划-最长不下降或不上升子序列"><a href="#动态规划-最长不下降或不上升子序列" class="headerlink" title="动态规划 最长不下降或不上升子序列"></a>动态规划 最长不下降或不上升子序列</h1><p><a href="http://blog.csdn.net/wy19910326/article/details/7229350" target="_blank" rel="noopener">参考</a></p><hr><h1 id="O-n-复杂度根据index删除链表中的元素"><a href="#O-n-复杂度根据index删除链表中的元素" class="headerlink" title="O(n)复杂度根据index删除链表中的元素"></a>O(n)复杂度根据index删除链表中的元素</h1><p>给定一个链表，要求删除掉倒数第n个元素，然后返回head<br>例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>要求onepass，遍历一次<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> fast.next:</span><br><span class="line">                fast = fast.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            slow.next = slow.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：两个指针，一个在前一个在后，他们之间的间隔为n，那么当前面的那个指针到达链表的尾部的时候，后面那个指针的下一个元素就是要删除掉的元素，直接next = next.next跳过就可以了</p><hr><h1 id="括号匹配问题Generate-Parentheses"><a href="#括号匹配问题Generate-Parentheses" class="headerlink" title="括号匹配问题Generate Parentheses"></a>括号匹配问题Generate Parentheses</h1><p>给定一个数字，比如3，在3个括号的前提下求所有可能的括号匹配，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>回溯，注意两个点，一个是左括号一定等于右括号，第二个是左括号一定大于右括号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addParentheses</span><span class="params">(strP,left,right)</span>:</span></span><br><span class="line">            <span class="comment"># 如果还剩下左括号，优先安排左括号</span></span><br><span class="line">            <span class="keyword">if</span> left: addParentheses(strP+<span class="string">'('</span>,left<span class="number">-1</span>,right)</span><br><span class="line">            <span class="comment"># 如果右括号比左括号剩的多，再安排右括号</span></span><br><span class="line">            <span class="keyword">if</span> right&gt;left:addParentheses(strP+<span class="string">')'</span>,left,right<span class="number">-1</span>)</span><br><span class="line">            <span class="comment"># 这样，在递归的过程中，就可以列出所有可能的情况了</span></span><br><span class="line">            <span class="keyword">if</span> right==<span class="number">0</span>:</span><br><span class="line">                result.append(strP)</span><br><span class="line">        addParentheses(<span class="string">''</span>,n,n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>下面就3的例子画个图解释一下：</strong><br><img src="http://i2.bvimg.com/620746/73363b4f08d0bb26s.jpg" alt="Markdown"></p><hr><h1 id="交换链表节点"><a href="#交换链表节点" class="headerlink" title="交换链表节点"></a>交换链表节点</h1><p>从左到右，一次交换每两个节点<br>例如 1-&gt;2-&gt;3-&gt;4-&gt;5 到 2-&gt;1-&gt;4-&gt;3-&gt;5<br>要求不准使用多余的空间，不准改变链表的值<br><strong>My Solution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        current = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> head.next:</span><br><span class="line">            temp = head.next</span><br><span class="line">            head.next = head.next.next</span><br><span class="line">            temp.next = head</span><br><span class="line">            head = temp</span><br><span class="line">            current = head.next</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="keyword">if</span> current.next:</span><br><span class="line">                <span class="keyword">if</span> current.next.next:</span><br><span class="line">                    first = current.next</span><br><span class="line">                    second = current.next.next</span><br><span class="line">                    current.next = second</span><br><span class="line">                    first.next = second.next</span><br><span class="line">                    second.next = first</span><br><span class="line">                    current = current.next.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>因为头结点比较特殊，所以我把对头结点的交换和后面的交换给分开了，主要用到三个变量，current,first,scond,其中，first和second是要交换的节点，current是first的上一个节点，所以要判断后面是否有两个值可以交换要判断current.next.next是否为None,具体的交换思路看下图</p><p><img src="/2017/12/28/leetcode/new1.jpg" alt="new1"></p><hr><h1 id="Reverse-Nodes-in-k-Group"><a href="#Reverse-Nodes-in-k-Group" class="headerlink" title="Reverse Nodes in k-Group"></a>Reverse Nodes in k-Group</h1><p>翻转链表中k-group，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p><p>感冒了脑子太僵了，先占个坑</p><hr><h1 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h1><p>下一个最大的数字串，如果不是最大的，就找一个最小的比它大的，如果已经已经最大了，找一个最小的,例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong></p><ul><li>从后往前遍历看看每一位是否能被替换</li><li>看每一位后面的所有字符是否有比它大的</li><li>挑出比它大的最小的那个来互换</li><li>互换完以后把该位后面的数按从小到大排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        AlreadyMax = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-2</span>,-len(nums)<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> max(nums[i:]) &gt; nums[i]:</span><br><span class="line">                AlreadyMax = <span class="number">0</span></span><br><span class="line">                min_index = <span class="number">0</span></span><br><span class="line">                minvalue = <span class="number">9999999</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)+i,len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &gt; nums[i] <span class="keyword">and</span> nums[j] &lt; minvalue:</span><br><span class="line">                        min_index = j</span><br><span class="line">                        minvalue = nums[j]</span><br><span class="line">                <span class="comment"># change</span></span><br><span class="line">                temp = nums[i]</span><br><span class="line">                nums[i] = nums[min_index]</span><br><span class="line">                nums[min_index] = temp</span><br><span class="line">                sortedList = sorted(nums[len(nums)+i+<span class="number">1</span>:])</span><br><span class="line">                m = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) + i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                    nums[j] = sortedList[m]</span><br><span class="line">                    m+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> AlreadyMax:</span><br><span class="line">            nums.reverse()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><hr><h1 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h1><p>翻转的有序数组里找个数，就是一个升序排序数组事先翻转了，例如：<br>0 1 2 4 5 6 7 -&gt; 4 5 6 7 0 1 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> nums.index(target) <span class="keyword">if</span> target <span class="keyword">in</span> nums <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findIndex</span><span class="params">(head, tail)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> tail - head &lt; <span class="number">3</span>:</span><br><span class="line">        result = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(head, tail + <span class="number">1</span>) <span class="keyword">if</span> nums[i] == target]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> result == [] <span class="keyword">else</span> result[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> nums[int((tail + head) / <span class="number">2</span>)]&gt;=nums[head]:</span><br><span class="line">        <span class="keyword">return</span> findIndex(head, int((tail + head) / <span class="number">2</span>)) <span class="keyword">if</span> nums[head]&lt;=target&lt;=nums[int((tail + head) / <span class="number">2</span>)] <span class="keyword">else</span> findIndex(int((tail + head) / <span class="number">2</span>), tail)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> findIndex(int((tail + head) / <span class="number">2</span>), tail) <span class="keyword">if</span> nums[int((tail + head) / <span class="number">2</span>)]&lt;=target&lt;=nums[tail] <span class="keyword">else</span> findIndex(head, int((tail + head) / <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> findIndex(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>思路：</strong><br>递归，参数为数组头和尾指针<br><img src="http://i1.bvimg.com/620746/63dcf9f59fae4d1cs.png" alt="Markdown"></p><hr><h1 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a>Search for a Range</h1><p><strong>找数组中某个数开始和结束的index</strong><br>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findIndex</span><span class="params">(head, tail)</span>:</span></span><br><span class="line">        halfIndex = int((tail + head) / <span class="number">2</span>)</span><br><span class="line">        halfNumber = nums[halfIndex]</span><br><span class="line">        <span class="keyword">if</span> nums[head] == nums[tail]:</span><br><span class="line">            <span class="keyword">return</span> [head,tail] <span class="keyword">if</span> nums[head]==target <span class="keyword">else</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> halfNumber != target <span class="keyword">and</span> halfIndex-head &gt; <span class="number">1</span> <span class="keyword">and</span> tail - halfIndex &gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> findIndex(head,halfIndex) <span class="keyword">if</span> target &lt; halfNumber <span class="keyword">else</span> findIndex(halfIndex,tail)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> halfIndex-head &gt; <span class="number">1</span> <span class="keyword">and</span> nums[int((head+halfIndex)/<span class="number">2</span>)]&lt;target:</span><br><span class="line">                head = int((head+halfIndex)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> tail - halfIndex &gt;<span class="number">1</span> <span class="keyword">and</span> nums[int((tail+halfIndex)/<span class="number">2</span>)]&gt;target:</span><br><span class="line">                tail = int((tail+halfIndex)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> tail &gt; head <span class="keyword">and</span> nums[head]!=target:</span><br><span class="line">                head+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> tail &gt; head <span class="keyword">and</span> nums[tail]!=target:</span><br><span class="line">                tail-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> findIndex(head,tail)</span><br><span class="line">    <span class="keyword">return</span> findIndex(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>二分法，我用的是从两边往中间缩，直到无法用二分法缩了以后，用while找到头和尾，详细一点：</p><ul><li>终止条件：如果头的值等于尾的值，判断是否等于target，是返回最终结果，否则[-1,-1]说明不在list里</li><li>如果中间值不等于target说明该值在左半部分或右半部分，递归</li><li>左边每次缩一半，如果还没遇到target的话，右边同理，缩到最小</li><li>左右多余一点儿裁掉，找到head和tail，返回<br><strong>注意：</strong>int((head+halfIndex)/2)如果两个index紧邻的话会无限重复，因为int(a,a+1)=a,需要判别</li></ul><hr><h1 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h1><p>给定一个正整数去重序列，求序列中所有和为target的非重复组合，每个数可以重复用，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Mysolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">        <span class="keyword">if</span> len(candidates)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        minValue = candidates[<span class="number">0</span>]</span><br><span class="line">        result= []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(Sum,tempL)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> Sum == <span class="number">0</span>:</span><br><span class="line">                final = sorted(tempL)</span><br><span class="line">                <span class="keyword">if</span> final <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                    result.append(final)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> candidates:</span><br><span class="line">                    <span class="keyword">if</span> Sum-x &gt;=<span class="number">0</span>:</span><br><span class="line">                        findSum(Sum-x,tempL+[x])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        findSum(target,[])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>递归，参数为每个子序列及其目前的和，每次用target减去总序列的每个值，如果为0，说明该子序列结束有解，如果为负数则无解，不添加该子序列。</p><hr><h1 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h1><p>与上个题基本一样，但是序列是重复的，并且每个数不能重复用，求所有和为target的非重复序列<br><strong>思路：</strong>递归参数加一个，nowCandidate，大小为遍历到的该数后面的序列[i+1:]<br><strong>solution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(candidates) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        minValue = candidates[<span class="number">0</span>]</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(Sum, tempL, nowCan)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> Sum == <span class="number">0</span>:</span><br><span class="line">                final = sorted(tempL)</span><br><span class="line">                <span class="keyword">if</span> final <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                    result.append(final)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nowCan)):</span><br><span class="line">                    <span class="keyword">if</span> Sum - nowCan[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                        findSum(Sum - nowCan[i], tempL + [nowCan[i]], nowCan[i+<span class="number">1</span>:])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        findSum(target, [], candidates)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h1><p>给定一个非重复整数串，求所有可能的子序排列，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>递归，从剩下的序列中遍历选取一个加入到目前子序列，再将这个数从剩下的子序列中删除<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findAll</span><span class="params">(nowL, remainL)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> remainL == []:</span><br><span class="line">                result.append(nowL)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remainL)):</span><br><span class="line">                tempL = remainL[:]</span><br><span class="line">                tempL.remove(remainL[i])</span><br><span class="line">                findAll(nowL + [remainL[i]], tempL)</span><br><span class="line">        findAll([], nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a>Permutations II</h1><p>与上题类似，但是给定序列中有重复数字，求所有可能的子序排列（去重复）<br>只要在上题的基础上在每次从剩余序列选值的时候加上跳过重复值得操作即可，首先要对整个序列排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findAll</span><span class="params">(nowL, remainL)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> remainL == []:</span><br><span class="line">                result.append(nowL)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remainL)):</span><br><span class="line">                <span class="comment"># 加入下面这一行,因为不管在哪一轮，如果有两个以上重复的，那么选他们任意超过两个后续操作必然重复，因为没有区别</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> (i&gt;<span class="number">0</span> <span class="keyword">and</span> remainL[i]!=remainL[i<span class="number">-1</span>]):</span><br><span class="line">                    tempL = remainL[:]</span><br><span class="line">                    tempL.remove(remainL[i])</span><br><span class="line">                    findAll(nowL + [remainL[i]], tempL)</span><br><span class="line"></span><br><span class="line">        findAll([], nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h1 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h1><p>判断给的已经填充一部分的数独是否有效<br><strong>思路：</strong><br>只需要判断三个条件：</p><ul><li>行不能重复</li><li>列不能重复</li><li>九宫格内不能重复<br>所以，依次遍历每一个填充的值，把i,j,position（位于哪个九宫格）加入字典，只要有一个重复就fail</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sudokuDict = &#123;&#125;</span><br><span class="line">        n = len(board)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 判断在哪个九宫格内</span></span><br><span class="line">                position = [int(i / <span class="number">3</span>), int(j / <span class="number">3</span>)]</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] <span class="keyword">not</span> <span class="keyword">in</span> sudokuDict:</span><br><span class="line">                        sudokuDict[board[i][j]] = [[i, j, position]]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">for</span> l <span class="keyword">in</span> sudokuDict[board[i][j]]:</span><br><span class="line">                            <span class="keyword">if</span> l[<span class="number">0</span>] == i <span class="keyword">or</span> l[<span class="number">1</span>] == j <span class="keyword">or</span> l[<span class="number">2</span>] == position:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            sudokuDict[board[i][j]].append([i, j, position])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h1><p>旋转二位数组，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix <span class="keyword">in</span>-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>每次遍历最外层的正方形的第一层，找到四个位置的对应关系，依次替换即可（不用管奇数偶数问题，因为最后中心即使剩下一个单独的值无需替换）<br><img src="http://i2.bvimg.com/620746/e9f1106b57504a32s.png" alt="Markdown"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(int(n/<span class="number">2</span>)):</span><br><span class="line">            start = i</span><br><span class="line">            <span class="comment"># 不包括ends</span></span><br><span class="line">            end = n-i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(start,end):</span><br><span class="line">                print(start,end)</span><br><span class="line">                print(i,j)</span><br><span class="line">                <span class="comment">#   matrix[i][j]   -&gt;    matrix[j][end]</span></span><br><span class="line">                <span class="comment">#         ↑               ↓</span></span><br><span class="line">                <span class="comment"># matrix[n-1-j][start] &lt;- matrix[n-1-i][n-1-j]</span></span><br><span class="line">                temp = matrix[j][end]</span><br><span class="line">                matrix[j][end] = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n<span class="number">-1</span>-j][start]</span><br><span class="line">                matrix[n<span class="number">-1</span>-j][start] = matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j]</span><br><span class="line">                matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j] = temp</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><hr><h1 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a>Group Anagrams</h1><p>给定一个字符串数组，把里面字符串内容相同但是顺序不同的归到一起，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">given:: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>]</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>, <span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>依次遍历，用字典来存遍历过的字符串，键为排序过的字符串，如果不计算sort的时间的话，是nlog(n)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        result = []</span><br><span class="line">        searchDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            sortedS = <span class="string">''</span>.join(sorted(s))</span><br><span class="line">            <span class="keyword">if</span> sortedS <span class="keyword">in</span> searchDict:</span><br><span class="line">                searchDict[sortedS] += [s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                searchDict[sortedS] = [s]</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> searchDict.items():</span><br><span class="line">            result.append(v)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><hr><h1 id="Spiral-Matrix-螺旋矩阵"><a href="#Spiral-Matrix-螺旋矩阵" class="headerlink" title="Spiral Matrix 螺旋矩阵"></a>Spiral Matrix 螺旋矩阵</h1><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">output:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong><br>沿着一个方向一直走直到不能走，顺序是右下左上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        hasMoved = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            hasMoved[i] = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(cols)]</span><br><span class="line">        result = []</span><br><span class="line">        hasMoved[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        result.append(matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(result) != rows*cols:</span><br><span class="line">            <span class="keyword">while</span> j&lt;cols<span class="number">-1</span> <span class="keyword">and</span> hasMoved[i][j+<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                hasMoved[i][j+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                result.append(matrix[i][j+<span class="number">1</span>])</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; rows - <span class="number">1</span> <span class="keyword">and</span> hasMoved[i+<span class="number">1</span>][j] == <span class="number">0</span>:</span><br><span class="line">                hasMoved[i+<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">                result.append(matrix[i+<span class="number">1</span>][j])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;<span class="number">0</span> <span class="keyword">and</span> hasMoved[i][j<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                hasMoved[i][j<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                result.append(matrix[i][j<span class="number">-1</span>])</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> hasMoved[i<span class="number">-1</span>][j] == <span class="number">0</span>:</span><br><span class="line">                hasMoved[i<span class="number">-1</span>][j] = <span class="number">1</span></span><br><span class="line">                result.append(matrix[i<span class="number">-1</span>][j])</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)leetcode刷题记录&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow</title>
    <link href="http://yoursite.com/2017/10/10/Tensorflow/"/>
    <id>http://yoursite.com/2017/10/10/Tensorflow/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2018-03-11T13:42:43.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用flags定义命令行参数"><a href="#使用flags定义命令行参数" class="headerlink" title="使用flags定义命令行参数"></a>使用flags定义命令行参数</h1><p>flag在TensorFlow中用于定义命令行参数<br><a href="http://blog.csdn.net/leiting_imecas/article/details/72367937" target="_blank" rel="noopener">参考链接</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一个是参数名称，第二个参数是默认值，第三个是参数描述</span></span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">'str_name'</span>, <span class="string">'def_v_1'</span>,<span class="string">"descrip1"</span>)</span><br><span class="line">tf.app.flags.DEFINE_integer(<span class="string">'int_name'</span>, <span class="number">10</span>,<span class="string">"descript2"</span>)</span><br><span class="line">tf.app.flags.DEFINE_boolean(<span class="string">'bool_name'</span>, <span class="keyword">False</span>, <span class="string">"descript3"</span>)</span><br><span class="line"></span><br><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须带参数，否则：'TypeError: main() takes no arguments (1 given)';   main的参数名随意定义，无要求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span>  </span><br><span class="line">    print(FLAGS.str_name)</span><br><span class="line">    print(FLAGS.int_name)</span><br><span class="line">    print(FLAGS.bool_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tf.app.run()  <span class="comment">#执行main函数</span></span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@AliHPC-G41<span class="number">-211</span> test]<span class="comment"># python tt.py</span></span><br><span class="line">def_v_1</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">[root@AliHPC-G41<span class="number">-211</span> test]<span class="comment"># python tt.py --str_name test_str --int_name 99 --bool_name True</span></span><br><span class="line">test_str</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="Tensorflow实现线性回归"><a href="#Tensorflow实现线性回归" class="headerlink" title="Tensorflow实现线性回归"></a>Tensorflow实现线性回归</h1><p>(本习题也是港大深度学习的第一次作业)</p><h2 id="线性回归原理"><a href="#线性回归原理" class="headerlink" title="线性回归原理"></a>线性回归原理</h2><p><strong>单变量线性回归</strong></p><ul><li>因为是线性回归，所以学习到的函数为线性函数，即直线函数</li><li>因为是单变量，因此只有一个x<br>我们能够给出单变量线性回归的模型：<br><img src="http://img.blog.csdn.net/20161006121754312" alt="公式1"><br>我们常称x为feature，h(x)为hypothesis（假设函数）<br><strong>Cost Function：</strong>对假设的函数进行评价，Cost Function越小的函数，说明对训练数据拟合的越好。下面给出costFunction公式：<br><img src="http://img.blog.csdn.net/20161006124407924" alt="公式2"><br>如果theta0和theta1都不固定，则theta0、theta1、J的函数为：<br><img src="http://img.blog.csdn.net/20161006134926885" alt="公式3"><br><strong>注意如果是线性回归，则cost function一定是碗状的，即只有一个最小点。</strong></li></ul><p><strong>损失函数最优化：梯度下降</strong><br>下面给出梯度下降算法：<br><img src="http://img.blog.csdn.net/20161006140441811" alt="公式4"><br><strong>特点</strong><br><strong>a)</strong>初始点不同，获得的最小值也不同，因此梯度下降求得的只是局部最小值；<br><strong>b)</strong>越接近最小值，下降速度越慢。<br><strong>问题1：</strong>如果和初始值就在local minimum的位置，则、会如何变化？<br><strong>答案：</strong>因为、已经在local minimum位置，所以derivative（导数）肯定是0，因此、不会改变。<br><strong>问题2：</strong>如果取到一个正确的值，则cost function应该会越来越小。那么，怎么取值？<br><strong>答案：</strong>随时观察值，如果cost function变小了，则OK；反之，则再取一个更小的值。</p><p><strong>注意：</strong>下降的步伐大小非常重要，因为，如果太小，则找到函数最小值的速度就很慢；如果太大，则可能会出现overshoot the minimum现象。<br><img src="http://img.blog.csdn.net/20161006143417373" alt="overshoot"><br>那既然梯度下降可以求到损失函数的最小值，线性回归又是需要一个最小的损失函数，那么可以将两者进行整合：<br><img src="http://img.blog.csdn.net/20161006144108314" alt="整合"></p><p><strong>Feature Scaling</strong>此种方法应用于梯度下降，为了加快梯度下降的执行速度。<br>思想：将各个feature的值标准化，使得取值范围大致都在<strong>-1&lt;=x&lt;=1</strong>之间。<br>常用的方法是Mean Normalization，即<img src="http://img.blog.csdn.net/20161006144838659" alt="1">,或者[X-mean(X)]/std(X)。</p><p><strong>多变量线性回归</strong><br>其假设函数为:<br><img src="http://img.blog.csdn.net/20161006151000259" alt="3"><br>损失函数仍然定义为平方损失函数<br>最小化损失函数仍然可以用梯度下降法：<br><img src="http://img.blog.csdn.net/20161006151253077" alt="4"></p><p>下面给出python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据集 -2到2 200个点 等差数列</span></span><br><span class="line">x_train = np.linspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment"># 构造 系数为2 偏差为4的y 加入一些随机噪音</span></span><br><span class="line">y_train = x_train * <span class="number">2</span> + np.ones(len(x_train)) * <span class="number">4</span> + np.random.randn(len(x_train)) * <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensorflow构造模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.定义输入和输出的占位符 tf中一般是tf.float32</span></span><br><span class="line">X = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line">Y = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义参数变量,初始化为0</span></span><br><span class="line">w = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'weights'</span>)</span><br><span class="line">b = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'bias'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.定义假设模型的输出,wx+b</span></span><br><span class="line">y_pred = tf.multiply(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.定义损失函数,这里是平方损失函数</span></span><br><span class="line">loss = tf.square(y_pred - Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.定义优化函数来最小化损失函数,学习率，要最小化的损失函数</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到这里搭建完了图模型，但是不会产生任何运算结果，因为需要session来驱动</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># 变量必须要初始化，如果变量有嵌套关系，则必须按顺序初始化</span></span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line"><span class="comment"># 定义迭代次数</span></span><br><span class="line">iteration_nums = <span class="number">500</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration_nums):</span><br><span class="line">    <span class="comment"># 注意这里，要run的是optimizer这个函数，它又用到了loss这个函数，而loss函数又用到了y_pred这个结果，所以追溯向前，一共</span></span><br><span class="line">    <span class="comment"># 用到了 X,Y 这两个被占位符声明的输入与输出以及w,b这两个变量，而参数变量正是我们要优化的目标</span></span><br><span class="line">    sess.run(optimizer, feed_dict=&#123;X: x_train, Y: y_train&#125;)</span><br><span class="line"><span class="comment"># 学习完成后，变量w,b被重新赋值，打印w和b</span></span><br><span class="line">print(sess.run(w))</span><br><span class="line">print(sess.run(b))</span><br></pre></td></tr></table></figure></p><p>最终的输出为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.0024</span></span><br><span class="line"><span class="number">3.9702</span></span><br></pre></td></tr></table></figure></p><p>与预期输出相符，注意我在一开始设置步长为0.01的时候发散掉了，最后w和b都是nan，所以合理的调参是必不可少的<br>下面绘制一下样本点和回归函数的图像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意上面y_pred没有实际的值</span></span><br><span class="line">y_pred = sess.run(y_pred,&#123;X:x_train&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'Population of City in 10,000s'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Profit in $10,000s'</span>)</span><br><span class="line">plt.plot(x_train,y_train,marker=<span class="string">'x'</span>,lw=<span class="number">0</span>,color=<span class="string">'r'</span>,label=<span class="string">'Training data'</span>)</span><br><span class="line">plt.plot(x_train,y_pred,linestyle=<span class="string">'-'</span>,color=<span class="string">'b'</span>,label=<span class="string">'Linear regression line'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2017/10/10/Tensorflow/pic1.png" alt="1"></p><p>再构造一些测试数据，用学习到的模型进行预测<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.定义测试数据</span></span><br><span class="line">X_test = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line"><span class="comment"># 2.定义相关参数</span></span><br><span class="line">w = sess.run(w)</span><br><span class="line">b = sess.run(b)</span><br><span class="line"><span class="comment"># 3.定义预测</span></span><br><span class="line">predict = tf.multiply(w,X_test)+b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.得到预测结果</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line">test_pred = sess.run(predict,&#123;X_test:x_test&#125;)</span><br><span class="line">print(test_pred)</span><br></pre></td></tr></table></figure></p><p>绘制测试集上的回归函数图像：<br><img src="/2017/10/10/Tensorflow/pic2.png" alt="2"><br>可以看到拟合的效果还是不错的。</p><p>这是<a href="http://blog.csdn.net/freedom098/article/details/52106931" target="_blank" rel="noopener">freedom098博客</a>上的一点关于梯度下降的一点儿感悟：<br><strong>1、</strong>梯度下降法分为批量梯度下降和随机梯度下降法，第一种是所有数据都参与运算后，计算误差函数，根据此误差函数来更新模型参数，实际调试发现，如果定义误差函数为平方误差函数，这个值很快就会飞掉，原因是，批量平方误差都加起来可能会很大，如果此时学习率比较高，那么调整就会过，造成模型参数向一个方向大幅调整，造成最终结果发散。所以这个时候要降低学习率，让参数变化不要太快。<br><strong>2、</strong>随机梯度下降法，每次用一个数据计算误差函数，然后更新模型参数，这个方法有可能会造成结果出现震荡，而且麻烦的是由于要一个个取出数据参与运算，而不是像批量计算那样采用了广播或者向量化乘法的机制，收敛会慢一些。但是速度要比使用批量梯度下降要快，原因是不需要每次计算全部数据的梯度了。比较折中的办法是mini-batch，也就是每次选用一小部分数据做梯度下降，目前这也是最为常用的方法了。<br><strong>3、</strong>epoch概念：所有样本集过完一轮，就是一个epoch，很明显，如果是严格的随机梯度下降法，一个epoch内更新了样本个数这么多次参数，而批量法只更新了一次。</p><hr><h1 id="tf-multiply和tf-matmul区别"><a href="#tf-multiply和tf-matmul区别" class="headerlink" title="tf.multiply和tf.matmul区别"></a>tf.multiply和tf.matmul区别</h1><p>其中tf.multiply是点乘，tf.matmul是矩阵乘法，点乘要求维度相同，结果是每个对应的元素相乘，矩阵乘法要求MxN NxK,最后得到MxK<br>举个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">B = np.array([[<span class="number">5</span>],[<span class="number">2</span>],[<span class="number">1</span>]])</span><br><span class="line">C = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">-2</span>,<span class="number">0</span>]])</span><br><span class="line">print(<span class="string">'矩阵A'</span>)</span><br><span class="line">print(A)</span><br><span class="line">print(<span class="string">'矩阵B'</span>)</span><br><span class="line">print(B)</span><br><span class="line">print(<span class="string">'矩阵A乘以B'</span>)</span><br><span class="line">print(np.matmul(A,B))</span><br><span class="line">print(<span class="string">'矩阵A点乘C'</span>)</span><br><span class="line">print(np.multiply(A,C))</span><br></pre></td></tr></table></figure></p><p>Output<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">矩阵A</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">矩阵B</span><br><span class="line">[[<span class="number">5</span>]</span><br><span class="line"> [<span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span>]]</span><br><span class="line">矩阵A乘以B</span><br><span class="line">[[<span class="number">12</span>]</span><br><span class="line"> [<span class="number">36</span>]]</span><br><span class="line">矩阵A点乘C</span><br><span class="line">[[  <span class="number">1</span>   <span class="number">0</span>  <span class="number">-3</span>]</span><br><span class="line"> [  <span class="number">8</span> <span class="number">-10</span>   <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="np-dot"><a href="#np-dot" class="headerlink" title="np.dot"></a>np.dot</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">          [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">          [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">          [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]])</span><br><span class="line">B = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]])</span><br><span class="line">C = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]])</span><br><span class="line">D = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">E = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 当x,y都为一维数组的时候，np.dot表示内积</span></span><br><span class="line">print(np.dot(D,E))</span><br><span class="line"><span class="comment">#print(np.dot(np.mat(B).T,np.mat(C).T))</span></span><br><span class="line"><span class="comment"># 除此之外，表示矩阵乘积</span></span><br><span class="line">print(np.dot(A,C))</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span></span><br><span class="line"></span><br><span class="line">[[ <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">70</span>]</span><br><span class="line"> [<span class="number">110</span>]</span><br><span class="line"> [<span class="number">150</span>]]</span><br></pre></td></tr></table></figure></p><hr><h1 id="手动实现Logistic"><a href="#手动实现Logistic" class="headerlink" title="手动实现Logistic"></a>手动实现Logistic</h1><p><a href="http://blog.csdn.net/zjsghww/article/details/55211530" target="_blank" rel="noopener">参考链接1</a><br>下面两个图可以看到线性回归和逻辑回归的联系，因为逻辑回归的假设函数的输出是0到1之间的概率，相当于把线性回归的假设函数归一化<br><img src="http://img.blog.csdn.net/20170421120330053?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3lhbmd6aGl6aG91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic1"><br>那现在有一个线性回归模型$ z = \theta^Tx $,要将输出转为y(0,1)，那么就需要将z转为y，如果用单位阶跃函数来表示:<br><img src="/2017/10/10/Tensorflow/gs_0.png" alt=""><br>由于其不连续，所以用sigmoid函数代替：<br>$ y = \frac{1}{1+e^{-z}} $<br>则其输出为（假设函数）:<br>$ y = \frac{1}{1+e^{-(\theta^Tx)}} $<br>其函数图像为：<br><img src="http://img.blog.csdn.net/20170215164754943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempzZ2h3dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic1"><br>如果将假设函数进行变形，将theta向量与X矩阵相乘拿出来的话，可以得到：<br><img src="/2017/10/10/Tensorflow/gs1.png" alt="Markdown"><br>那这也就是对数几率回归，y看成是样本x正例的概率，1-y则为样本x负例的概率，这里将条件概率模型转化为了线性模型:<br><img src="/2017/10/10/Tensorflow/gs2.png" alt="Markdown"><br>那么接下来要求<strong>样本点的联合概率分布</strong>，对于每一个样本点来说:<br><img src="/2017/10/10/Tensorflow/gs3.png" alt="Markdown"><br>那考虑所有样本，由于每个样本点互相独立，因此他们的联合概率分布等于各自的边缘概率分布的积：<br><img src="/2017/10/10/Tensorflow/gs4.png" alt="Markdown"><br>其对数似然函数为：<br><img src="/2017/10/10/Tensorflow/gs5.png" alt="Markdown"><br>现在需要使得联合概率分布最大，或者说使得其对数似然函数最大，需要使用梯度下降法来求θ(其损失函数可以说是-1/m * 对数似然函数（联合概率分布）)<br>给出其损失函数<img src="/2017/10/10/Tensorflow/gs6.png" alt="Markdown">并给出从损失函数到偏导的推导:<br><img src="http://img.blog.csdn.net/20170215174429487?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempzZ2h3dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic3"></p><p><strong>下面给出其python实现过程：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">x_train = [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">2.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">3.0</span>, <span class="number">5.0</span>], [<span class="number">1.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">2.0</span>], [<span class="number">7.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">11.0</span>, <span class="number">3.0</span>],</span><br><span class="line">           [<span class="number">8.0</span>, <span class="number">7.0</span>]]</span><br><span class="line">y_train = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">good_index = []</span><br><span class="line">bad_index = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_train)):</span><br><span class="line">    <span class="keyword">if</span> y_train[i]==<span class="number">1</span>:</span><br><span class="line">        good_index.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bad_index.append(i)</span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">plt.scatter(np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[good_index],np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[good_index],marker=<span class="string">'o'</span>,color=<span class="string">'k'</span>,label=<span class="string">'good'</span>)</span><br><span class="line">plt.scatter(np.array([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[bad_index],np.array([x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> x_train])[bad_index],marker=<span class="string">'x'</span>,color=<span class="string">'g'</span>,label=<span class="string">'bad'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="http://i1.bvimg.com/620746/8fb6d8adb6285060s.png" alt="pic"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化变量 由于这里是两维特征 h(θ) = θ0*x0 + θ1*x1 + θ2*x2</span></span><br><span class="line"><span class="comment"># 为了构造矩阵相乘，给数据集X添加一列1</span></span><br><span class="line">init_theta = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">X = np.array([[<span class="number">1.0</span>]+x <span class="keyword">for</span> x <span class="keyword">in</span> x_train])</span><br><span class="line">y = np.array(y_train)</span><br><span class="line"><span class="comment"># 构造假设函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Objective</span><span class="params">(theta,X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-np.dot(theta.reshape(<span class="number">1</span>,<span class="number">3</span>),X.T)))</span><br><span class="line"><span class="comment"># 构造损失函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(theta,X,y)</span>:</span></span><br><span class="line">    pred_y = Objective(theta,X)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 在当前theta下训练集的损失函数值,求原来损失函数的最大，在这里取负号就是最小</span></span><br><span class="line">    lossSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">        lossSum += -y[i]*pred_y[i] + np.log(<span class="number">1</span>+np.exp(pred_y[i]))</span><br><span class="line">    <span class="keyword">return</span> lossSum/X.shape[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">'在初始theta的情况下，训练集的损失函数值为:'</span>,loss(init_theta,X,y))</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在初始theta的情况下，训练集的损失函数值为: <span class="number">0.71354969579</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化损失函数</span></span><br><span class="line"><span class="comment"># 为了寻找最优的theta向量使得损失函数最小，这里使用梯度下降法</span></span><br><span class="line"><span class="comment"># 计算当前梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gradient</span><span class="params">(theta,X,y)</span>:</span></span><br><span class="line">    grad = []</span><br><span class="line">    pred_y = Objective(theta,X)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>]):</span><br><span class="line">        cur_grad = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前梯度跟每一个样本实例都有关系</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">            cur_grad += (pred_y[j]-y[j]) * X[j][i]</span><br><span class="line">        grad.append(cur_grad/X.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> np.array(grad)</span><br><span class="line">print(<span class="string">'初始梯度'</span>,Gradient(init_theta,X,y))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始梯度 [ <span class="number">0.39880029</span>  <span class="number">2.39851299</span>  <span class="number">1.09756494</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用梯度下降找到最优参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic</span><span class="params">(theta,X,y,eta)</span>:</span></span><br><span class="line">    loss_list = []</span><br><span class="line">    minLoss = <span class="number">1000</span></span><br><span class="line">    minTheta = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 定义迭代次数</span></span><br><span class="line">    theLoss = <span class="number">0</span></span><br><span class="line">    iteration_times = <span class="number">5000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration_times):</span><br><span class="line">        <span class="comment"># 每一轮迭代更新损失theta向量和损失函数值</span></span><br><span class="line">        theta = theta - eta * Gradient(theta,X,y)</span><br><span class="line">        theLoss = loss(theta,X,y)</span><br><span class="line">        <span class="keyword">if</span> theLoss &lt; minLoss:</span><br><span class="line">            minLoss = theLoss</span><br><span class="line">            minTheta = theta</span><br><span class="line">        loss_list.append(theLoss)</span><br><span class="line">    <span class="keyword">return</span> loss_list,minLoss,minTheta</span><br><span class="line">loss_list,minLoss,minTheta = logistic(init_theta,X,y,<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># 画出收敛曲线的图</span></span><br><span class="line">axis_x = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(len(loss_list))]</span><br><span class="line">plt.xlabel(<span class="string">'iteration times'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss function value'</span>)</span><br><span class="line">plt.plot(axis_x,loss_list,linestyle=<span class="string">'-'</span>,color=<span class="string">'b'</span>,label=<span class="string">'Convergent curve'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://i1.bvimg.com/620746/6bbfdf02e262ce31s.png" alt="pic"></p><hr><h1 id="交叉熵Corss-entropy和Softmax"><a href="#交叉熵Corss-entropy和Softmax" class="headerlink" title="交叉熵Corss-entropy和Softmax"></a>交叉熵Corss-entropy和Softmax</h1><h2 id="交叉熵Cross-entropy"><a href="#交叉熵Cross-entropy" class="headerlink" title="交叉熵Cross-entropy"></a>交叉熵Cross-entropy</h2><p><a href="https://www.zhihu.com/question/65288314/answer/230209104" target="_blank" rel="noopener">参考链接</a><br><img src="http://i1.bvimg.com/620746/fcd91367dd3490e5s.png" alt="Markdown"><br><img src="http://i1.bvimg.com/620746/6f3c163bcd3a6e43s.png" alt="Markdown"><br><img src="http://i1.bvimg.com/620746/0d58162dce573c0cs.png" alt="Markdown"></p><h2 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h2><p><strong>Softmax函数用于多分类或二分类，可以对样本输出的每一个类别给出对应的概率值</strong><br>这里的softmax可以看成是一个激励（activation）函数或者链接（link）函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10个数字类的概率分布。因此，给定一张图片，它对于每一个数字的吻合度可以被softmax函数转换成为一个概率值<br><img src="http://i1.bvimg.com/620746/e922629c244061a5s.png" alt="Markdown"><br><img src="http://i1.bvimg.com/620746/e1c695434044cc9es.png" alt="Markdown"></p><hr><h1 id="Logistic回归：MINIST训练集"><a href="#Logistic回归：MINIST训练集" class="headerlink" title="Logistic回归：MINIST训练集"></a>Logistic回归：MINIST训练集</h1><p>MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片：<br><img src="http://wiki.jikexueyuan.com/project/tensorflow-zh/images/MNIST.png" alt="11"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line">MNIST = input_data.read_data_sets(<span class="string">"data"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义相关超参</span></span><br><span class="line">eta = <span class="number">0.01</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">n_epochs = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为输入和输出定义placeholder</span></span><br><span class="line"><span class="comment"># 因为每个在MNIST中的像素是28*28 = 784</span></span><br><span class="line"><span class="comment"># 所以每一个图像都有784个特征，是一个1x784的张量</span></span><br><span class="line">X = tf.placeholder(<span class="string">'float32'</span>,[batch_size,<span class="number">784</span>])</span><br><span class="line">y = tf.placeholder(<span class="string">'float32'</span>,[batch_size,<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建要调整的参数变量 weights and bias</span></span><br><span class="line"><span class="comment"># 784，10 是因为要输出一个长度为10的结果向量</span></span><br><span class="line">w = tf.Variable(tf.random_normal(shape=[<span class="number">784</span>,<span class="number">10</span>],stddev=<span class="number">0.1</span>), name=<span class="string">'weights'</span>)</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>,<span class="number">10</span>]), name=<span class="string">'bias'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义假设函数</span></span><br><span class="line">logits = tf.matmul(X,w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">entropy = tf.nn.softmax_cross_entropy_with_logits(logits=logits,labels=y)</span><br><span class="line">loss = tf.reduce_mean(entropy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=eta).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里batch_size是每一次训练多少个样本，这里要算每一轮要训练多少次</span></span><br><span class="line">n_batches = int(MNIST.train.num_examples/batch_size)</span><br><span class="line"><span class="comment"># 训练多少轮</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_batches):</span><br><span class="line">        <span class="comment"># 该循环的每个步骤中，我们都会随机抓取训练数据中的batch_size个批处理数据点，然后我们用这些数据点作为参数替换之前的占位符来运行train_step</span></span><br><span class="line">        X_batch,Y_batch = MNIST.train.next_batch(batch_size)</span><br><span class="line">        sess.run([optimizer,loss],&#123;X:X_batch,y:Y_batch&#125;)</span><br><span class="line"><span class="comment"># 测试模型</span></span><br><span class="line">corrects = <span class="number">0</span></span><br><span class="line">n_batches = int(MNIST.test.num_examples/batch_size)</span><br><span class="line">total_correct_preds = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_batches):</span><br><span class="line">    X_batch, Y_batch = MNIST.test.next_batch(batch_size)</span><br><span class="line">    _,loss_batch,logits_batch = sess.run([optimizer,loss,logits],feed_dict=&#123;X:X_batch,y:Y_batch&#125;)</span><br><span class="line">    preds = tf.nn.softmax(logits_batch)</span><br><span class="line">    corrects_preds = tf.equal(tf.argmax(preds,<span class="number">1</span>),tf.argmax(Y_batch,<span class="number">1</span>))</span><br><span class="line">    accuracy = tf.reduce_sum(tf.cast(corrects_preds,tf.float32))</span><br><span class="line">    total_correct_preds += sess.run(accuracy)</span><br><span class="line">print(<span class="string">'Accuracy'</span>,total_correct_preds/MNIST.test.num_examples)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Accuracy <span class="number">0.9077</span></span><br></pre></td></tr></table></figure><hr><h1 id="决策树作业"><a href="#决策树作业" class="headerlink" title="决策树作业"></a>决策树作业</h1><p>$$0.0902763493928-\frac{8}{14}<em>-\frac{4}{8}</em>log2\frac{4}{8}-\frac{6}{14}<em>-\frac{1}{6}</em>log2\frac{1}{6}=0.0902763493928$$</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;目前只有一点儿，课程所需，实习后补充&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
