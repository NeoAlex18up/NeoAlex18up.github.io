<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨一瓶</title>
  
  <subtitle>非常に広い肩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-10T12:39:50.499Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yangyiqing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流畅的python</title>
    <link href="http://yoursite.com/2017/12/14/python/"/>
    <id>http://yoursite.com/2017/12/14/python/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2018-01-10T12:39:50.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-math库"><a href="#python-math库" class="headerlink" title="python math库"></a>python math库</h1><h2 id="Number-theoretic-and-representation-functions"><a href="#Number-theoretic-and-representation-functions" class="headerlink" title="Number-theoretic and representation functions"></a>Number-theoretic and representation functions</h2><ul><li><strong>math.ceil(x)</strong> 上限，返回大于或等于x的最小整数</li><li><strong>math.copysign(x,y)</strong> 赋值符号,返回x的绝对值，使用y的符号,返回类型为float</li><li><strong>math.fabs(x)</strong> 返回x的绝对值</li><li><strong>math.factorial(x)</strong> 返回x的阶乘，如果x为非正整数会报错</li><li><strong>math.floor(x)</strong> 下限，小于或等于x的最大整数 </li><li><strong>math.fmod(x,y)</strong> 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号）</li><li><strong>math.frexp(x)</strong> 返回一个元组(m,n),根据x = m<em>(2*</em>n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了）</li><li><strong>math.fsum(iterable)</strong> 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999</li><li><strong>math.gcd(a,b)</strong> 返回最大公约数,a,b必须为整数</li><li><strong>math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0)</strong> 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.18</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">11.3</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True</p><ul><li><strong>math.isfinite(x)</strong> 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number)</li><li><p><strong>math.isinf(x)</strong> 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正无穷</span></span><br><span class="line">float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="comment"># 负无穷</span></span><br><span class="line">float(<span class="string">'-inf'</span>)</span><br><span class="line">-float(<span class="string">'inf'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>math.isnan(x)</strong> 判断是否是NAN（not a number）</p></li><li><strong>math.ldexp(x,i)</strong> 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数</li><li><strong>math.modf(x)</strong> 分别返回x的小数部分和整数部分，同时带x的符号，例如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.modf(<span class="number">-1.89</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出(-0.8899999999999999, -1.0)</p><ul><li><strong>math.trunc(x)</strong> 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数<h2 id="Power-and-logarithmic-functions"><a href="#Power-and-logarithmic-functions" class="headerlink" title="Power and logarithmic functions"></a>Power and logarithmic functions</h2></li><li><strong>math.exp(x)</strong> 返回e的x方</li><li><strong>math.expm1(x)</strong> 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确</li><li><strong>math.log(x[,base])</strong> 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base),</li><li><strong>math.log1p(x)</strong> 返回值为 log(1+x)/log(e)</li><li><strong>math.log2(x)</strong> 返回值为log(x)/log2,用来代替log(x,2),因为更加精确</li><li><strong>math.log10(x)</strong> 同理，返回log(x)/log(10)</li><li><strong>math.pow(x,y)</strong> 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan</li><li><strong>math.sqrt(x)</strong> 返回x的平方根<h2 id="Trigonometric-functions"><a href="#Trigonometric-functions" class="headerlink" title="Trigonometric functions"></a>Trigonometric functions</h2><strong>三角函数</strong></li><li><strong>math.acos(x)</strong> 返回x的反余弦 arc cosine，把斜率转换成弧度</li><li><strong>math.asin(x)</strong> 返回x的反正弦 arc sine</li><li><strong>math.atan(x)</strong> 返回x的反正切 arc tangent</li><li><strong>math.atan2(y,x)</strong> 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标</li><li><strong>math.cos(x)</strong> 返回x的余弦,角度值转为余弦值,cos(0)=1.0</li><li><strong>math.sin(x)</strong> 返回x的正弦</li><li><strong>math.tan(x)</strong> 返回x的正切</li><li><strong>math.hypot(x,y)</strong> 返回欧几里得范数 sqrt(x<em>x + y</em>y) ,也就是点(x,y)到原点的距离</li><li><strong>math.degrees(x)</strong> 把角度x转为弧度，角度=（弧度/π）*180</li><li><strong>math.radians(x)</strong> 把弧度x转为角度，弧度= (角度/180)*π<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2></li><li><strong>math.lgamma(x)</strong> 返回伽马函数绝对值在x上的自然对数。</li></ul><hr><h1 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h1><p>pyhton 中的 filter函数接收一个函数f和一个序列(<strong>python中的序列有：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象，列表和元组的区别主要是：列表可以修改，元组不能</strong>)，函数f的作用是对列表中的每一个元素进行条件判断，返回True或False，filter函数最终返回一个迭代器Iterator(在python 2.x中返回一个list)<br>举例：返回1-1000中的所有奇数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x%<span class="number">2</span>!=<span class="number">0</span></span><br><span class="line"><span class="comment"># in python 3.x</span></span><br><span class="line">print(list(filter(is_odd,range(<span class="number">1</span>,<span class="number">1001</span>))))</span><br><span class="line"><span class="comment"># in python 2.x</span></span><br><span class="line"><span class="keyword">print</span> filter(is_odd,range(<span class="number">1</span>,<span class="number">1001</span>))</span><br></pre></td></tr></table></figure></p><p>字符串遍历筛选的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x==<span class="string">'a'</span></span><br><span class="line">print(list(filter(is_a,<span class="string">'HaHaHaHa'</span>)))</span><br><span class="line">Output:</span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure></p><p>例如：删除None和空字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cal_str</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip())&gt;<span class="number">0</span></span><br><span class="line">filter(Cal_str,[<span class="string">"H"</span>,<span class="keyword">None</span>,<span class="string">""</span>,<span class="string">"ello"</span>])</span><br><span class="line">Output: <span class="string">"[H"</span>,<span class="string">"ello"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h2><p><strong> strip(rm)</strong> 默认删除s字符串中开头、结尾处的rm字符串，当rm为空的时候，默认删除空白（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)</p><ul><li>s.strip(rm)        删除s字符串中开头、结尾处，位于 rm删除序列的字符</li><li>s.lstrip(rm)       删除s字符串中开头处，位于 rm删除序列的字符</li><li>s.rstrip(rm)      删除s字符串中结尾处，位于 rm删除序列的字符<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'Hello world'</span></span><br><span class="line">print(a.strip(<span class="string">'He'</span>))</span><br><span class="line">print(a.strip(<span class="string">'eH'</span>))</span><br><span class="line">print(a.strip(<span class="string">'el'</span>))</span><br><span class="line">Output:</span><br><span class="line">llo world</span><br><span class="line">llo world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></li></ul><p>由于Python3.x中的filter返回的是一个Iterator，所以不仅仅可以指定为list，也可以set(filter(…))</p><hr><h1 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h1><p>python 中的 map函数接收一个函数f和一个序列，f将作用于序列中的每个元素，最终的结果作为Interator返回</p><p>如果使用map来实现filter中的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="string">'a'</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">print(list(map(is_a,<span class="string">"Hahahah"</span>)))</span><br><span class="line">Output:</span><br><span class="line">[<span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure></p><p><strong>map最终返回的序列长度是等于原来的序列长度的，filter返回的序列长度是小于等于原来的长度的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lambda函数的例子</span></span><br><span class="line">print(list(map(<span class="keyword">lambda</span> x:x+<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p><strong>注意！</strong> 当只有一个序列的时候，map和filter都是可以使用的，但是当处理多个序列的时候，只能使用map<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(list(map(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">14</span>]</span><br><span class="line"><span class="comment"># 相当于zip,然后将zip的结果传给函数,所以map在处理多个序列的时候，无法操作序列长度不一致，对应值类型不同的情况</span></span><br><span class="line"><span class="comment"># 例如[1,4,6],[2,5,6,8]或[1,4,6],['a',3,6]</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h1><p><strong>注意</strong> 在python3中，reduce已经从内置函数中被抛弃了，要使用就要引入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure></p><p>reduce函数是一个累积运算的过程，其接收一个函数f(x,y)和一个序列（以及一个可选的初始值）,其中函数f的x,y首先代表序列中的第一个和第二个参数，其返回值作为新的x，第三个参数作为新的y，依次运算至结束。<br>例如求和运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">print(list(reduce(f,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])))</span><br><span class="line">Process:</span><br><span class="line">先计算头两个元素：f(<span class="number">1</span>, <span class="number">3</span>)，结果为<span class="number">4</span>；</span><br><span class="line">再把结果和第<span class="number">3</span>个元素计算：f(<span class="number">4</span>, <span class="number">5</span>)，结果为<span class="number">9</span>；</span><br><span class="line">再把结果和第<span class="number">4</span>个元素计算：f(<span class="number">9</span>, <span class="number">7</span>)，结果为<span class="number">16</span>；</span><br><span class="line">再把结果和第<span class="number">5</span>个元素计算：f(<span class="number">16</span>, <span class="number">9</span>)，结果为<span class="number">25</span>；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果<span class="number">25</span></span><br></pre></td></tr></table></figure></p><p>如果设置了初始值为100，那么第一次运算就是f(100,1)</p><p>再例如，用reduce实现5的阶乘:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">6</span>)))</span><br><span class="line">Output:</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>只举了两个简单的例子，通过函数可以实现更为复杂的操作</p><hr><h1 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h1><p>lambda作为一个表达式，定义了一个匿名函数<br>定义一个lambda表达式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line"><span class="comment"># 可以这样理解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>lambda 常常配合上述的 reduce , map, filter 作为f来使用，可以使得代码大大简化。<br><strong>但是python中的 for..in..if 已经非常强大</strong>，lambda并不一定作为首选<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意是[]</span></span><br><span class="line"><span class="keyword">print</span> ([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>总之：ambda 并不会带来程序运行效率的提高，只会使代码更简洁。<strong>lambda是为了减少单行函数而存在的</strong></p><hr><h1 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h1><p>python的set和其他语言类似，是一个是一个无序不重复元素集, 基本功能包括<strong>关系测试和消除重复元素.</strong> 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.作为一个无序的集合，<strong>sets不记录元素位置或者插入点</strong>。因此，<strong>sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作</strong>。<br><strong> 初始化 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s0 = set()</span><br><span class="line">s1 = set(<span class="string">'HelloWorld'</span>)</span><br><span class="line">s2 = set([<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>])</span><br><span class="line">s3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 注意，没有这种操作 set(1,2,3)</span></span><br></pre></td></tr></table></figure></p><p><strong>简单例子：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = set(<span class="string">'spam'</span>)  </span><br><span class="line">y = set([<span class="string">'h'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>])  </span><br><span class="line">x,y</span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line">(set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'m'</span>]), set([<span class="string">'a'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>]))</span><br></pre></td></tr></table></figure></p><p><strong>去除list l 中重复元素的例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">55</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> set(l)])</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure></p><p><strong>两个集合的数学运算</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）  </span></span><br><span class="line">d = t ^ s          <span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）  </span></span><br><span class="line"><span class="comment"># 当然，也可以麻烦点写成函数的形式</span></span><br><span class="line">print(s.intersection(t), s &amp; t)  <span class="comment"># 交集</span></span><br><span class="line">print(s.union(t), s | t)   <span class="comment"># 并集 </span></span><br><span class="line">print(s.difference(t), s - t)  <span class="comment"># 差集 </span></span><br><span class="line">print(s.symmetric_difference(t), s ^ t) <span class="comment"># 对称差集 </span></span><br><span class="line">print(s1.issubset(s2), s1 &lt;= s2) <span class="comment"># 子集</span></span><br><span class="line">print(s1.issuperset(s2), s1 &gt;= s2)      <span class="comment"># 包含</span></span><br></pre></td></tr></table></figure></p><p><strong> 基本方法 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">len(s)  <span class="comment"># 获取集合中的元素的总数</span></span><br><span class="line">s.update([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># 添加多个元素</span></span><br><span class="line">s.add(<span class="string">"x"</span>)         <span class="comment"># 添加一个元素</span></span><br><span class="line">s.remove(<span class="string">"x"</span>)      <span class="comment"># 去掉一个元素</span></span><br><span class="line">s.discard(<span class="string">"x"</span>)     <span class="comment"># 如果集合存在指定元素，则删除该元素</span></span><br><span class="line">c = s.copy()       <span class="comment"># 复制集合</span></span><br><span class="line">s.pop() <span class="comment"># 弹出集合中的一个不确定元素(好像不是等价随机)</span></span><br><span class="line">s.clear()          <span class="comment"># 删除集合中所有的元素(改变原集合)</span></span><br><span class="line">x <span class="keyword">in</span> s  <span class="comment">#测试 x 是否是 s 的成员  </span></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></p><p><strong>参考链接</strong><br><a href="http://www.jb51.net/article/60480.htm" target="_blank" rel="noopener">链接1</a><br><a href="http://blog.csdn.net/business122/article/details/7541486" target="_blank" rel="noopener">链接2</a></p><hr><h1 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace 函数"></a>replace 函数</h1><p><strong>replace()方法语法：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(old, new[, max])</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>old – 将被替换的子字符串。</li><li>new – 新字符串，用于替换old子字符串。</li><li>max – 可选字符串, 替换不超过 max 次</li></ul><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"this is string example....wow!!! this is really string"</span>;</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>);</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas <span class="keyword">is</span> really string</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)人生苦短，我用python&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2017/12/13/leetcode/"/>
    <id>http://yoursite.com/2017/12/13/leetcode/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2018-01-28T10:39:48.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-Two-sum"><a href="#Array-Two-sum" class="headerlink" title="(Array)Two sum"></a>(Array)Two sum</h1><p>**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.**</p><p>Example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p><p>给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解）</p><p>Sample solution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    buff_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> buff_dict:</span><br><span class="line">            <span class="keyword">return</span> [buff_dict[nums[i]], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buff_dict[target - nums[i]] = i</span><br></pre></td></tr></table></figure></p><p><strong>思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index]</strong></p><hr><h1 id="Array-Reverse-Integer"><a href="#Array-Reverse-Integer" class="headerlink" title="(Array)Reverse Integer"></a>(Array)Reverse Integer</h1><p>Q:Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output:  <span class="number">-321</span></span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output:  <span class="number">21</span></span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>My Answer:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(str(nums))&gt;<span class="number">0</span> <span class="keyword">and</span> nums != <span class="number">0</span> <span class="keyword">and</span> nums &lt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">            nums = str(nums)</span><br><span class="line">            newStr = <span class="string">''</span></span><br><span class="line">            <span class="comment"># len(nums)-1 to -1 , -1 not included , interval is -1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                newStr = newStr + nums[i]</span><br><span class="line">            print(newStr)</span><br><span class="line">            <span class="keyword">while</span> newStr[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                newStr= newStr[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> newStr[<span class="number">-1</span>]==<span class="string">'-'</span>:</span><br><span class="line">                newStr=<span class="string">'-'</span>+newStr[:len(newStr)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> math.fabs(int(newStr)) &gt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span>(int(newStr))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：主要注意几点</strong><br>1.32位有符号整数范围判断<br>2.逆序以后0的处理<br>3.切片时注意索引是否会超范围，也就是只输入0的情况<br>4.对于是否为负的处理</p><hr><h1 id="Array-Palindrome-Number"><a href="#Array-Palindrome-Number" class="headerlink" title="(Array)Palindrome Number"></a>(Array)Palindrome Number</h1><p><strong>判断是否是回文数字</strong><br><strong>注意</strong><br>1.负数不为回文数<br>2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性</p><p>Mysolution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> nums&lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> math.pow(<span class="number">10</span>,length) &lt;= nums:</span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(math.ceil(length/<span class="number">2</span>)):</span><br><span class="line">                status = math.isclose((math.floor(nums/math.pow(<span class="number">10</span>,i))%<span class="number">10</span>),(math.floor(nums/math.pow(<span class="number">10</span>,length-i<span class="number">-1</span>))%<span class="number">10</span>),abs_tol = <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="keyword">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p><strong>Hint:</strong> 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。</p><hr><h1 id="Array-Non-decreasing-Array"><a href="#Array-Non-decreasing-Array" class="headerlink" title="(Array)Non-decreasing Array"></a>(Array)Non-decreasing Array</h1><p><strong>非下降数组</strong><br><strong>Q:</strong>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<strong></strong>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could modify the first </span><br><span class="line"><span class="number">4</span></span><br><span class="line"> to </span><br><span class="line"><span class="number">1</span></span><br><span class="line"> to get a non-decreasing array.</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">False</span></span><br><span class="line">Explanation: You can<span class="string">'t get a non-decreasing array by modify at most one element.</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>:The n belongs to [1, 10,000].</p><p><strong>题意:</strong>给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。</p><p> <strong>Mysolution:</strong><br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">       num1 = nums.copy()</span><br><span class="line">       num2 = nums.copy()</span><br><span class="line">       <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">           <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">               num1[i] = num1[i+<span class="number">1</span>]</span><br><span class="line">               num2[i+<span class="number">1</span>] = num2[i]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">return</span> num1==sorted(num1) <span class="keyword">or</span> num2==sorted(num2)</span><br></pre></td></tr></table></figure></p><p><strong>借鉴了Discuss里 -Yangshun的思路:</strong>First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting.</p><hr><h1 id="Array-k-diff-Pairs-in-an-Array"><a href="#Array-k-diff-Pairs-in-an-Array" class="headerlink" title="(Array)k-diff Pairs in an Array"></a>(Array)k-diff Pairs in an Array</h1><p><strong>Q:</strong>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.<br><strong>Example 1:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: There are two <span class="number">2</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">and</span> (<span class="number">3</span>, <span class="number">5</span>).</span><br><span class="line">Although we have two <span class="number">1</span>s <span class="keyword">in</span> the input, we should only <span class="keyword">return</span> the number of unique pairs.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], k = <span class="number">1</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: There are four <span class="number">1</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>) <span class="keyword">and</span> (<span class="number">4</span>, <span class="number">5</span>).</span><br></pre></td></tr></table></figure></p><p><strong>Example 3:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], k = <span class="number">0</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> one <span class="number">0</span>-diff pair <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">1</span>).</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong><br>1.(1,3),(3,1)属于同一个数值对<br>2.k为负的时候返回0<br>3.注意处理k=0的情况<br>4.不要使用循环嵌套，必超时<br><strong> Mysolution </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 精简版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums))))</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">        <span class="keyword">return</span> len(set(sorted(nums)) &amp; set(map(<span class="keyword">lambda</span> x:x+k,nums)))</span><br></pre></td></tr></table></figure></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样写会好理解一些</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">           <span class="comment">#nums = list(filter(lambda x:nums.count(x)&gt;1,nums))</span></span><br><span class="line">           <span class="comment">#return len(set(nums))</span></span><br><span class="line">       nums = set(sorted(nums))</span><br><span class="line">       nums1 = set(map(<span class="keyword">lambda</span> x:x+k,nums))</span><br><span class="line">       <span class="keyword">return</span> len(nums &amp; nums1)</span><br></pre></td></tr></table></figure><p>思路：将数组中每个数+k后与原数组取交集</p><hr><h1 id="Hash-Table-Count-Primes"><a href="#Hash-Table-Count-Primes" class="headerlink" title="(Hash Table)Count Primes"></a>(Hash Table)Count Primes</h1><p><strong>Description:</strong><br>Count the number of prime numbers less than a non-negative number, <strong>n.</strong><br>计算小于正整数n的素数的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 一个长度为n的，值为True的list</span></span><br><span class="line">    primes = [<span class="keyword">True</span>] * n</span><br><span class="line">    <span class="comment"># 前两位置为False 0和1 都不是素数，最小的素数是2</span></span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数</span></span><br><span class="line">        <span class="comment"># 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了</span></span><br><span class="line">        <span class="keyword">if</span> primes[i]:</span><br><span class="line">            <span class="comment"># 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数</span></span><br><span class="line">            <span class="comment"># 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了</span></span><br><span class="line">            primes[i * i: n: i] = [<span class="keyword">False</span>] * len(primes[i * i: n: i])</span><br><span class="line">    <span class="comment"># 返回剩余的True的个数</span></span><br><span class="line">    <span class="keyword">return</span> sum(primes)</span><br></pre></td></tr></table></figure><p>这个算法实现的是<strong>埃拉托斯特尼筛法</strong>：<br>算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于  的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了）</p><hr><h1 id="Array-Medium-Insert-Delete-GetRandom-O-1"><a href="#Array-Medium-Insert-Delete-GetRandom-O-1" class="headerlink" title="(Array-Medium)Insert Delete GetRandom O(1)"></a>(Array-Medium)Insert Delete GetRandom O(1)</h1><p><strong>Description:</strong><br>Design a data structure that supports all following operations in average O(1) time.<br> 1.insert(val) : Inserts an item val to the set if not already present.<br> 2.remove(val) : Removes an item val from the set if present.<br> 3.getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned.</p><p><strong>Example：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">1</span> to the set. Returns true <span class="keyword">as</span> <span class="number">1</span> was inserted successfully.</span><br><span class="line">randomSet.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// Returns false <span class="keyword">as</span> <span class="number">2</span> does <span class="keyword">not</span> exist <span class="keyword">in</span> the set.</span><br><span class="line">randomSet.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">2</span> to the set, returns true. Set now contains [<span class="number">1</span>,<span class="number">2</span>].</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// getRandom should <span class="keyword">return</span> either <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes <span class="number">1</span> <span class="keyword">from</span> the set, returns true. Set now contains [<span class="number">2</span>].</span><br><span class="line">randomSet.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="number">2</span> was already <span class="keyword">in</span> the set, so <span class="keyword">return</span> false.</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Since <span class="number">2</span> <span class="keyword">is</span> the only number <span class="keyword">in</span> the set, getRandom always <span class="keyword">return</span> <span class="number">2.</span></span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p><p><strong> My Solution*</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Rset,self.Rlist = set(),[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Rset.add(val)</span><br><span class="line">            self.Rlist.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            self.Rset.remove(val)</span><br><span class="line">            self.Rlist.remove(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.Rlist)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素<br>再添加一个discuss里用<strong>字典</strong>和list来实现的代码，更快一些：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums, self.pos = [], &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.pos:</span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            self.pos[val] = len(self.nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.pos:</span><br><span class="line">            idx, last = self.pos[val], self.nums[<span class="number">-1</span>]</span><br><span class="line">            self.nums[idx], self.pos[last] = last, idx</span><br><span class="line">            self.nums.pop(); self.pos.pop(val, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[random.randint(<span class="number">0</span>, len(self.nums) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p><hr><h1 id="Array-medium-4Sum-拓展为Nsum问题"><a href="#Array-medium-4Sum-拓展为Nsum问题" class="headerlink" title="(Array-medium)4Sum(拓展为Nsum问题)"></a>(Array-medium)4Sum(拓展为Nsum问题)</h1><p><strong>Description</strong><br>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br><strong>Note:</strong> The solution set must not contain duplicate quadruplets.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Solution</strong>借鉴discuss的思路，很不错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N,nums,target,result,results)</span>:</span></span><br><span class="line">            <span class="comment"># 特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> N&gt;len(nums) <span class="keyword">or</span> target&gt;N*nums[<span class="number">-1</span>] <span class="keyword">or</span> target&lt;N*nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 高效的2Sum</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                        <span class="comment"># 补充到最终结果</span></span><br><span class="line">                        results.append(result + [nums[l], nums[r]])</span><br><span class="line">                        <span class="comment"># 左指针右移，同时右指针左移，因为已经排好序了，一个值不变另一个值变一定不会得到target</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 解决重复问题</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> r &gt; l <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 注意这里的范围，是到len(nums)-N+1,因为最后N个数为最后一组，无须再进行递归</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 结合sorted可解决重复问题</span></span><br><span class="line">                    <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> (i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]!=nums[i]):</span><br><span class="line">                        <span class="comment"># 递归，将nSum问题降为n-1Sum问题</span></span><br><span class="line">                        Nsum(N<span class="number">-1</span>,nums[i+<span class="number">1</span>:],target-nums[i],result+[nums[i]],results)</span><br><span class="line">        results = []</span><br><span class="line">        Nsum(<span class="number">4</span>,sorted(nums),target,[],results)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：给定一个list和一个target，求所有n个list中的数和为target的不重复组合。本题是4Sum，代码拓展为了nSum问题，主要思路是通过迭代来把问题转换为高效的2Sum问题，即nSum-&gt;n-1Sum-&gt;….-&gt;4Sum-&gt;3Sum-&gt;2Sum,具体细节在代码注释中。</p><hr><h1 id="Hash-Table-Repeated-DNA-Sequences"><a href="#Hash-Table-Repeated-DNA-Sequences" class="headerlink" title="(Hash-Table)Repeated DNA Sequences"></a>(Hash-Table)Repeated DNA Sequences</h1><p><strong>Description</strong>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.<br>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.<br>For example,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given s = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>].</span><br></pre></td></tr></table></figure></p><p>就是求一个字符串里的所有指定长度的重复子字符串。<br><strong>Mysolution</strong><br>class Solution(object):<br>    def findRepeatedDnaSequences(self, s):<br>        “””<br>        :type s: str<br>        :rtype: List[str]<br>        “””<br>        if len(s)<10: return="" []="" results="[]" dnadict="{}" for="" i="" in="" range(len(s)-9):="" if="" s[i:i+10]="" dnadict:="" dnadict[s[i:i+10]]="" +="1" else:="" key,value="" dnadict.items():="" value="">0:<br>                results.append(key)<br>        return results<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**思路** 循环切片判断是否重复，数据结构用的字典，注意的就是range的范围和切片的范围问题。将10替换为N可以变为求一个字符串中长度为N的重复子串。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># Longest Palindromic Substring</span><br><span class="line">经典的最大回文子字符串问题</span><br><span class="line">样例：</span><br><span class="line">``` python</span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></10:></p><p><strong>思路：</strong>从左到右依次把每个字符当做中心，然后依次判断两边的字符是否相等，最后取最大的那个就行了，唯一要注意的一点是连续字符的情况，比如 abccbd,这个时候要把cc整体作为一个字符串，这里用了两个位置变量，left和right，每次判断两边的相同字符之前要确定right的值，也就是相同字符的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            right = <span class="number">1</span></span><br><span class="line">            left = <span class="number">1</span></span><br><span class="line">            <span class="comment"># get the step length</span></span><br><span class="line">            <span class="keyword">while</span> i + right &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i + right] == s[i]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ((i -left ) &gt;= <span class="number">0</span> <span class="keyword">and</span> (i + right) &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i - left] == s[i + right]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            longest = s[i - left+<span class="number">1</span>:i + right]</span><br><span class="line">            <span class="keyword">if</span> len(longest) &gt; len(result):</span><br><span class="line">                result = longest</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h1 id="链表-Add-Two-Numbers"><a href="#链表-Add-Two-Numbers" class="headerlink" title="(链表)Add Two Numbers"></a>(链表)Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></p><p><strong>思路:</strong>就是由两个链表逆序表示的整数的和，没什么思路可言，这里主要考察的是对链表的操作，具体看代码，讲的很通俗易懂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s1 = str(l1.val)</span><br><span class="line">        s2 = str(l2.val)</span><br><span class="line">        <span class="keyword">while</span> l1.next:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            s1 = str(l1.val)+s1</span><br><span class="line">        <span class="keyword">while</span> l2.next:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            s2 = str(l2.val)+s2</span><br><span class="line">        result = str(int(s1)+int(s2))</span><br><span class="line">        <span class="comment"># 头节点</span></span><br><span class="line">        head = ListNode(int(result[<span class="number">-1</span>]))</span><br><span class="line">        after = head</span><br><span class="line">        <span class="comment"># 这里是对数组的操作，[-2::-1]表示从倒数第二个元素向后-1的取全部，注意这里[-2:0:-1]和[-2::-1]是不同的，前者取到下标为1，因为:左右就是[)的，后者取到数组头</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> result[<span class="number">-2</span>::<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># 新开辟一块内存空间</span></span><br><span class="line">            node = ListNode(int(c))</span><br><span class="line">            <span class="comment"># 让after.next指向这个内存空间，相当于把两个节点连接起来</span></span><br><span class="line">            after.next = node</span><br><span class="line">            <span class="comment"># after指向这块内存空间，方便下一个节点建立以后after代表这块内存空间去实行指向下一块新的节点的任务</span></span><br><span class="line">            after = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h1 id="字符串-最大字符不重复子串问题-Longest-Substring-Without-Repeating-Characters"><a href="#字符串-最大字符不重复子串问题-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="(字符串)最大字符不重复子串问题 Longest Substring Without Repeating Characters"></a>(字符串)最大字符不重复子串问题 Longest Substring Without Repeating Characters</h1><p>Given a string, find the length of the longest substring without repeating characters.<br><strong>Examples:</strong><br>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.<br>给定一个字符串，求其最大子串，要求子串中无重复字符</p><p><strong>思路:</strong>一开始我使用简单的从左到右每一个字符遍历最大子串，最后一个测试用例超时了，这里discuss里给出了一个特别好的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        usedChar = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="comment"># start是一个下表，表示这一轮新的字符串的开始下标</span></span><br><span class="line">        <span class="comment"># if s[i] in userChar 表示遍历到的当前字符曾经用过，有跟我当前新字符串重复的嫌疑</span></span><br><span class="line">        <span class="comment"># start &lt;= userChar[s[i]]就是说我去查查你上次出现的下标，如果是在start以后，也就是说在当前新字符串你已经出现过一次了，那么这次就算重复了</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">            <span class="comment"># 那么这次新字符串的遍历到此结束，start更新为上次这个下标出现的后一位字符，下面会有详细解释</span></span><br><span class="line">                start = usedChar[s[i]]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength = max(maxLength,i-start+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 每次都更新下标</span></span><br><span class="line">            usedChar[s[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">**举个例子说明**</span><br><span class="line">abczkoz543q</span><br><span class="line"></span><br><span class="line">从左到右遍历：(used 误拼为 user 了)</span><br><span class="line">a -&gt; not in userChar ; max(0,1)=1 ; userChar[a] = 0</span><br><span class="line">b -&gt; not in userChar ; max(1,2)=2 ; userChar[b] = 1</span><br><span class="line">c -&gt; not in userChar ; max(2,3)=3 ; userChar[c] = 2</span><br><span class="line">z -&gt; not in userChar ; max(3,4)=4 ; userChar[z] = 3</span><br><span class="line">k -&gt; not in userChar ; max(4,5)=5 ; userChar[k] = 4</span><br><span class="line">o -&gt; not in userChar ; max(5,6)=6 ; userChar[b] = 5</span><br><span class="line">(到这儿为止，字符串一直是从start=<span class="number">0</span>到当前下标，所以长度为<span class="number">6</span>)</span><br><span class="line">z -&gt; in userChar and start &lt; userChar[z]</span><br><span class="line">在这里z在下标为<span class="number">3</span>的时候出现过的，而当前字符串是从下标为<span class="number">0</span>开始的，所以这个字符串到此为止了，它贡献了maxLength=<span class="number">6</span></span><br><span class="line">然后更新start为<span class="number">3</span>+<span class="number">1</span>，也就是从z后面的k作为下一个字符串的开始下标</span><br><span class="line">这里就要从第二个开始继续遍历了，因为没必要从b开始再遍历，因为b也肯定会遍历第一个z然后遍历到第二个z，它形成的最大子串其实是a形成的最大子串的子串，即 bczko 属于 abzko</span><br><span class="line">所以直接从z的下一个元素，也就是k开始作为start即可，同时这里用到了字典，也降低了时间复杂度</span><br></pre></td></tr></table></figure><hr><h1 id="分治-两个数组的中位数-Median-of-Two-Sorted-Arrays"><a href="#分治-两个数组的中位数-Median-of-Two-Sorted-Arrays" class="headerlink" title="(分治)两个数组的中位数 Median of Two Sorted Arrays"></a>(分治)两个数组的中位数 Median of Two Sorted Arrays</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>限制时间复杂度是O(log(m+n))<br><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>思路:</strong>非常简单的一道题目，先用+连起来，sorted一下，如果是偶数就输出中间两个的均值，如果是奇数长度就输出中间那个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = sorted(nums1+nums2)</span><br><span class="line">        <span class="keyword">if</span> len(l)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (l[int(len(l)/<span class="number">2</span>)] + l[int(len(l)/<span class="number">2</span><span class="number">-1</span>)])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(l[int((len(l)<span class="number">-1</span>)/<span class="number">2</span>)])</span><br></pre></td></tr></table></figure></p><p><strong>但是</strong>其实这个复杂度是O(m+n),这种做法的思想基于下面这种做法一样，而且应该花的时间更长，是最优化最差也是最简单的做法：<br>依次遍历两个数组，每次取最小那个，直到遍历到第i个，这个i就是我们要的中位数或中间两个数，时间复杂度为O(m+n)<br><strong>有更好的做法：分治</strong><br>思路是分治常用的“割”，关键点是一条线割开两个数组，使得左边部分全部小于右边部分，这样就可以确定虚拟数组（两个数组合并排序）的前k个值了，妙啊妙啊。<br>这是O(min(m,n))的做法(感觉不够简练)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1)+len(nums2)&lt;=<span class="number">10</span>:</span><br><span class="line">            l = sorted(nums1 + nums2)</span><br><span class="line">            <span class="keyword">if</span> len(l) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> (float(l[int(len(l) / <span class="number">2</span>)]) + float(l[int(len(l) / <span class="number">2</span> - <span class="number">1</span>)])) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(l[int((len(l) - <span class="number">1</span>) / <span class="number">2</span>)])</span><br><span class="line">        <span class="keyword">if</span> len(nums1)&lt;len(nums2):</span><br><span class="line">            long = nums2</span><br><span class="line">            short = nums1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            long = nums1</span><br><span class="line">            short = nums2</span><br><span class="line">        <span class="keyword">if</span> (len(long)+len(short))%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 前面找k个数</span></span><br><span class="line">            k = ((len(nums1)+len(nums2))<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">            k1 = <span class="number">0</span></span><br><span class="line">            k2 = k - <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> ((k2 + <span class="number">1</span> &lt;= len(long) - <span class="number">1</span> <span class="keyword">and</span> short[k1] &gt; long[k2 + <span class="number">1</span>]) <span class="keyword">or</span> (</span><br><span class="line">                        k1 + <span class="number">1</span> &lt;= len(short) - <span class="number">1</span> <span class="keyword">and</span> long[k2] &gt; short[k1 + <span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">if</span> short[k1]&gt;long[k2+<span class="number">1</span>]:</span><br><span class="line">                    k1-=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k1+=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">            <span class="keyword">if</span> k1 + <span class="number">1</span> &lt;= len(short) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> min(short[k1 + <span class="number">1</span>], long[k2 + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> long[k2 + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = (len(nums1)+len(nums2))/<span class="number">2</span> <span class="number">-1</span></span><br><span class="line">            <span class="comment"># 割少的那个尾巴，注意下标</span></span><br><span class="line">            k1 = <span class="number">0</span></span><br><span class="line">            k2 = k<span class="number">-2</span></span><br><span class="line">            <span class="keyword">while</span>((k2+<span class="number">1</span>&lt;= len(long)<span class="number">-1</span> <span class="keyword">and</span> short[k1]&gt;long[k2+<span class="number">1</span>]) <span class="keyword">or</span> (k1+<span class="number">1</span> &lt;= len(short)<span class="number">-1</span> <span class="keyword">and</span> long[k2]&gt;short[k1+<span class="number">1</span>])):</span><br><span class="line">                <span class="keyword">if</span> short[k1]&gt;long[k2+<span class="number">1</span>]:</span><br><span class="line">                    k1-=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k1+=<span class="number">1</span></span><br><span class="line">                    k2 = k-k1<span class="number">-2</span></span><br><span class="line">            compareL = []</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k1+<span class="number">1</span>&lt;=len(short)<span class="number">-1</span> <span class="keyword">and</span> count &lt;<span class="number">2</span>:</span><br><span class="line">                compareL.append(short[k1+<span class="number">1</span>])</span><br><span class="line">                k1+=<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k2+<span class="number">1</span>&lt;=len(long)<span class="number">-1</span> <span class="keyword">and</span> count &lt;<span class="number">2</span>:</span><br><span class="line">                compareL.append(long[k2+<span class="number">1</span>])</span><br><span class="line">                k2+=<span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            x1 = min(compareL)</span><br><span class="line">            compareL.remove(x1)</span><br><span class="line">            x2 = min(compareL)</span><br><span class="line">            <span class="keyword">return</span> (float(x1)+float(x2))/<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以加个二分查找就变为了O(log(min(m,n))),有空再更新吧</p><hr><h1 id="3Sum问题"><a href="#3Sum问题" class="headerlink" title="3Sum问题"></a>3Sum问题</h1><p>第二次重写Nsum问题，花了一个小时调试边界值，虽然基本思想没忘，但是对细节的处理很差，后面写上注意事项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N, L, subResult, target)</span>:</span></span><br><span class="line">            <span class="comment"># 这种写法的复杂度是nlog(n),超时了，改写为排序数组的2Sum写法</span></span><br><span class="line">            <span class="comment"># if N == 2:</span></span><br><span class="line">            <span class="comment">#     sumDict = &#123;&#125;</span></span><br><span class="line">            <span class="comment">#     for i in L:</span></span><br><span class="line">            <span class="comment">#         if i not in sumDict:</span></span><br><span class="line">            <span class="comment">#             sumDict[target - i] = i</span></span><br><span class="line">            <span class="comment">#         else:</span></span><br><span class="line">            <span class="comment">#             # 这里用了一个sorted来解决重复问题，不知道有没有更好的办法</span></span><br><span class="line">            <span class="comment">#             if sorted(subResult+[target-i,i]) not in result:</span></span><br><span class="line">            <span class="comment">#                 print subResult+[target-i,i]</span></span><br><span class="line">            <span class="comment">#                 result.append(sorted(subResult+[target-i,i]))</span></span><br><span class="line">            <span class="comment">#     return</span></span><br><span class="line">            <span class="keyword">if</span> N==<span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(L)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> r&gt;l:</span><br><span class="line">                    <span class="keyword">if</span> L[l]+L[r] == target:</span><br><span class="line">                        result.append(subResult+[L[r],L[l]])</span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> L[l] == L[l+<span class="number">1</span>]:</span><br><span class="line">                            l+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> L[r] == L[r<span class="number">-1</span>]:</span><br><span class="line">                            r-=<span class="number">1</span></span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L[l]+L[r] &gt; target:</span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L[l]+L[r] &lt; target:</span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 每次跳过重复字符</span></span><br><span class="line">                    <span class="comment"># while i&gt;1 and i&lt;len(L)-1 and L[i]==L[i-1]:</span></span><br><span class="line">                    <span class="comment">#     i+=1</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] != L[i]):</span><br><span class="line">                        Nsum(N - <span class="number">1</span>, L[i + <span class="number">1</span>:], subResult + [L[i]], target - L[i])</span><br><span class="line">        Nsum(<span class="number">3</span>,sorted(nums),[],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>1：</strong>思路依然是递归的将Nsum问题转化为2Sum问题，这里2Sum因为要找的值是不用管下标的，所以可以将数组排好序，这样可以将2Sum问题的时间<br>复杂度降为O(n),而找两个下标的2Sum问题的复杂度是O(nlogN),我一开始将两者弄混了，所以一开始用的找下标的那种方法，然后就超时了<br><strong>2：</strong>注意2Sum问题的时候，指针移动的时候，要先跳过所以重复值，加上l<r就可以防止边界问题 **3：**递归的地方我注释掉的部分，**while="" i="">1 and i&lt;len(L)-1 and L[i]==L[i-1]:**如果用这种方法来去掉遍历时候的重复值，会出现一些问题，比如[0,0,0,0,0]，<br>虽然跳过了0，但是最后一个0还是会进，这样就会出现输出为[[0,0,0],[0,0,0]]的情况，所以用if可以防止这种情况，只要和前面重复都不进。</r就可以防止边界问题></p><hr><h1 id="NSum-Closest问题"><a href="#NSum-Closest问题" class="headerlink" title="NSum Closest问题"></a>NSum Closest问题</h1><p>是Nsum问题的变形，但是原理差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 全局变量问题</span></span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    <span class="keyword">global</span> Min</span><br><span class="line">    Min = <span class="number">9999</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSum</span><span class="params">(N, L, Sum, target)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> result</span><br><span class="line">        <span class="keyword">global</span> Min</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 从L里找两个数，使得min(|(x1+x2+sum)-1|)</span></span><br><span class="line">            l, r = <span class="number">0</span>, len(L) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 先替换</span></span><br><span class="line">                <span class="keyword">if</span> Min &gt; abs(L[r] + L[l] + Sum - target):</span><br><span class="line">                    Min = abs(L[r] + L[l] + Sum - target)</span><br><span class="line">                    result = L[r] + L[l] + Sum</span><br><span class="line">                <span class="comment"># 是否特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> abs(L[r] + L[l] + Sum - target) ==<span class="number">0</span>:</span><br><span class="line">                    result = L[r] + L[l] + Sum</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># 移动指针</span></span><br><span class="line">                <span class="keyword">if</span> L[r] + L[l] + Sum &gt; target <span class="keyword">and</span> l&lt;r:</span><br><span class="line">                    r-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> L[r] + L[l] + Sum &lt;target <span class="keyword">and</span> l&lt;r:</span><br><span class="line">                    l+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L) - N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i] != L[i - <span class="number">1</span>]):</span><br><span class="line">                    findSum(N - <span class="number">1</span>, L[i + <span class="number">1</span>:], Sum + L[i], target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    findSum(<span class="number">3</span>, sorted(nums), <span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>还是递归的思想减少的2Sum问题，每次左右指针先算一次去替换最小，如果出现最优情况直接return，否则根据情况移动左右指针，跟Nsum还是有所区别。</p><hr><h1 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h1><p>数字组合，给出手机上的号码，每个号码对应着一组字母，求之间的有多少种组合方式<br>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="图片"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>就是一个简单的递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        kvmaps = &#123;</span><br><span class="line">            <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">            <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">            <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">            <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">            <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">            <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">            <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">            <span class="string">'9'</span>: <span class="string">'wxyz'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">comLetter</span><span class="params">(number, L)</span>:</span></span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">if</span> number == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> L == []:result = [x <span class="keyword">for</span> x <span class="keyword">in</span> kvmaps[number[<span class="number">0</span>]]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> kvmaps[number[<span class="number">0</span>]]:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> L:</span><br><span class="line">                        result.append(y+x)</span><br><span class="line">            <span class="keyword">if</span> len(number) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> comLetter(number[<span class="number">1</span>:], result)</span><br><span class="line">        <span class="keyword">return</span> comLetter(digits, [])</span><br></pre></td></tr></table></figure><hr><h1 id="动态规划-最长不下降或不上升子序列"><a href="#动态规划-最长不下降或不上升子序列" class="headerlink" title="动态规划 最长不下降或不上升子序列"></a>动态规划 最长不下降或不上升子序列</h1><p><a href="http://blog.csdn.net/wy19910326/article/details/7229350" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)leetcode刷题记录&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow学习笔记</title>
    <link href="http://yoursite.com/2017/11/29/Tensorflow%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/29/Tensorflow笔记/</id>
    <published>2017-11-28T16:00:00.000Z</published>
    <updated>2018-01-29T16:35:34.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用flags定义命令行参数"><a href="#使用flags定义命令行参数" class="headerlink" title="使用flags定义命令行参数"></a>使用flags定义命令行参数</h1><p>flag在TensorFlow中用于定义命令行参数<br><a href="http://blog.csdn.net/leiting_imecas/article/details/72367937" target="_blank" rel="noopener">参考链接</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一个是参数名称，第二个参数是默认值，第三个是参数描述</span></span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">'str_name'</span>, <span class="string">'def_v_1'</span>,<span class="string">"descrip1"</span>)</span><br><span class="line">tf.app.flags.DEFINE_integer(<span class="string">'int_name'</span>, <span class="number">10</span>,<span class="string">"descript2"</span>)</span><br><span class="line">tf.app.flags.DEFINE_boolean(<span class="string">'bool_name'</span>, <span class="keyword">False</span>, <span class="string">"descript3"</span>)</span><br><span class="line"></span><br><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment">#必须带参数，否则：'TypeError: main() takes no arguments (1 given)';   main的参数名随意定义，无要求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span>  </span><br><span class="line">    print(FLAGS.str_name)</span><br><span class="line">    print(FLAGS.int_name)</span><br><span class="line">    print(FLAGS.bool_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tf.app.run()  <span class="comment">#执行main函数</span></span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@AliHPC-G41<span class="number">-211</span> test]<span class="comment"># python tt.py</span></span><br><span class="line">def_v_1</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">[root@AliHPC-G41<span class="number">-211</span> test]<span class="comment"># python tt.py --str_name test_str --int_name 99 --bool_name True</span></span><br><span class="line">test_str</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="Tensorflow实现线性回归"><a href="#Tensorflow实现线性回归" class="headerlink" title="Tensorflow实现线性回归"></a>Tensorflow实现线性回归</h1><p>(本习题也是港大深度学习的第一次作业)</p><h2 id="线性回归原理"><a href="#线性回归原理" class="headerlink" title="线性回归原理"></a>线性回归原理</h2><p><strong>单变量线性回归</strong></p><ul><li>因为是线性回归，所以学习到的函数为线性函数，即直线函数</li><li>因为是单变量，因此只有一个x<br>我们能够给出单变量线性回归的模型：<br><img src="http://img.blog.csdn.net/20161006121754312" alt="公式1"><br>我们常称x为feature，h(x)为hypothesis（假设函数）<br><strong>Cost Function：</strong>对假设的函数进行评价，Cost Function越小的函数，说明对训练数据拟合的越好。下面给出costFunction公式：<br><img src="http://img.blog.csdn.net/20161006124407924" alt="公式2"><br>如果theta0和theta1都不固定，则theta0、theta1、J的函数为：<br><img src="http://img.blog.csdn.net/20161006134926885" alt="公式3"><br><strong>注意如果是线性回归，则cost function一定是碗状的，即只有一个最小点。</strong></li></ul><p><strong>损失函数最优化：梯度下降</strong><br>下面给出梯度下降算法：<br><img src="http://img.blog.csdn.net/20161006140441811" alt="公式4"><br><strong>特点</strong><br><strong>a)</strong>初始点不同，获得的最小值也不同，因此梯度下降求得的只是局部最小值；<br><strong>b)</strong>越接近最小值，下降速度越慢。<br><strong>问题1：</strong>如果和初始值就在local minimum的位置，则、会如何变化？<br><strong>答案：</strong>因为、已经在local minimum位置，所以derivative（导数）肯定是0，因此、不会改变。<br><strong>问题2：</strong>如果取到一个正确的值，则cost function应该会越来越小。那么，怎么取值？<br><strong>答案：</strong>随时观察值，如果cost function变小了，则OK；反之，则再取一个更小的值。</p><p><strong>注意：</strong>下降的步伐大小非常重要，因为，如果太小，则找到函数最小值的速度就很慢；如果太大，则可能会出现overshoot the minimum现象。<br><img src="http://img.blog.csdn.net/20161006143417373" alt="overshoot"><br>那既然梯度下降可以求到损失函数的最小值，线性回归又是需要一个最小的损失函数，那么可以将两者进行整合：<br><img src="http://img.blog.csdn.net/20161006144108314" alt="整合"></p><p><strong>Feature Scaling</strong>此种方法应用于梯度下降，为了加快梯度下降的执行速度。<br>思想：将各个feature的值标准化，使得取值范围大致都在<strong>-1&lt;=x&lt;=1</strong>之间。<br>常用的方法是Mean Normalization，即<img src="http://img.blog.csdn.net/20161006144838659" alt="1">,或者[X-mean(X)]/std(X)。</p><p><strong>多变量线性回归</strong><br>其假设函数为:<br><img src="http://img.blog.csdn.net/20161006151000259" alt="3"><br>损失函数仍然定义为平方损失函数<br>最小化损失函数仍然可以用梯度下降法：<br><img src="http://img.blog.csdn.net/20161006151253077" alt="4"></p><p>下面给出python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据集 -2到2 200个点 等差数列</span></span><br><span class="line">x_train = np.linspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment"># 构造 系数为2 偏差为4的y 加入一些随机噪音</span></span><br><span class="line">y_train = x_train * <span class="number">2</span> + np.ones(len(x_train)) * <span class="number">4</span> + np.random.randn(len(x_train)) * <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensorflow构造模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.定义输入和输出的占位符 tf中一般是tf.float32</span></span><br><span class="line">X = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line">Y = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义参数变量,初始化为0</span></span><br><span class="line">w = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'weights'</span>)</span><br><span class="line">b = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'bias'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.定义假设模型的输出,wx+b</span></span><br><span class="line">y_pred = tf.multiply(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.定义损失函数,这里是平方损失函数</span></span><br><span class="line">loss = tf.square(y_pred - Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.定义优化函数来最小化损失函数,学习率，要最小化的损失函数</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到这里搭建完了图模型，但是不会产生任何运算结果，因为需要session来驱动</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># 变量必须要初始化，如果变量有嵌套关系，则必须按顺序初始化</span></span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line"><span class="comment"># 定义迭代次数</span></span><br><span class="line">iteration_nums = <span class="number">500</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration_nums):</span><br><span class="line">    <span class="comment"># 注意这里，要run的是optimizer这个函数，它又用到了loss这个函数，而loss函数又用到了y_pred这个结果，所以追溯向前，一共</span></span><br><span class="line">    <span class="comment"># 用到了 X,Y 这两个被占位符声明的输入与输出以及w,b这两个变量，而参数变量正是我们要优化的目标</span></span><br><span class="line">    sess.run(optimizer, feed_dict=&#123;X: x_train, Y: y_train&#125;)</span><br><span class="line"><span class="comment"># 学习完成后，变量w,b被重新赋值，打印w和b</span></span><br><span class="line">print(sess.run(w))</span><br><span class="line">print(sess.run(b))</span><br></pre></td></tr></table></figure></p><p>最终的输出为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.0024</span></span><br><span class="line"><span class="number">3.9702</span></span><br></pre></td></tr></table></figure></p><p>与预期输出相符，注意我在一开始设置步长为0.01的时候发散掉了，最后w和b都是nan，所以合理的调参是必不可少的<br>下面绘制一下样本点和回归函数的图像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意上面y_pred没有实际的值</span></span><br><span class="line">y_pred = sess.run(y_pred,&#123;X:x_train&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'Population of City in 10,000s'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Profit in $10,000s'</span>)</span><br><span class="line">plt.plot(x_train,y_train,marker=<span class="string">'x'</span>,lw=<span class="number">0</span>,color=<span class="string">'r'</span>,label=<span class="string">'Training data'</span>)</span><br><span class="line">plt.plot(x_train,y_pred,linestyle=<span class="string">'-'</span>,color=<span class="string">'b'</span>,label=<span class="string">'Linear regression line'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="http://i4.bvimg.com/620746/ca16ce6a4d186649s.png" alt="1"></p><p>再构造一些测试数据，用学习到的模型进行预测<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.定义测试数据</span></span><br><span class="line">X_test = tf.placeholder(<span class="string">'float'</span>)</span><br><span class="line"><span class="comment"># 2.定义相关参数</span></span><br><span class="line">w = sess.run(w)</span><br><span class="line">b = sess.run(b)</span><br><span class="line"><span class="comment"># 3.定义预测</span></span><br><span class="line">predict = tf.multiply(w,X_test)+b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.得到预测结果</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line">test_pred = sess.run(predict,&#123;X_test:x_test&#125;)</span><br><span class="line">print(test_pred)</span><br></pre></td></tr></table></figure></p><p>绘制测试集上的回归函数图像：<br><img src="http://i4.bvimg.com/620746/af37e43ce35e8e51s.png" alt="2"><br>可以看到拟合的效果还是不错的。</p><p>这是<a href="http://blog.csdn.net/freedom098/article/details/52106931" target="_blank" rel="noopener">freedom098博客</a>上的一点关于梯度下降的一点儿感悟：<br><strong>1、</strong>梯度下降法分为批量梯度下降和随机梯度下降法，第一种是所有数据都参与运算后，计算误差函数，根据此误差函数来更新模型参数，实际调试发现，如果定义误差函数为平方误差函数，这个值很快就会飞掉，原因是，批量平方误差都加起来可能会很大，如果此时学习率比较高，那么调整就会过，造成模型参数向一个方向大幅调整，造成最终结果发散。所以这个时候要降低学习率，让参数变化不要太快。<br><strong>2、</strong>随机梯度下降法，每次用一个数据计算误差函数，然后更新模型参数，这个方法有可能会造成结果出现震荡，而且麻烦的是由于要一个个取出数据参与运算，而不是像批量计算那样采用了广播或者向量化乘法的机制，收敛会慢一些。但是速度要比使用批量梯度下降要快，原因是不需要每次计算全部数据的梯度了。比较折中的办法是mini-batch，也就是每次选用一小部分数据做梯度下降，目前这也是最为常用的方法了。<br><strong>3、</strong>epoch概念：所有样本集过完一轮，就是一个epoch，很明显，如果是严格的随机梯度下降法，一个epoch内更新了样本个数这么多次参数，而批量法只更新了一次。</p><hr>]]></content>
    
    <summary type="html">
    
      从零开始TensorFlow
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/1970/01/01/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/1970/01/01/剑指offer/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-10T13:42:19.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二位数组中的查找"><a href="#二位数组中的查找" class="headerlink" title="二位数组中的查找"></a>二位数组中的查找</h1><p><strong>题目描述</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>My solution</strong>:用递归来解，从右下向左上对角线遍历，每次把大矩阵分为左下右上两个小矩阵进行递归，终止条件是target位于对角线或矩阵只剩一行或一列遍历target（矩阵可能行列数不相同）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self,target, array)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">FindTarget</span><span class="params">(target, array)</span>:</span></span><br><span class="line">            <span class="comment"># 如果只有一行</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> target <span class="keyword">in</span> array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(array) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果只有一列</span></span><br><span class="line">                <span class="keyword">if</span> len(array[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> len(array[<span class="number">1</span>]) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> target <span class="keyword">in</span> [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="comment"># 其它情况</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    height = len(array)</span><br><span class="line">                    width = len(array[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">while</span> (height &gt; <span class="number">0</span> <span class="keyword">and</span> width &gt; <span class="number">0</span>):</span><br><span class="line">                        v = array[height - <span class="number">1</span>][width - <span class="number">1</span>]</span><br><span class="line">                        height -= <span class="number">1</span></span><br><span class="line">                        width -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> v == target:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">if</span> v &gt; target <span class="keyword">and</span> height!=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            remain1 = [x[width + <span class="number">1</span>:len(array[<span class="number">0</span>])] <span class="keyword">for</span> x <span class="keyword">in</span> array[:height+<span class="number">1</span>]]</span><br><span class="line">                            remain2 = [x[:width + <span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array[height + <span class="number">1</span>:len(array)]]</span><br><span class="line">                            <span class="keyword">return</span> (FindTarget(target, remain1)) <span class="keyword">or</span> (FindTarget(target, remain2))</span><br><span class="line">        result = <span class="keyword">False</span></span><br><span class="line">        result = FindTarget(target, array)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>简单做法：</strong><br>从左下开始遍历，比target大就往上，比target小就往下（妈的，看完很气，还特么辛苦写了个递归，这个简单做法太简单就不写了，╭(╯^╰)╮）</p><hr><h1 id="从尾到头打印列表"><a href="#从尾到头打印列表" class="headerlink" title="从尾到头打印列表"></a>从尾到头打印列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l = []</span><br><span class="line">        head = listNode</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l.insert(<span class="number">0</span>, head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p>很简单，注意是<strong>while head</strong> 不是 <strong>while head.next</strong></p><hr><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><strong>题目描述：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><strong>思路</strong><br>就是一个数组，把从后面切片放到前面来，让找最小数字，最简单的做法是直接min()函数，但是耗时<br>我的做法是使用递归，如果数组中间的数比开头的小，那么说明最小的数在这个切片里，不然就在后半切片里<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array)&lt;<span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> min(array)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&gt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[int(len(array)/<span class="number">2</span>):])</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&lt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[:int(len(array)/<span class="number">2</span>)+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> findMin(rotateArray)</span><br></pre></td></tr></table></figure></p><p>再优化一点就是从左到右找，找到下一个比当前的小了说明下一个就是最小值</p><hr><h1 id="输出斐波那契数列第n个数"><a href="#输出斐波那契数列第n个数" class="headerlink" title="输出斐波那契数列第n个数"></a>输出斐波那契数列第n个数</h1><p><strong>递归做法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getN</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getN(n - <span class="number">1</span>) + getN(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> getN(n)</span><br></pre></td></tr></table></figure></p><p><strong>数组做法</strong><br>def Fibonacci(self, n):<br>        a = [0,1,1]<br>        if n<3: return="" a[n]="" else:="" for="" i="" in="" range(n-2):="" a.append(a[-1]+a[-2])="" a[-1]="" **三个变量做法**最快="" <figure="" class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">        int one = <span class="number">0</span>;</span><br><span class="line">        int two = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> one;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> two;</span><br><span class="line">        int result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            result = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></3:></p><hr><h1 id="斐波那契数列扩展"><a href="#斐波那契数列扩展" class="headerlink" title="斐波那契数列扩展"></a>斐波那契数列扩展</h1><p><strong>问题</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路</strong><br>一个青蛙跳到第k个台阶，对于k-1个台阶来说只有一种跳法，就是跳1级，对k-2级台阶来说就是跳两级，也只有一种跳法，所以跳到第k个台阶的做法就是跳到第k-1个台阶的做法+跳到第k-2个台阶的做法<br>也就是 <strong>斐波那契数列！</strong><br>精彩</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)剑指offer&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>各公司校招算法题</title>
    <link href="http://yoursite.com/1970/01/01/%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/1970/01/01/校招算法题/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-10T15:57:58.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网易2018校园招聘编程题真题"><a href="#网易2018校园招聘编程题真题" class="headerlink" title="网易2018校园招聘编程题真题"></a>网易2018校园招聘编程题真题</h1><h2 id="魔法币"><a href="#魔法币" class="headerlink" title="魔法币"></a>魔法币</h2><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一行,包括一个正整数n(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">9</span>),表示小易需要的魔法币数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符<span class="string">'1'</span>和<span class="string">'2'</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = int(input()) </span><br><span class="line">arr=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStr</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 奇数</span></span><br><span class="line">            arr.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 偶数</span></span><br><span class="line">            arr.append(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-2</span>)/<span class="number">2</span>))</span><br><span class="line">getStr(n)</span><br><span class="line">arr.reverse()</span><br><span class="line">finalStr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalStr += str(x)</span><br><span class="line">print(finalStr)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong> 递归，如果最终结果是偶数，那么上一步一定用了机器2，奇数机器1同理</p><hr><p>##”相反数“”<br>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一个整数n,(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个整数,表示n的相反数</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">1325</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">6556</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> str(n)]</span><br><span class="line">arr.reverse()</span><br><span class="line">finalNumber = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalNumber+=x</span><br><span class="line">finalNumber = int(finalNumber)</span><br><span class="line"><span class="keyword">print</span> (finalNumber + n)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单</p><hr><p>##字符串碎片<br>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个字符串s,字符串s的长度length(<span class="number">1</span> ≤ length ≤ <span class="number">50</span>),s只含小写字母(<span class="string">'a'</span>-<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。</span><br><span class="line"></span><br><span class="line">如样例所示: s = <span class="string">"aaabbaaac"</span></span><br><span class="line">所有碎片的平均长度 = (<span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span>) / <span class="number">4</span> = <span class="number">2.25</span></span><br><span class="line"></span><br><span class="line">输入例子<span class="number">1</span>:</span><br><span class="line">aaabbaaac</span><br><span class="line"></span><br><span class="line">输出例子<span class="number">1</span>:</span><br><span class="line"><span class="number">2.25</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = str(input())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findS</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    sum=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i]!=s[i+<span class="number">1</span>]:</span><br><span class="line">            sum+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(s)/sum</span><br><span class="line">print(<span class="string">'%.2f'</span>%findS(s))</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单的题目，就注意格式化的时候，我一开始用round，报错3.50要求不能3.5，于是用了%.2f</p><hr><p>##重排数列</p><p>小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。<br>牛博士给小易出了一个难题:<br>对数列A进行重新排列,使数列A满足所有的A[i] * A<a href="1 ≤ i ≤ N - 1">i + 1</a>都是4的倍数。<br>小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line"><span class="comment">#输入的第一行为数列的个数t(1 ≤ t ≤ 10),</span></span><br><span class="line"><span class="comment">#接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)</span></span><br><span class="line"><span class="comment">#第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line"><span class="comment">#对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。</span></span><br><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="comment">#输入</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = int(input())</span><br><span class="line">resultArr = []</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = [int(y) <span class="keyword">for</span> y <span class="keyword">in</span> str(input()).split(<span class="string">' '</span>)]</span><br><span class="line">    dic[n] = arr</span><br><span class="line">    arr = [int(x%<span class="number">4</span>) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br><span class="line">    ji = arr.count(<span class="number">1</span>)+arr.count(<span class="number">3</span>)<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 有能被2整除的</span></span><br><span class="line">    <span class="keyword">if</span> arr.count(<span class="number">2</span>)&gt;<span class="number">0</span>:</span><br><span class="line">        arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x != <span class="number">2</span>]</span><br><span class="line">        arr.append(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#如果存在能被2整除的，这些数必须紧邻在一起当做一个奇数</span></span><br><span class="line">    <span class="keyword">if</span> float(arr.count(<span class="number">0</span>))&gt;=(len(arr)<span class="number">-1</span>)/<span class="number">2</span>:</span><br><span class="line">        resultArr.append(<span class="string">'Yes'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resultArr.append(<span class="string">'No'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> resultArr:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong> 如果有能被2整除的，那为了满足条件，它们必须紧挨着，那就相当于一个奇数，所以可以删除它们加进来一个奇数，那么数组就只剩下奇数和能被4整除的数了，那么满足被4整除的数插在奇数中间即可，即 n* &gt;= (len(array)-1)/2 或者 大于等于奇数-1，都一样.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)互联网公司校招算法题&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/1970/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/1970/01/01/数据结构/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-17T13:01:12.828Z</updated>
    
    <content type="html"><![CDATA[<p>#二叉树的相关概念<br>一 特殊的二叉树及其特点<br>1.斜树<br>2.满二叉树<br>3.完全二叉树<br>二 二叉树性质<br>1.一般二叉树性质<br>2.完全二叉树性质<br>三 二叉树遍历<br>1.前序遍历<br>2.中序遍历<br>3.后序遍历<br>四 二叉树的建立</p><h2 id="点击查看二叉树相关概念"><a href="#点击查看二叉树相关概念" class="headerlink" title="点击查看二叉树相关概念"></a><strong><a href="https://www.cnblogs.com/polly333/p/4740355.html#0" target="_blank" rel="noopener">点击查看二叉树相关概念</a></strong></h2>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;各种数据结构的python实现&lt;/center&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
