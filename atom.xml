<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨一瓶</title>
  
  <subtitle>非常に広い肩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-14T06:21:45.008Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yangyiqing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2017/12/14/python/"/>
    <id>http://yoursite.com/2017/12/14/python/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2017-12-14T06:21:45.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-math库"><a href="#python-math库" class="headerlink" title="python math库"></a>python math库</h1><h2 id="Number-theoretic-and-representation-functions"><a href="#Number-theoretic-and-representation-functions" class="headerlink" title="Number-theoretic and representation functions"></a>Number-theoretic and representation functions</h2><ul><li><strong>math.ceil(x)</strong> 上限，返回大于或等于x的最小整数</li><li><strong>math.copysign(x,y)</strong> 赋值符号,返回x的绝对值，使用y的符号,返回类型为float</li><li><strong>math.fabs(x)</strong> 返回x的绝对值</li><li><strong>math.factorial(x)</strong> 返回x的阶乘，如果x为非正整数会报错</li><li><strong>math.floor(x)</strong> 下限，小于或等于x的最大整数 </li><li><strong>math.fmod(x,y)</strong> 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号）</li><li><strong>math.frexp(x)</strong> 返回一个元组(m,n),根据x = m<em>(2*</em>n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了）</li><li><strong>math.fsum(iterable)</strong> 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999</li><li><strong>math.gcd(a,b)</strong> 返回最大公约数,a,b必须为整数</li><li><strong>math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0)</strong> 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.18</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">11.3</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True</p><ul><li><strong>math.isfinite(x)</strong> 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number)</li><li><p><strong>math.isinf(x)</strong> 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正无穷</span></span><br><span class="line">float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="comment"># 负无穷</span></span><br><span class="line">float(<span class="string">'-inf'</span>)</span><br><span class="line">-float(<span class="string">'inf'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>math.isnan(x)</strong> 判断是否是NAN（not a number）</p></li><li><strong>math.ldexp(x,i)</strong> 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数</li><li><strong>math.modf(x)</strong> 分别返回x的小数部分和整数部分，同时带x的符号，例如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.modf(<span class="number">-1.89</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出(-0.8899999999999999, -1.0)</p><ul><li><strong>math.trunc(x)</strong> 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数<h2 id="Power-and-logarithmic-functions"><a href="#Power-and-logarithmic-functions" class="headerlink" title="Power and logarithmic functions"></a>Power and logarithmic functions</h2></li><li><strong>math.exp(x)</strong> 返回e的x方</li><li><strong>math.expm1(x)</strong> 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确</li><li><strong>math.log(x[,base])</strong> 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base),</li><li><strong>math.log1p(x)</strong> 返回值为 log(1+x)/log(e)</li><li><strong>math.log2(x)</strong> 返回值为log(x)/log2,用来代替log(x,2),因为更加精确</li><li><strong>math.log10(x)</strong> 同理，返回log(x)/log(10)</li><li><strong>math.pow(x,y)</strong> 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan</li><li><strong>math.sqrt(x)</strong> 返回x的平方根<h2 id="Trigonometric-functions"><a href="#Trigonometric-functions" class="headerlink" title="Trigonometric functions"></a>Trigonometric functions</h2><strong>三角函数</strong></li><li><strong>math.acos(x)</strong> 返回x的反余弦 arc cosine，把斜率转换成弧度</li><li><strong>math.asin(x)</strong> 返回x的反正弦 arc sine</li><li><strong>math.atan(x)</strong> 返回x的反正切 arc tangent</li><li><strong>math.atan2(y,x)</strong> 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标</li><li><strong>math.cos(x)</strong> 返回x的余弦,角度值转为余弦值,cos(0)=1.0</li><li><strong>math.sin(x)</strong> 返回x的正弦</li><li><strong>math.tan(x)</strong> 返回x的正切</li><li><strong>math.hypot(x,y)</strong> 返回欧几里得范数 sqrt(x<em>x + y</em>y) ,也就是点(x,y)到原点的距离</li><li><strong>math.degrees(x)</strong> 把角度x转为弧度，角度=（弧度/π）*180</li><li><strong>math.radians(x)</strong> 把弧度x转为角度，弧度= (角度/180)*π<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2></li><li><strong>math.lgamma(x)</strong> 返回伽马函数绝对值在x上的自然对数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)pyton相关语法&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_easy</title>
    <link href="http://yoursite.com/2017/12/13/leetcode/"/>
    <id>http://yoursite.com/2017/12/13/leetcode/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2017-12-14T07:11:47.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-Two-sum"><a href="#Array-Two-sum" class="headerlink" title="(Array)Two sum"></a>(Array)Two sum</h1><p>**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.**</p><p>Example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p><p>给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解）</p><p>Sample solution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    buff_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> buff_dict:</span><br><span class="line">            <span class="keyword">return</span> [buff_dict[nums[i]], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buff_dict[target - nums[i]] = i</span><br></pre></td></tr></table></figure></p><p><strong>思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index]</strong></p><hr><h1 id="Array-Reverse-Integer"><a href="#Array-Reverse-Integer" class="headerlink" title="(Array)Reverse Integer"></a>(Array)Reverse Integer</h1><p>Q:Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output:  <span class="number">-321</span></span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output:  <span class="number">21</span></span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>My Answer:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(str(nums))&gt;<span class="number">0</span> <span class="keyword">and</span> nums != <span class="number">0</span> <span class="keyword">and</span> nums &lt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">            nums = str(nums)</span><br><span class="line">            newStr = <span class="string">''</span></span><br><span class="line">            <span class="comment"># len(nums)-1 to -1 , -1 not included , interval is -1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                newStr = newStr + nums[i]</span><br><span class="line">            print(newStr)</span><br><span class="line">            <span class="keyword">while</span> newStr[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                newStr= newStr[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> newStr[<span class="number">-1</span>]==<span class="string">'-'</span>:</span><br><span class="line">                newStr=<span class="string">'-'</span>+newStr[:len(newStr)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> math.fabs(int(newStr)) &gt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span>(int(newStr))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：主要注意几点</strong><br>1.32位有符号整数范围判断<br>2.逆序以后0的处理<br>3.切片时注意索引是否会超范围，也就是只输入0的情况<br>4.对于是否为负的处理</p><hr><h1 id="Array-Palindrome-Number"><a href="#Array-Palindrome-Number" class="headerlink" title="(Array)Palindrome Number"></a>(Array)Palindrome Number</h1><p><strong>判断是否是回文数字</strong><br><strong>注意</strong><br>1.负数不为回文数</p><h2 id="2-不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性"><a href="#2-不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性" class="headerlink" title="2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性"></a>2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性</h2><p>Mysolution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> nums&lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> math.pow(<span class="number">10</span>,length) &lt;= nums:</span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(math.ceil(length/<span class="number">2</span>)):</span><br><span class="line">                status = math.isclose((math.floor(nums/math.pow(<span class="number">10</span>,i))%<span class="number">10</span>),(math.floor(nums/math.pow(<span class="number">10</span>,length-i<span class="number">-1</span>))%<span class="number">10</span>),abs_tol = <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="keyword">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p><strong>Hint:</strong> 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。</p><h1 id="Array-Non-decreasing-Array"><a href="#Array-Non-decreasing-Array" class="headerlink" title="(Array)Non-decreasing Array"></a>(Array)Non-decreasing Array</h1><p><strong>非下降数组</strong><br><strong>Q:</strong>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<strong></strong>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could modify the first </span><br><span class="line"><span class="number">4</span></span><br><span class="line"> to </span><br><span class="line"><span class="number">1</span></span><br><span class="line"> to get a non-decreasing array.</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">False</span></span><br><span class="line">Explanation: You can<span class="string">'t get a non-decreasing array by modify at most one element.</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>:The n belongs to [1, 10,000].</p><p><strong>题意:</strong>给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。</p><p> <strong>Mysolution:</strong><br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">       num1 = nums.copy()</span><br><span class="line">       num2 = nums.copy()</span><br><span class="line">       <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">           <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">               num1[i] = num1[i+<span class="number">1</span>]</span><br><span class="line">               num2[i+<span class="number">1</span>] = num2[i]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">return</span> num1==sorted(num1) <span class="keyword">or</span> num2==sorted(num2)</span><br></pre></td></tr></table></figure></p><p><strong>借鉴了Discuss里 -Yangshun的思路:</strong>First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting.</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)leetcode(easy难度篇)的解法和相关解释&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="http://yoursite.com/2017/11/29/test/"/>
    <id>http://yoursite.com/2017/11/29/test/</id>
    <published>2017-11-29T11:09:27.415Z</published>
    <updated>2017-11-29T11:43:10.665Z</updated>
    
    <content type="html"><![CDATA[<p>时间测试：<br>2017年11月29日 19时16分32秒</p><p><strong><em>==字体加粗高亮斜体测试==</em></strong></p><p>###<a href="www.baidu.com">百度链接测试</a></p><p>###代码测试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></p><p>###插入图片测试<br><img src="http://i2.bvimg.com/620746/e754fd9fe8ce585b.png" alt="Markdown"></p><p>###添加附件测试<br>=<a href="http://i2.bvimg.com/620746/e754fd9fe8ce585b.png" target="_blank" rel="noopener">点击下载</a></p><hr><p>###多标签写法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">  - python</span><br><span class="line">  - 机器学习</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      测试markdown
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>监督学习 半监督学习 非监督学习 强化学习</title>
    <link href="http://yoursite.com/2017/11/29/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/11/29/统计学习方法的分类/</id>
    <published>2017-11-28T16:00:00.000Z</published>
    <updated>2017-11-30T05:04:36.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><blockquote><p>监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同） –李航《统计学习方法》</p></blockquote><p>监督学习通常有标注好的训练集，通过这份训练集可以根据某个评价函数训练出最优的模型，从而对于每一个输入，该模型都能够在当前的评价体系下给出一个相对较优的输出。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>有标注好的训练样本</li><li>有输入有输出</li><li>通常的任务为分类和回归以及标注</li></ul><h3 id="常用的监督学习算法"><a href="#常用的监督学习算法" class="headerlink" title="常用的监督学习算法"></a>常用的监督学习算法</h3><ul><li>K近邻算法（KNN）</li><li>决策树 （Decision Tree）</li><li>朴素贝叶斯（Naive Bayesian）</li><li>逻辑回归（Logistic Regression）</li></ul><p>这里只罗列了几种最基础的算法，通常在实际应用或数据挖掘比赛中人们会采用更为复杂的集成算法。</p><hr><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><p>非监督学习没有任何训练样本，直接对数据进行建模，举个例子来说，数据中有大量的地理位置信息比如经纬度，就可以对经纬度进行无监督学习，把地理位置相近的分在一起，这在无监督学习中叫做聚类</p><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>没有训练样本</li><li>主要任务是聚类</li></ul><h2 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h2><p>半监督学习就和它的名字一样，同时具备监督学习和非监督学习的特征和方法，它的数据中有标注好的训练样本，也有没有标注的样本。<br>举个半监督学习的例子：</p><p><img src="https://pic1.zhimg.com/50/v2-d0fffc210bb74aa212f9b2ee55fce81c_hd.jpg" alt="半监督学习"></p><p>图中有两个标注好的训练样本，绿色的是没有标注的样本，如果按照监督学习的方法，例如SVM模型会按照左边所示来进行分类，然而实际的数据情况如右图所示，所以实际上应该按照右图所示进行划分，这也就是半监督学习的基本原理：想办法如何同时利用标注好的数据和没有标注的数据。</p><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>既有标注好的训练样本也有未标注的样本</li></ul><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>首先上一个很普遍的用来描述强化学习的图片：</p><p><img src="http://nooverfit.com/wp/wp-content/uploads/2017/01/Screenshot-from-2017-03-12-120248.png" alt="强化学习"><br>解释：训练实体(Agent)不断地采取行动(action), 之后转到下一个状态(State), 并且获得一个回报(reward), 从而进一步更新训练实体Agent.</p><p>  就像要训练小老鼠走出迷宫, 你可以在迷宫的几个关键地点放上奶酪, 这些奶酪就是算法中的回报(reward)了, 剩下你只要坐着等小老鼠走出迷宫啦:</p><p><img src="http://nooverfit.com/wp/wp-content/uploads/2017/01/rl_interaction.png" alt=""></p><p>再举个例子：</p><p>假设1:你是第一次撩妹。那么你会去求教他人，逛各种论坛，总之收集大量相关知识。这个过程就是experience data。利用离线数据来train一个model。</p><p>假设2:过去你有很多撩妹经验。你似乎又发现总是按照套路来并不能成功。嗯，经典的探索与利用问题，于是你尝试了其他方法，你发现获得了更好的效果。嗯，more optimal policy</p><p>将上述过程对应到RL中：<br>action：你的行为<br>state：你观察到的妹子的状态<br>reward：妹子的反应：开心or不开心<br>至此，一个RL的基本模型已经建立。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>  <a href="https://www.zhihu.com/question/31140846/answer/94703351" target="_blank" rel="noopener">https://www.zhihu.com/question/31140846/answer/94703351</a><br>  <a href="http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/" target="_blank" rel="noopener">http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/</a><br>  <a href="https://www.zhihu.com/question/31140846" target="_blank" rel="noopener">https://www.zhihu.com/question/31140846</a></p>]]></content>
    
    <summary type="html">
    
      统计学习的方法是基于数据构建统计模型从而对数据进行预测和分析，统计学习由监督学习，非监督学习，半监督学习和强化学习组成，本文主要详细解释这四种方法及其区别
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
