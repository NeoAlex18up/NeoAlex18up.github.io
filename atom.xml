<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨一瓶</title>
  
  <subtitle>非常に広い肩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-10T12:39:50.499Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yangyiqing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流畅的python</title>
    <link href="http://yoursite.com/2017/12/14/python/"/>
    <id>http://yoursite.com/2017/12/14/python/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2018-01-10T12:39:50.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-math库"><a href="#python-math库" class="headerlink" title="python math库"></a>python math库</h1><h2 id="Number-theoretic-and-representation-functions"><a href="#Number-theoretic-and-representation-functions" class="headerlink" title="Number-theoretic and representation functions"></a>Number-theoretic and representation functions</h2><ul><li><strong>math.ceil(x)</strong> 上限，返回大于或等于x的最小整数</li><li><strong>math.copysign(x,y)</strong> 赋值符号,返回x的绝对值，使用y的符号,返回类型为float</li><li><strong>math.fabs(x)</strong> 返回x的绝对值</li><li><strong>math.factorial(x)</strong> 返回x的阶乘，如果x为非正整数会报错</li><li><strong>math.floor(x)</strong> 下限，小于或等于x的最大整数 </li><li><strong>math.fmod(x,y)</strong> 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号）</li><li><strong>math.frexp(x)</strong> 返回一个元组(m,n),根据x = m<em>(2*</em>n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了）</li><li><strong>math.fsum(iterable)</strong> 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999</li><li><strong>math.gcd(a,b)</strong> 返回最大公约数,a,b必须为整数</li><li><strong>math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0)</strong> 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.18</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">1</span>,<span class="number">0.8</span>,rel_tol=<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p>输出为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.isclose(<span class="number">12</span>,<span class="number">0.8</span>,abs_tol = <span class="number">11.3</span>))</span><br></pre></td></tr></table></figure></p><p>输出为True</p><ul><li><strong>math.isfinite(x)</strong> 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number)</li><li><p><strong>math.isinf(x)</strong> 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正无穷</span></span><br><span class="line">float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="comment"># 负无穷</span></span><br><span class="line">float(<span class="string">'-inf'</span>)</span><br><span class="line">-float(<span class="string">'inf'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>math.isnan(x)</strong> 判断是否是NAN（not a number）</p></li><li><strong>math.ldexp(x,i)</strong> 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数</li><li><strong>math.modf(x)</strong> 分别返回x的小数部分和整数部分，同时带x的符号，例如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(math.modf(<span class="number">-1.89</span>))</span><br></pre></td></tr></table></figure></li></ul><p>输出(-0.8899999999999999, -1.0)</p><ul><li><strong>math.trunc(x)</strong> 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数<h2 id="Power-and-logarithmic-functions"><a href="#Power-and-logarithmic-functions" class="headerlink" title="Power and logarithmic functions"></a>Power and logarithmic functions</h2></li><li><strong>math.exp(x)</strong> 返回e的x方</li><li><strong>math.expm1(x)</strong> 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确</li><li><strong>math.log(x[,base])</strong> 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base),</li><li><strong>math.log1p(x)</strong> 返回值为 log(1+x)/log(e)</li><li><strong>math.log2(x)</strong> 返回值为log(x)/log2,用来代替log(x,2),因为更加精确</li><li><strong>math.log10(x)</strong> 同理，返回log(x)/log(10)</li><li><strong>math.pow(x,y)</strong> 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan</li><li><strong>math.sqrt(x)</strong> 返回x的平方根<h2 id="Trigonometric-functions"><a href="#Trigonometric-functions" class="headerlink" title="Trigonometric functions"></a>Trigonometric functions</h2><strong>三角函数</strong></li><li><strong>math.acos(x)</strong> 返回x的反余弦 arc cosine，把斜率转换成弧度</li><li><strong>math.asin(x)</strong> 返回x的反正弦 arc sine</li><li><strong>math.atan(x)</strong> 返回x的反正切 arc tangent</li><li><strong>math.atan2(y,x)</strong> 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标</li><li><strong>math.cos(x)</strong> 返回x的余弦,角度值转为余弦值,cos(0)=1.0</li><li><strong>math.sin(x)</strong> 返回x的正弦</li><li><strong>math.tan(x)</strong> 返回x的正切</li><li><strong>math.hypot(x,y)</strong> 返回欧几里得范数 sqrt(x<em>x + y</em>y) ,也就是点(x,y)到原点的距离</li><li><strong>math.degrees(x)</strong> 把角度x转为弧度，角度=（弧度/π）*180</li><li><strong>math.radians(x)</strong> 把弧度x转为角度，弧度= (角度/180)*π<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2></li><li><strong>math.lgamma(x)</strong> 返回伽马函数绝对值在x上的自然对数。</li></ul><hr><h1 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h1><p>pyhton 中的 filter函数接收一个函数f和一个序列(<strong>python中的序列有：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象，列表和元组的区别主要是：列表可以修改，元组不能</strong>)，函数f的作用是对列表中的每一个元素进行条件判断，返回True或False，filter函数最终返回一个迭代器Iterator(在python 2.x中返回一个list)<br>举例：返回1-1000中的所有奇数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x%<span class="number">2</span>!=<span class="number">0</span></span><br><span class="line"><span class="comment"># in python 3.x</span></span><br><span class="line">print(list(filter(is_odd,range(<span class="number">1</span>,<span class="number">1001</span>))))</span><br><span class="line"><span class="comment"># in python 2.x</span></span><br><span class="line"><span class="keyword">print</span> filter(is_odd,range(<span class="number">1</span>,<span class="number">1001</span>))</span><br></pre></td></tr></table></figure></p><p>字符串遍历筛选的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x==<span class="string">'a'</span></span><br><span class="line">print(list(filter(is_a,<span class="string">'HaHaHaHa'</span>)))</span><br><span class="line">Output:</span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure></p><p>例如：删除None和空字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cal_str</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip())&gt;<span class="number">0</span></span><br><span class="line">filter(Cal_str,[<span class="string">"H"</span>,<span class="keyword">None</span>,<span class="string">""</span>,<span class="string">"ello"</span>])</span><br><span class="line">Output: <span class="string">"[H"</span>,<span class="string">"ello"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h2><p><strong> strip(rm)</strong> 默认删除s字符串中开头、结尾处的rm字符串，当rm为空的时候，默认删除空白（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)</p><ul><li>s.strip(rm)        删除s字符串中开头、结尾处，位于 rm删除序列的字符</li><li>s.lstrip(rm)       删除s字符串中开头处，位于 rm删除序列的字符</li><li>s.rstrip(rm)      删除s字符串中结尾处，位于 rm删除序列的字符<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'Hello world'</span></span><br><span class="line">print(a.strip(<span class="string">'He'</span>))</span><br><span class="line">print(a.strip(<span class="string">'eH'</span>))</span><br><span class="line">print(a.strip(<span class="string">'el'</span>))</span><br><span class="line">Output:</span><br><span class="line">llo world</span><br><span class="line">llo world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></li></ul><p>由于Python3.x中的filter返回的是一个Iterator，所以不仅仅可以指定为list，也可以set(filter(…))</p><hr><h1 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h1><p>python 中的 map函数接收一个函数f和一个序列，f将作用于序列中的每个元素，最终的结果作为Interator返回</p><p>如果使用map来实现filter中的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="string">'a'</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">print(list(map(is_a,<span class="string">"Hahahah"</span>)))</span><br><span class="line">Output:</span><br><span class="line">[<span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>, <span class="string">'a'</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure></p><p><strong>map最终返回的序列长度是等于原来的序列长度的，filter返回的序列长度是小于等于原来的长度的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lambda函数的例子</span></span><br><span class="line">print(list(map(<span class="keyword">lambda</span> x:x+<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p><strong>注意！</strong> 当只有一个序列的时候，map和filter都是可以使用的，但是当处理多个序列的时候，只能使用map<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(list(map(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">14</span>]</span><br><span class="line"><span class="comment"># 相当于zip,然后将zip的结果传给函数,所以map在处理多个序列的时候，无法操作序列长度不一致，对应值类型不同的情况</span></span><br><span class="line"><span class="comment"># 例如[1,4,6],[2,5,6,8]或[1,4,6],['a',3,6]</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h1><p><strong>注意</strong> 在python3中，reduce已经从内置函数中被抛弃了，要使用就要引入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure></p><p>reduce函数是一个累积运算的过程，其接收一个函数f(x,y)和一个序列（以及一个可选的初始值）,其中函数f的x,y首先代表序列中的第一个和第二个参数，其返回值作为新的x，第三个参数作为新的y，依次运算至结束。<br>例如求和运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">print(list(reduce(f,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])))</span><br><span class="line">Process:</span><br><span class="line">先计算头两个元素：f(<span class="number">1</span>, <span class="number">3</span>)，结果为<span class="number">4</span>；</span><br><span class="line">再把结果和第<span class="number">3</span>个元素计算：f(<span class="number">4</span>, <span class="number">5</span>)，结果为<span class="number">9</span>；</span><br><span class="line">再把结果和第<span class="number">4</span>个元素计算：f(<span class="number">9</span>, <span class="number">7</span>)，结果为<span class="number">16</span>；</span><br><span class="line">再把结果和第<span class="number">5</span>个元素计算：f(<span class="number">16</span>, <span class="number">9</span>)，结果为<span class="number">25</span>；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果<span class="number">25</span></span><br></pre></td></tr></table></figure></p><p>如果设置了初始值为100，那么第一次运算就是f(100,1)</p><p>再例如，用reduce实现5的阶乘:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">6</span>)))</span><br><span class="line">Output:</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>只举了两个简单的例子，通过函数可以实现更为复杂的操作</p><hr><h1 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h1><p>lambda作为一个表达式，定义了一个匿名函数<br>定义一个lambda表达式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line"><span class="comment"># 可以这样理解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>lambda 常常配合上述的 reduce , map, filter 作为f来使用，可以使得代码大大简化。<br><strong>但是python中的 for..in..if 已经非常强大</strong>，lambda并不一定作为首选<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意是[]</span></span><br><span class="line"><span class="keyword">print</span> ([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>总之：ambda 并不会带来程序运行效率的提高，只会使代码更简洁。<strong>lambda是为了减少单行函数而存在的</strong></p><hr><h1 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h1><p>python的set和其他语言类似，是一个是一个无序不重复元素集, 基本功能包括<strong>关系测试和消除重复元素.</strong> 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.作为一个无序的集合，<strong>sets不记录元素位置或者插入点</strong>。因此，<strong>sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作</strong>。<br><strong> 初始化 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s0 = set()</span><br><span class="line">s1 = set(<span class="string">'HelloWorld'</span>)</span><br><span class="line">s2 = set([<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>])</span><br><span class="line">s3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 注意，没有这种操作 set(1,2,3)</span></span><br></pre></td></tr></table></figure></p><p><strong>简单例子：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = set(<span class="string">'spam'</span>)  </span><br><span class="line">y = set([<span class="string">'h'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>])  </span><br><span class="line">x,y</span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line">(set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'m'</span>]), set([<span class="string">'a'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>]))</span><br></pre></td></tr></table></figure></p><p><strong>去除list l 中重复元素的例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">55</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> set(l)])</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure></p><p><strong>两个集合的数学运算</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）  </span></span><br><span class="line">d = t ^ s          <span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）  </span></span><br><span class="line"><span class="comment"># 当然，也可以麻烦点写成函数的形式</span></span><br><span class="line">print(s.intersection(t), s &amp; t)  <span class="comment"># 交集</span></span><br><span class="line">print(s.union(t), s | t)   <span class="comment"># 并集 </span></span><br><span class="line">print(s.difference(t), s - t)  <span class="comment"># 差集 </span></span><br><span class="line">print(s.symmetric_difference(t), s ^ t) <span class="comment"># 对称差集 </span></span><br><span class="line">print(s1.issubset(s2), s1 &lt;= s2) <span class="comment"># 子集</span></span><br><span class="line">print(s1.issuperset(s2), s1 &gt;= s2)      <span class="comment"># 包含</span></span><br></pre></td></tr></table></figure></p><p><strong> 基本方法 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">len(s)  <span class="comment"># 获取集合中的元素的总数</span></span><br><span class="line">s.update([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># 添加多个元素</span></span><br><span class="line">s.add(<span class="string">"x"</span>)         <span class="comment"># 添加一个元素</span></span><br><span class="line">s.remove(<span class="string">"x"</span>)      <span class="comment"># 去掉一个元素</span></span><br><span class="line">s.discard(<span class="string">"x"</span>)     <span class="comment"># 如果集合存在指定元素，则删除该元素</span></span><br><span class="line">c = s.copy()       <span class="comment"># 复制集合</span></span><br><span class="line">s.pop() <span class="comment"># 弹出集合中的一个不确定元素(好像不是等价随机)</span></span><br><span class="line">s.clear()          <span class="comment"># 删除集合中所有的元素(改变原集合)</span></span><br><span class="line">x <span class="keyword">in</span> s  <span class="comment">#测试 x 是否是 s 的成员  </span></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></p><p><strong>参考链接</strong><br><a href="http://www.jb51.net/article/60480.htm" target="_blank" rel="noopener">链接1</a><br><a href="http://blog.csdn.net/business122/article/details/7541486" target="_blank" rel="noopener">链接2</a></p><hr><h1 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace 函数"></a>replace 函数</h1><p><strong>replace()方法语法：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(old, new[, max])</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>old – 将被替换的子字符串。</li><li>new – 新字符串，用于替换old子字符串。</li><li>max – 可选字符串, 替换不超过 max 次</li></ul><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"this is string example....wow!!! this is really string"</span>;</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>);</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas <span class="keyword">is</span> really string</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)人生苦短，我用python&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2017/12/13/leetcode/"/>
    <id>http://yoursite.com/2017/12/13/leetcode/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2018-01-26T12:56:24.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-Two-sum"><a href="#Array-Two-sum" class="headerlink" title="(Array)Two sum"></a>(Array)Two sum</h1><p>**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.**</p><p>Example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p><p>给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解）</p><p>Sample solution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    buff_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> buff_dict:</span><br><span class="line">            <span class="keyword">return</span> [buff_dict[nums[i]], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buff_dict[target - nums[i]] = i</span><br></pre></td></tr></table></figure></p><p><strong>思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index]</strong></p><hr><h1 id="Array-Reverse-Integer"><a href="#Array-Reverse-Integer" class="headerlink" title="(Array)Reverse Integer"></a>(Array)Reverse Integer</h1><p>Q:Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output:  <span class="number">-321</span></span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output:  <span class="number">21</span></span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>My Answer:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(str(nums))&gt;<span class="number">0</span> <span class="keyword">and</span> nums != <span class="number">0</span> <span class="keyword">and</span> nums &lt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">            nums = str(nums)</span><br><span class="line">            newStr = <span class="string">''</span></span><br><span class="line">            <span class="comment"># len(nums)-1 to -1 , -1 not included , interval is -1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                newStr = newStr + nums[i]</span><br><span class="line">            print(newStr)</span><br><span class="line">            <span class="keyword">while</span> newStr[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                newStr= newStr[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> newStr[<span class="number">-1</span>]==<span class="string">'-'</span>:</span><br><span class="line">                newStr=<span class="string">'-'</span>+newStr[:len(newStr)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> math.fabs(int(newStr)) &gt;= math.pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span>(int(newStr))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p><strong>思路：主要注意几点</strong><br>1.32位有符号整数范围判断<br>2.逆序以后0的处理<br>3.切片时注意索引是否会超范围，也就是只输入0的情况<br>4.对于是否为负的处理</p><hr><h1 id="Array-Palindrome-Number"><a href="#Array-Palindrome-Number" class="headerlink" title="(Array)Palindrome Number"></a>(Array)Palindrome Number</h1><p><strong>判断是否是回文数字</strong><br><strong>注意</strong><br>1.负数不为回文数<br>2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性</p><p>Mysolution:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> nums&lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> math.pow(<span class="number">10</span>,length) &lt;= nums:</span><br><span class="line">                length+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(math.ceil(length/<span class="number">2</span>)):</span><br><span class="line">                status = math.isclose((math.floor(nums/math.pow(<span class="number">10</span>,i))%<span class="number">10</span>),(math.floor(nums/math.pow(<span class="number">10</span>,length-i<span class="number">-1</span>))%<span class="number">10</span>),abs_tol = <span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="keyword">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p><strong>Hint:</strong> 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。</p><hr><h1 id="Array-Non-decreasing-Array"><a href="#Array-Non-decreasing-Array" class="headerlink" title="(Array)Non-decreasing Array"></a>(Array)Non-decreasing Array</h1><p><strong>非下降数组</strong><br><strong>Q:</strong>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<strong></strong>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).<br>Example 1:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could modify the first </span><br><span class="line"><span class="number">4</span></span><br><span class="line"> to </span><br><span class="line"><span class="number">1</span></span><br><span class="line"> to get a non-decreasing array.</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">False</span></span><br><span class="line">Explanation: You can<span class="string">'t get a non-decreasing array by modify at most one element.</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>:The n belongs to [1, 10,000].</p><p><strong>题意:</strong>给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。</p><p> <strong>Mysolution:</strong><br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">       num1 = nums.copy()</span><br><span class="line">       num2 = nums.copy()</span><br><span class="line">       <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">           <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">               num1[i] = num1[i+<span class="number">1</span>]</span><br><span class="line">               num2[i+<span class="number">1</span>] = num2[i]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">return</span> num1==sorted(num1) <span class="keyword">or</span> num2==sorted(num2)</span><br></pre></td></tr></table></figure></p><p><strong>借鉴了Discuss里 -Yangshun的思路:</strong>First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting.</p><hr><h1 id="Array-k-diff-Pairs-in-an-Array"><a href="#Array-k-diff-Pairs-in-an-Array" class="headerlink" title="(Array)k-diff Pairs in an Array"></a>(Array)k-diff Pairs in an Array</h1><p><strong>Q:</strong>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.<br><strong>Example 1:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: There are two <span class="number">2</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">and</span> (<span class="number">3</span>, <span class="number">5</span>).</span><br><span class="line">Although we have two <span class="number">1</span>s <span class="keyword">in</span> the input, we should only <span class="keyword">return</span> the number of unique pairs.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], k = <span class="number">1</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: There are four <span class="number">1</span>-diff pairs <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>) <span class="keyword">and</span> (<span class="number">4</span>, <span class="number">5</span>).</span><br></pre></td></tr></table></figure></p><p><strong>Example 3:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], k = <span class="number">0</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> one <span class="number">0</span>-diff pair <span class="keyword">in</span> the array, (<span class="number">1</span>, <span class="number">1</span>).</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong><br>1.(1,3),(3,1)属于同一个数值对<br>2.k为负的时候返回0<br>3.注意处理k=0的情况<br>4.不要使用循环嵌套，必超时<br><strong> Mysolution </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 精简版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums))))</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">        <span class="keyword">return</span> len(set(sorted(nums)) &amp; set(map(<span class="keyword">lambda</span> x:x+k,nums)))</span><br></pre></td></tr></table></figure></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样写会好理解一些</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> k&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> sum(v&gt;<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> collections.Counter(nums).values())</span><br><span class="line">           <span class="comment">#nums = list(filter(lambda x:nums.count(x)&gt;1,nums))</span></span><br><span class="line">           <span class="comment">#return len(set(nums))</span></span><br><span class="line">       nums = set(sorted(nums))</span><br><span class="line">       nums1 = set(map(<span class="keyword">lambda</span> x:x+k,nums))</span><br><span class="line">       <span class="keyword">return</span> len(nums &amp; nums1)</span><br></pre></td></tr></table></figure><p>思路：将数组中每个数+k后与原数组取交集</p><hr><h1 id="Hash-Table-Count-Primes"><a href="#Hash-Table-Count-Primes" class="headerlink" title="(Hash Table)Count Primes"></a>(Hash Table)Count Primes</h1><p><strong>Description:</strong><br>Count the number of prime numbers less than a non-negative number, <strong>n.</strong><br>计算小于正整数n的素数的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 一个长度为n的，值为True的list</span></span><br><span class="line">    primes = [<span class="keyword">True</span>] * n</span><br><span class="line">    <span class="comment"># 前两位置为False 0和1 都不是素数，最小的素数是2</span></span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数</span></span><br><span class="line">        <span class="comment"># 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了</span></span><br><span class="line">        <span class="keyword">if</span> primes[i]:</span><br><span class="line">            <span class="comment"># 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数</span></span><br><span class="line">            <span class="comment"># 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了</span></span><br><span class="line">            primes[i * i: n: i] = [<span class="keyword">False</span>] * len(primes[i * i: n: i])</span><br><span class="line">    <span class="comment"># 返回剩余的True的个数</span></span><br><span class="line">    <span class="keyword">return</span> sum(primes)</span><br></pre></td></tr></table></figure><p>这个算法实现的是<strong>埃拉托斯特尼筛法</strong>：<br>算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于  的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了）</p><hr><h1 id="Array-Medium-Insert-Delete-GetRandom-O-1"><a href="#Array-Medium-Insert-Delete-GetRandom-O-1" class="headerlink" title="(Array-Medium)Insert Delete GetRandom O(1)"></a>(Array-Medium)Insert Delete GetRandom O(1)</h1><p><strong>Description:</strong><br>Design a data structure that supports all following operations in average O(1) time.<br> 1.insert(val) : Inserts an item val to the set if not already present.<br> 2.remove(val) : Removes an item val from the set if present.<br> 3.getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned.</p><p><strong>Example：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">1</span> to the set. Returns true <span class="keyword">as</span> <span class="number">1</span> was inserted successfully.</span><br><span class="line">randomSet.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// Returns false <span class="keyword">as</span> <span class="number">2</span> does <span class="keyword">not</span> exist <span class="keyword">in</span> the set.</span><br><span class="line">randomSet.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Inserts <span class="number">2</span> to the set, returns true. Set now contains [<span class="number">1</span>,<span class="number">2</span>].</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// getRandom should <span class="keyword">return</span> either <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes <span class="number">1</span> <span class="keyword">from</span> the set, returns true. Set now contains [<span class="number">2</span>].</span><br><span class="line">randomSet.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="number">2</span> was already <span class="keyword">in</span> the set, so <span class="keyword">return</span> false.</span><br><span class="line">randomSet.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// Since <span class="number">2</span> <span class="keyword">is</span> the only number <span class="keyword">in</span> the set, getRandom always <span class="keyword">return</span> <span class="number">2.</span></span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p><p><strong> My Solution*</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Rset,self.Rlist = set(),[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Rset.add(val)</span><br><span class="line">            self.Rlist.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.Rset:</span><br><span class="line">            self.Rset.remove(val)</span><br><span class="line">            self.Rlist.remove(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.Rlist)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素<br>再添加一个discuss里用<strong>字典</strong>和list来实现的代码，更快一些：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums, self.pos = [], &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.pos:</span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            self.pos[val] = len(self.nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.pos:</span><br><span class="line">            idx, last = self.pos[val], self.nums[<span class="number">-1</span>]</span><br><span class="line">            self.nums[idx], self.pos[last] = last, idx</span><br><span class="line">            self.nums.pop(); self.pos.pop(val, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[random.randint(<span class="number">0</span>, len(self.nums) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p><hr><h1 id="Array-medium-4Sum-拓展为Nsum问题"><a href="#Array-medium-4Sum-拓展为Nsum问题" class="headerlink" title="(Array-medium)4Sum(拓展为Nsum问题)"></a>(Array-medium)4Sum(拓展为Nsum问题)</h1><p><strong>Description</strong><br>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.<br><strong>Note:</strong> The solution set must not contain duplicate quadruplets.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Solution</strong>借鉴discuss的思路，很不错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Nsum</span><span class="params">(N,nums,target,result,results)</span>:</span></span><br><span class="line">            <span class="comment"># 特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> N&gt;len(nums) <span class="keyword">or</span> target&gt;N*nums[<span class="number">-1</span>] <span class="keyword">or</span> target&lt;N*nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 高效的2Sum</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                        <span class="comment"># 补充到最终结果</span></span><br><span class="line">                        results.append(result + [nums[l], nums[r]])</span><br><span class="line">                        <span class="comment"># 左指针右移，同时右指针左移，因为已经排好序了，一个值不变另一个值变一定不会得到target</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 解决重复问题</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> r &gt; l <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 注意这里的范围，是到len(nums)-N+1,因为最后N个数为最后一组，无须再进行递归</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-N+<span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 结合sorted可解决重复问题</span></span><br><span class="line">                    <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> (i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]!=nums[i]):</span><br><span class="line">                        <span class="comment"># 递归，将nSum问题降为n-1Sum问题</span></span><br><span class="line">                        Nsum(N<span class="number">-1</span>,nums[i+<span class="number">1</span>:],target-nums[i],result+[nums[i]],results)</span><br><span class="line">        results = []</span><br><span class="line">        Nsum(<span class="number">4</span>,sorted(nums),target,[],results)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：给定一个list和一个target，求所有n个list中的数和为target的不重复组合。本题是4Sum，代码拓展为了nSum问题，主要思路是通过迭代来把问题转换为高效的2Sum问题，即nSum-&gt;n-1Sum-&gt;….-&gt;4Sum-&gt;3Sum-&gt;2Sum,具体细节在代码注释中。</p><hr><h1 id="Hash-Table-Repeated-DNA-Sequences"><a href="#Hash-Table-Repeated-DNA-Sequences" class="headerlink" title="(Hash-Table)Repeated DNA Sequences"></a>(Hash-Table)Repeated DNA Sequences</h1><p><strong>Description</strong>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.<br>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.<br>For example,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given s = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>].</span><br></pre></td></tr></table></figure></p><p>就是求一个字符串里的所有指定长度的重复子字符串。<br><strong>Mysolution</strong><br>class Solution(object):<br>    def findRepeatedDnaSequences(self, s):<br>        “””<br>        :type s: str<br>        :rtype: List[str]<br>        “””<br>        if len(s)<10: return="" []="" results="[]" dnadict="{}" for="" i="" in="" range(len(s)-9):="" if="" s[i:i+10]="" dnadict:="" dnadict[s[i:i+10]]="" +="1" else:="" key,value="" dnadict.items():="" value="">0:<br>                results.append(key)<br>        return results<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**思路** 循环切片判断是否重复，数据结构用的字典，注意的就是range的范围和切片的范围问题。将10替换为N可以变为求一个字符串中长度为N的重复子串。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># Longest Palindromic Substring</span><br><span class="line">经典的最大回文子字符串问题</span><br><span class="line">样例：</span><br><span class="line">``` python</span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></10:></p><p><strong>思路：</strong>从左到右依次把每个字符当做中心，然后依次判断两边的字符是否相等，最后取最大的那个就行了，唯一要注意的一点是连续字符的情况，比如 abccbd,这个时候要把cc整体作为一个字符串，这里用了两个位置变量，left和right，每次判断两边的相同字符之前要确定right的值，也就是相同字符的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            right = <span class="number">1</span></span><br><span class="line">            left = <span class="number">1</span></span><br><span class="line">            <span class="comment"># get the step length</span></span><br><span class="line">            <span class="keyword">while</span> i + right &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i + right] == s[i]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ((i -left ) &gt;= <span class="number">0</span> <span class="keyword">and</span> (i + right) &lt;= length - <span class="number">1</span> <span class="keyword">and</span> s[i - left] == s[i + right]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            longest = s[i - left+<span class="number">1</span>:i + right]</span><br><span class="line">            <span class="keyword">if</span> len(longest) &gt; len(result):</span><br><span class="line">                result = longest</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h1 id="链表-Add-Two-Numbers"><a href="#链表-Add-Two-Numbers" class="headerlink" title="(链表)Add Two Numbers"></a>(链表)Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></p><p><strong>思路:</strong>就是由两个链表逆序表示的整数的和，没什么思路可言，这里主要考察的是对链表的操作，具体看代码，讲的很通俗易懂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s1 = str(l1.val)</span><br><span class="line">        s2 = str(l2.val)</span><br><span class="line">        <span class="keyword">while</span> l1.next:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            s1 = str(l1.val)+s1</span><br><span class="line">        <span class="keyword">while</span> l2.next:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            s2 = str(l2.val)+s2</span><br><span class="line">        result = str(int(s1)+int(s2))</span><br><span class="line">        <span class="comment"># 头节点</span></span><br><span class="line">        head = ListNode(int(result[<span class="number">-1</span>]))</span><br><span class="line">        after = head</span><br><span class="line">        <span class="comment"># 这里是对数组的操作，[-2::-1]表示从倒数第二个元素向后-1的取全部，注意这里[-2:0:-1]和[-2::-1]是不同的，前者取到下标为1，因为:左右就是[)的，后者取到数组头</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> result[<span class="number">-2</span>::<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># 新开辟一块内存空间</span></span><br><span class="line">            node = ListNode(int(c))</span><br><span class="line">            <span class="comment"># 让after.next指向这个内存空间，相当于把两个节点连接起来</span></span><br><span class="line">            after.next = node</span><br><span class="line">            <span class="comment"># after指向这块内存空间，方便下一个节点建立以后after代表这块内存空间去实行指向下一块新的节点的任务</span></span><br><span class="line">            after = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)leetcode刷题记录&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>监督学习 半监督学习 非监督学习 强化学习</title>
    <link href="http://yoursite.com/2017/11/29/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/11/29/统计学习方法的分类/</id>
    <published>2017-11-28T16:00:00.000Z</published>
    <updated>2017-11-30T05:04:36.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><blockquote><p>监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同） –李航《统计学习方法》</p></blockquote><p>监督学习通常有标注好的训练集，通过这份训练集可以根据某个评价函数训练出最优的模型，从而对于每一个输入，该模型都能够在当前的评价体系下给出一个相对较优的输出。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>有标注好的训练样本</li><li>有输入有输出</li><li>通常的任务为分类和回归以及标注</li></ul><h3 id="常用的监督学习算法"><a href="#常用的监督学习算法" class="headerlink" title="常用的监督学习算法"></a>常用的监督学习算法</h3><ul><li>K近邻算法（KNN）</li><li>决策树 （Decision Tree）</li><li>朴素贝叶斯（Naive Bayesian）</li><li>逻辑回归（Logistic Regression）</li></ul><p>这里只罗列了几种最基础的算法，通常在实际应用或数据挖掘比赛中人们会采用更为复杂的集成算法。</p><hr><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><p>非监督学习没有任何训练样本，直接对数据进行建模，举个例子来说，数据中有大量的地理位置信息比如经纬度，就可以对经纬度进行无监督学习，把地理位置相近的分在一起，这在无监督学习中叫做聚类</p><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>没有训练样本</li><li>主要任务是聚类</li></ul><h2 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h2><p>半监督学习就和它的名字一样，同时具备监督学习和非监督学习的特征和方法，它的数据中有标注好的训练样本，也有没有标注的样本。<br>举个半监督学习的例子：</p><p><img src="https://pic1.zhimg.com/50/v2-d0fffc210bb74aa212f9b2ee55fce81c_hd.jpg" alt="半监督学习"></p><p>图中有两个标注好的训练样本，绿色的是没有标注的样本，如果按照监督学习的方法，例如SVM模型会按照左边所示来进行分类，然而实际的数据情况如右图所示，所以实际上应该按照右图所示进行划分，这也就是半监督学习的基本原理：想办法如何同时利用标注好的数据和没有标注的数据。</p><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>既有标注好的训练样本也有未标注的样本</li></ul><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>首先上一个很普遍的用来描述强化学习的图片：</p><p><img src="http://nooverfit.com/wp/wp-content/uploads/2017/01/Screenshot-from-2017-03-12-120248.png" alt="强化学习"><br>解释：训练实体(Agent)不断地采取行动(action), 之后转到下一个状态(State), 并且获得一个回报(reward), 从而进一步更新训练实体Agent.</p><p>  就像要训练小老鼠走出迷宫, 你可以在迷宫的几个关键地点放上奶酪, 这些奶酪就是算法中的回报(reward)了, 剩下你只要坐着等小老鼠走出迷宫啦:</p><p><img src="http://nooverfit.com/wp/wp-content/uploads/2017/01/rl_interaction.png" alt=""></p><p>再举个例子：</p><p>假设1:你是第一次撩妹。那么你会去求教他人，逛各种论坛，总之收集大量相关知识。这个过程就是experience data。利用离线数据来train一个model。</p><p>假设2:过去你有很多撩妹经验。你似乎又发现总是按照套路来并不能成功。嗯，经典的探索与利用问题，于是你尝试了其他方法，你发现获得了更好的效果。嗯，more optimal policy</p><p>将上述过程对应到RL中：<br>action：你的行为<br>state：你观察到的妹子的状态<br>reward：妹子的反应：开心or不开心<br>至此，一个RL的基本模型已经建立。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>  <a href="https://www.zhihu.com/question/31140846/answer/94703351" target="_blank" rel="noopener">https://www.zhihu.com/question/31140846/answer/94703351</a><br>  <a href="http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/" target="_blank" rel="noopener">http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/</a><br>  <a href="https://www.zhihu.com/question/31140846" target="_blank" rel="noopener">https://www.zhihu.com/question/31140846</a></p>]]></content>
    
    <summary type="html">
    
      统计学习的方法是基于数据构建统计模型从而对数据进行预测和分析，统计学习由监督学习，非监督学习，半监督学习和强化学习组成，本文主要详细解释这四种方法及其区别
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/1970/01/01/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/1970/01/01/剑指offer/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-10T13:42:19.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二位数组中的查找"><a href="#二位数组中的查找" class="headerlink" title="二位数组中的查找"></a>二位数组中的查找</h1><p><strong>题目描述</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>My solution</strong>:用递归来解，从右下向左上对角线遍历，每次把大矩阵分为左下右上两个小矩阵进行递归，终止条件是target位于对角线或矩阵只剩一行或一列遍历target（矩阵可能行列数不相同）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self,target, array)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">FindTarget</span><span class="params">(target, array)</span>:</span></span><br><span class="line">            <span class="comment"># 如果只有一行</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> target <span class="keyword">in</span> array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(array) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果只有一列</span></span><br><span class="line">                <span class="keyword">if</span> len(array[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> len(array[<span class="number">1</span>]) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> target <span class="keyword">in</span> [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="comment"># 其它情况</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    height = len(array)</span><br><span class="line">                    width = len(array[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">while</span> (height &gt; <span class="number">0</span> <span class="keyword">and</span> width &gt; <span class="number">0</span>):</span><br><span class="line">                        v = array[height - <span class="number">1</span>][width - <span class="number">1</span>]</span><br><span class="line">                        height -= <span class="number">1</span></span><br><span class="line">                        width -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> v == target:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">if</span> v &gt; target <span class="keyword">and</span> height!=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            remain1 = [x[width + <span class="number">1</span>:len(array[<span class="number">0</span>])] <span class="keyword">for</span> x <span class="keyword">in</span> array[:height+<span class="number">1</span>]]</span><br><span class="line">                            remain2 = [x[:width + <span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> array[height + <span class="number">1</span>:len(array)]]</span><br><span class="line">                            <span class="keyword">return</span> (FindTarget(target, remain1)) <span class="keyword">or</span> (FindTarget(target, remain2))</span><br><span class="line">        result = <span class="keyword">False</span></span><br><span class="line">        result = FindTarget(target, array)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p><strong>简单做法：</strong><br>从左下开始遍历，比target大就往上，比target小就往下（妈的，看完很气，还特么辛苦写了个递归，这个简单做法太简单就不写了，╭(╯^╰)╮）</p><hr><h1 id="从尾到头打印列表"><a href="#从尾到头打印列表" class="headerlink" title="从尾到头打印列表"></a>从尾到头打印列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l = []</span><br><span class="line">        head = listNode</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l.insert(<span class="number">0</span>, head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p>很简单，注意是<strong>while head</strong> 不是 <strong>while head.next</strong></p><hr><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><strong>题目描述：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><strong>思路</strong><br>就是一个数组，把从后面切片放到前面来，让找最小数字，最简单的做法是直接min()函数，但是耗时<br>我的做法是使用递归，如果数组中间的数比开头的小，那么说明最小的数在这个切片里，不然就在后半切片里<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array)&lt;<span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> min(array)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&gt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[int(len(array)/<span class="number">2</span>):])</span><br><span class="line">                <span class="keyword">if</span> array[int(len(array)/<span class="number">2</span>)]&lt;array[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> findMin(array[:int(len(array)/<span class="number">2</span>)+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> findMin(rotateArray)</span><br></pre></td></tr></table></figure></p><p>再优化一点就是从左到右找，找到下一个比当前的小了说明下一个就是最小值</p><hr><h1 id="输出斐波那契数列第n个数"><a href="#输出斐波那契数列第n个数" class="headerlink" title="输出斐波那契数列第n个数"></a>输出斐波那契数列第n个数</h1><p><strong>递归做法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getN</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getN(n - <span class="number">1</span>) + getN(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> getN(n)</span><br></pre></td></tr></table></figure></p><p><strong>数组做法</strong><br>def Fibonacci(self, n):<br>        a = [0,1,1]<br>        if n<3: return="" a[n]="" else:="" for="" i="" in="" range(n-2):="" a.append(a[-1]+a[-2])="" a[-1]="" **三个变量做法**最快="" <figure="" class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">        int one = <span class="number">0</span>;</span><br><span class="line">        int two = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> one;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> two;</span><br><span class="line">        int result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            result = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></3:></p><hr><h1 id="斐波那契数列扩展"><a href="#斐波那契数列扩展" class="headerlink" title="斐波那契数列扩展"></a>斐波那契数列扩展</h1><p><strong>问题</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路</strong><br>一个青蛙跳到第k个台阶，对于k-1个台阶来说只有一种跳法，就是跳1级，对k-2级台阶来说就是跳两级，也只有一种跳法，所以跳到第k个台阶的做法就是跳到第k-1个台阶的做法+跳到第k-2个台阶的做法<br>也就是 <strong>斐波那契数列！</strong><br>精彩</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)剑指offer&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/1970/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/1970/01/01/数据结构/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-17T13:01:12.828Z</updated>
    
    <content type="html"><![CDATA[<p>#二叉树的相关概念<br>一 特殊的二叉树及其特点<br>1.斜树<br>2.满二叉树<br>3.完全二叉树<br>二 二叉树性质<br>1.一般二叉树性质<br>2.完全二叉树性质<br>三 二叉树遍历<br>1.前序遍历<br>2.中序遍历<br>3.后序遍历<br>四 二叉树的建立</p><h2 id="点击查看二叉树相关概念"><a href="#点击查看二叉树相关概念" class="headerlink" title="点击查看二叉树相关概念"></a><strong><a href="https://www.cnblogs.com/polly333/p/4740355.html#0" target="_blank" rel="noopener">点击查看二叉树相关概念</a></strong></h2>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;各种数据结构的python实现&lt;/center&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>各公司校招算法题</title>
    <link href="http://yoursite.com/1970/01/01/%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/1970/01/01/校招算法题/</id>
    <published>1970-01-01T00:03:21.819Z</published>
    <updated>2018-01-10T15:57:58.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网易2018校园招聘编程题真题"><a href="#网易2018校园招聘编程题真题" class="headerlink" title="网易2018校园招聘编程题真题"></a>网易2018校园招聘编程题真题</h1><h2 id="魔法币"><a href="#魔法币" class="headerlink" title="魔法币"></a>魔法币</h2><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一行,包括一个正整数n(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">9</span>),表示小易需要的魔法币数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符<span class="string">'1'</span>和<span class="string">'2'</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = int(input()) </span><br><span class="line">arr=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStr</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 奇数</span></span><br><span class="line">            arr.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 偶数</span></span><br><span class="line">            arr.append(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getStr(int((n<span class="number">-2</span>)/<span class="number">2</span>))</span><br><span class="line">getStr(n)</span><br><span class="line">arr.reverse()</span><br><span class="line">finalStr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalStr += str(x)</span><br><span class="line">print(finalStr)</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong> 递归，如果最终结果是偶数，那么上一步一定用了机器2，奇数机器1同理</p><hr><p>##”相反数“”<br>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line">输入包括一个整数n,(<span class="number">1</span> ≤ n ≤ <span class="number">10</span>^<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line">输出一个整数,表示n的相反数</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入例子1:</span></span><br><span class="line"><span class="number">1325</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出例子1:</span></span><br><span class="line"><span class="number">6556</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> str(n)]</span><br><span class="line">arr.reverse()</span><br><span class="line">finalNumber = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">    finalNumber+=x</span><br><span class="line">finalNumber = int(finalNumber)</span><br><span class="line"><span class="keyword">print</span> (finalNumber + n)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单</p><hr><p>##字符串碎片<br>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个字符串s,字符串s的长度length(<span class="number">1</span> ≤ length ≤ <span class="number">50</span>),s只含小写字母(<span class="string">'a'</span>-<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。</span><br><span class="line"></span><br><span class="line">如样例所示: s = <span class="string">"aaabbaaac"</span></span><br><span class="line">所有碎片的平均长度 = (<span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span>) / <span class="number">4</span> = <span class="number">2.25</span></span><br><span class="line"></span><br><span class="line">输入例子<span class="number">1</span>:</span><br><span class="line">aaabbaaac</span><br><span class="line"></span><br><span class="line">输出例子<span class="number">1</span>:</span><br><span class="line"><span class="number">2.25</span></span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = str(input())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findS</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    sum=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i]!=s[i+<span class="number">1</span>]:</span><br><span class="line">            sum+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(s)/sum</span><br><span class="line">print(<span class="string">'%.2f'</span>%findS(s))</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong>很简单的题目，就注意格式化的时候，我一开始用round，报错3.50要求不能3.5，于是用了%.2f</p><hr><p>##重排数列</p><p>小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。<br>牛博士给小易出了一个难题:<br>对数列A进行重新排列,使数列A满足所有的A[i] * A<a href="1 ≤ i ≤ N - 1">i + 1</a>都是4的倍数。<br>小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入描述:</span></span><br><span class="line"><span class="comment">#输入的第一行为数列的个数t(1 ≤ t ≤ 10),</span></span><br><span class="line"><span class="comment">#接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)</span></span><br><span class="line"><span class="comment">#第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出描述:</span></span><br><span class="line"><span class="comment">#对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。</span></span><br><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="comment">#输入</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure></p><p><strong>MySolution</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = int(input())</span><br><span class="line">resultArr = []</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = [int(y) <span class="keyword">for</span> y <span class="keyword">in</span> str(input()).split(<span class="string">' '</span>)]</span><br><span class="line">    dic[n] = arr</span><br><span class="line">    arr = [int(x%<span class="number">4</span>) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br><span class="line">    ji = arr.count(<span class="number">1</span>)+arr.count(<span class="number">3</span>)<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 有能被2整除的</span></span><br><span class="line">    <span class="keyword">if</span> arr.count(<span class="number">2</span>)&gt;<span class="number">0</span>:</span><br><span class="line">        arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x != <span class="number">2</span>]</span><br><span class="line">        arr.append(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#如果存在能被2整除的，这些数必须紧邻在一起当做一个奇数</span></span><br><span class="line">    <span class="keyword">if</span> float(arr.count(<span class="number">0</span>))&gt;=(len(arr)<span class="number">-1</span>)/<span class="number">2</span>:</span><br><span class="line">        resultArr.append(<span class="string">'Yes'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resultArr.append(<span class="string">'No'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> resultArr:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong> 如果有能被2整除的，那为了满足条件，它们必须紧挨着，那就相当于一个奇数，所以可以删除它们加进来一个奇数，那么数组就只剩下奇数和能被4整除的数了，那么满足被4整除的数插在奇数中间即可，即 n* &gt;= (len(array)-1)/2 或者 大于等于奇数-1，都一样.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;(长期更新)互联网公司校招算法题&lt;/center&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
