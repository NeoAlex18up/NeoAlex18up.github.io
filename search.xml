<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[流畅的python]]></title>
    <url>%2F2017%2F12%2F14%2Fpython%2F</url>
    <content type="text"><![CDATA[python math库Number-theoretic and representation functions math.ceil(x) 上限，返回大于或等于x的最小整数 math.copysign(x,y) 赋值符号,返回x的绝对值，使用y的符号,返回类型为float math.fabs(x) 返回x的绝对值 math.factorial(x) 返回x的阶乘，如果x为非正整数会报错 math.floor(x) 下限，小于或等于x的最大整数 math.fmod(x,y) 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号） math.frexp(x) 返回一个元组(m,n),根据x = m(2*n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了） math.fsum(iterable) 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999 math.gcd(a,b) 返回最大公约数,a,b必须为整数 math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0) 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:1print(math.isclose(1,0.8,rel_tol=0.18)) 输出为False1print(math.isclose(1,0.8,rel_tol=0.2)) 输出为True1print(math.isclose(12,0.8,abs_tol = 10)) 输出为False1print(math.isclose(12,0.8,abs_tol = 11.3)) 输出为True math.isfinite(x) 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number) math.isinf(x) 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN 12345# 正无穷float('inf')# 负无穷float('-inf')-float('inf') math.isnan(x) 判断是否是NAN（not a number） math.ldexp(x,i) 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数 math.modf(x) 分别返回x的小数部分和整数部分，同时带x的符号，例如1print(math.modf(-1.89)) 输出(-0.8899999999999999, -1.0) math.trunc(x) 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数Power and logarithmic functions math.exp(x) 返回e的x方 math.expm1(x) 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确 math.log(x[,base]) 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base), math.log1p(x) 返回值为 log(1+x)/log(e) math.log2(x) 返回值为log(x)/log2,用来代替log(x,2),因为更加精确 math.log10(x) 同理，返回log(x)/log(10) math.pow(x,y) 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan math.sqrt(x) 返回x的平方根Trigonometric functions三角函数 math.acos(x) 返回x的反余弦 arc cosine，把斜率转换成弧度 math.asin(x) 返回x的反正弦 arc sine math.atan(x) 返回x的反正切 arc tangent math.atan2(y,x) 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标 math.cos(x) 返回x的余弦,角度值转为余弦值,cos(0)=1.0 math.sin(x) 返回x的正弦 math.tan(x) 返回x的正切 math.hypot(x,y) 返回欧几里得范数 sqrt(xx + yy) ,也就是点(x,y)到原点的距离 math.degrees(x) 把角度x转为弧度，角度=（弧度/π）*180 math.radians(x) 把弧度x转为角度，弧度= (角度/180)*πothers math.lgamma(x) 返回伽马函数绝对值在x上的自然对数。 filter 函数pyhton 中的 filter函数接收一个函数f和一个序列(python中的序列有：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象，列表和元组的区别主要是：列表可以修改，元组不能)，函数f的作用是对列表中的每一个元素进行条件判断，返回True或False，filter函数最终返回一个迭代器Iterator(在python 2.x中返回一个list)举例：返回1-1000中的所有奇数123456def is_odd(x): return x%2!=0# in python 3.xprint(list(filter(is_odd,range(1,1001))))# in python 2.xprint filter(is_odd,range(1,1001)) 字符串遍历筛选的例子：12345def is_a(x): return x=='a'print(list(filter(is_a,'HaHaHaHa')))Output:['a','a','a','a'] 例如：删除None和空字符串1234def Cal_str(s): return s and len(s.strip())&gt;0filter(Cal_str,["H",None,"","ello"])Output: "[H","ello"] strip strip(rm) 默认删除s字符串中开头、结尾处的rm字符串，当rm为空的时候，默认删除空白（包括’\n’, ‘\r’, ‘\t’, ‘ ‘) s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符 s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符 s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符12345678a = 'Hello world'print(a.strip('He'))print(a.strip('eH'))print(a.strip('el'))Output:llo worldllo worldHello world 由于Python3.x中的filter返回的是一个Iterator，所以不仅仅可以指定为list，也可以set(filter(…)) map 函数python 中的 map函数接收一个函数f和一个序列，f将作用于序列中的每个元素，最终的结果作为Interator返回 如果使用map来实现filter中的例子123456def is_a(x): if x=='a': return xprint(list(map(is_a,"Hahahah")))Output:[None, 'a', None, 'a', None, 'a', None] map最终返回的序列长度是等于原来的序列长度的，filter返回的序列长度是小于等于原来的长度的1234# 使用lambda函数的例子print(list(map(lambda x:x+1,[1,2,3,4,5])))Output:[2,3,4,5,6] 注意！ 当只有一个序列的时候，map和filter都是可以使用的，但是当处理多个序列的时候，只能使用map例如：12345print(list(map(lambda x,y:x+y,[1,4,6],[2,5,8])))Output:[3,9,14]# 相当于zip,然后将zip的结果传给函数,所以map在处理多个序列的时候，无法操作序列长度不一致，对应值类型不同的情况# 例如[1,4,6],[2,5,6,8]或[1,4,6],['a',3,6] reduce 函数注意 在python3中，reduce已经从内置函数中被抛弃了，要使用就要引入1from functools import reduce reduce函数是一个累积运算的过程，其接收一个函数f(x,y)和一个序列（以及一个可选的初始值）,其中函数f的x,y首先代表序列中的第一个和第二个参数，其返回值作为新的x，第三个参数作为新的y，依次运算至结束。例如求和运算：123456789def f(x, y): return x + yprint(list(reduce(f,[1,3,5,7,9])))Process:先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25 如果设置了初始值为100，那么第一次运算就是f(100,1) 再例如，用reduce实现5的阶乘:123print(reduce(lambda x,y:x*y,range(1,6)))Output:120 只举了两个简单的例子，通过函数可以实现更为复杂的操作 lambda 函数lambda作为一个表达式，定义了一个匿名函数定义一个lambda表达式:1234g = lambda x:x+1# 可以这样理解def g(x): return x+1 lambda 常常配合上述的 reduce , map, filter 作为f来使用，可以使得代码大大简化。但是python中的 for..in..if 已经非常强大，lambda并不一定作为首选12# 注意是[]print ([x for x in range(10) if x % 3 == 0]) 总之：ambda 并不会带来程序运行效率的提高，只会使代码更简洁。lambda是为了减少单行函数而存在的 set 集合python的set和其他语言类似，是一个是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。 初始化 12345s0 = set()s1 = set('HelloWorld')s2 = set(['h','e','l','l','o'])s3 = &#123;1,2,3,4,5&#125;# 注意，没有这种操作 set(1,2,3) 简单例子：12345x = set('spam') y = set(['h','a','m']) x,y#输出:(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm'])) 去除list l 中重复元素的例子1234l = [1,2,3,45,55,5,5,5,5]print([x for x in set(l)])输出：[1, 2, 3, 5, 45, 55] 两个集合的数学运算1234567891011a = t | s # t 和 s的并集 b = t &amp; s # t 和 s的交集 c = t – s # 求差集（项在t中，但不在s中） d = t ^ s # 对称差集（项在t或s中，但不会同时出现在二者中） # 当然，也可以麻烦点写成函数的形式print(s.intersection(t), s &amp; t) # 交集print(s.union(t), s | t) # 并集 print(s.difference(t), s - t) # 差集 print(s.symmetric_difference(t), s ^ t) # 对称差集 print(s1.issubset(s2), s1 &lt;= s2) # 子集print(s1.issuperset(s2), s1 &gt;= s2) # 包含 基本方法 12345678910len(s) # 获取集合中的元素的总数s.update([1,2,3]) # 添加多个元素s.add("x") # 添加一个元素s.remove("x") # 去掉一个元素s.discard("x") # 如果集合存在指定元素，则删除该元素c = s.copy() # 复制集合s.pop() # 弹出集合中的一个不确定元素(好像不是等价随机)s.clear() # 删除集合中所有的元素(改变原集合)x in s #测试 x 是否是 s 的成员 x not in s 参考链接链接1链接2 replace 函数replace()方法语法：1str.replace(old, new[, max]) 参数 old – 将被替换的子字符串。 new – 新字符串，用于替换old子字符串。 max – 可选字符串, 替换不超过 max 次 例子123str = "this is string example....wow!!! this is really string";print str.replace("is", "was");print str.replace("is", "was", 3); 输出如下12thwas was string example....wow!!! thwas was really stringthwas was string example....wow!!! thwas is really string]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode]]></title>
    <url>%2F2017%2F12%2F13%2Fleetcode%2F</url>
    <content type="text"><![CDATA[(Array)Two sum**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.** Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解） Sample solution:123456789def twoSum(self, nums, target): if len(nums) &lt;= 1: return False buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i 思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index] (Array)Reverse IntegerQ:Given a 32-bit signed integer, reverse digits of an integer.Example 1:12Input: 123Output: 321 Example 2:12Input: -123Output: -321 Example 3:12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. My Answer:12345678910111213141516171819class Solution: def reverse(self, nums): if len(str(nums))&gt;0 and nums != 0 and nums &lt;= math.pow(2,31): nums = str(nums) newStr = '' # len(nums)-1 to -1 , -1 not included , interval is -1 for i in range(len(nums)-1,-1,-1): newStr = newStr + nums[i] print(newStr) while newStr[0] == '0': newStr= newStr[1:] if newStr[-1]=='-': newStr='-'+newStr[:len(newStr)-1] if math.fabs(int(newStr)) &gt;= math.pow(2,31): return 0 else: return(int(newStr)) else: return 0 思路：主要注意几点1.32位有符号整数范围判断2.逆序以后0的处理3.切片时注意索引是否会超范围，也就是只输入0的情况4.对于是否为负的处理 (Array)Palindrome Number判断是否是回文数字注意1.负数不为回文数2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性 Mysolution:123456789101112131415class Solution: def isPalindrome(self, nums): if nums &lt; 0: return False if nums&lt; 10: return True else: length = 1 while math.pow(10,length) &lt;= nums: length+=1 for i in range(math.ceil(length/2)): status = math.isclose((math.floor(nums/math.pow(10,i))%10),(math.floor(nums/math.pow(10,length-i-1))%10),abs_tol = 0.5) if status == False: return status return True Hint: 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。 (Array)Non-decreasing Array非下降数组Q:Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).Example 1:1234567Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 123Input: [4,2,1]Output: FalseExplanation: You can't get a non-decreasing array by modify at most one element. Note:The n belongs to [1, 10,000]. 题意:给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。 Mysolution: 123456789101112class Solution: def checkPossibility(self, nums): num1 = nums.copy() num2 = nums.copy() if len(nums)==1: return True for i in range(len(nums)-1): if nums[i]&gt;nums[i+1]: num1[i] = num1[i+1] num2[i+1] = num2[i] break return num1==sorted(num1) or num2==sorted(num2) 借鉴了Discuss里 -Yangshun的思路:First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting. (Array)k-diff Pairs in an ArrayQ:Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.Example 1:1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2:123Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3:123Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). 注意1.(1,3),(3,1)属于同一个数值对2.k为负的时候返回03.注意处理k=0的情况4.不要使用循环嵌套，必超时 Mysolution 1234567# 精简版class Solution: def findPairs(self, nums, k): if k&lt;0:return 0 #if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums)))) if k==0:return sum(v&gt;1 for v in collections.Counter(nums).values()) return len(set(sorted(nums)) &amp; set(map(lambda x:x+k,nums))) 12345678910# 这样写会好理解一些class Solution: def findPairs(self, nums, k): if k&lt;0:return 0 if k==0:return sum(v&gt;1 for v in collections.Counter(nums).values()) #nums = list(filter(lambda x:nums.count(x)&gt;1,nums)) #return len(set(nums)) nums = set(sorted(nums)) nums1 = set(map(lambda x:x+k,nums)) return len(nums &amp; nums1) 思路：将数组中每个数+k后与原数组取交集 (Hash Table)Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n.计算小于正整数n的素数的个数 1234567891011121314151617181920def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt; 3: return 0 # 一个长度为n的，值为True的list primes = [True] * n # 前两位置为False 0和1 都不是素数，最小的素数是2 primes[0] = primes[1] = False for i in range(2, int(n ** 0.5) + 1): # 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数 # 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了 if primes[i]: # 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数 # 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了 primes[i * i: n: i] = [False] * len(primes[i * i: n: i]) # 返回剩余的True的个数 return sum(primes) 这个算法实现的是埃拉托斯特尼筛法：算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了） (Array-Medium)Insert Delete GetRandom O(1)Description:Design a data structure that supports all following operations in average O(1) time. 1.insert(val) : Inserts an item val to the set if not already present. 2.remove(val) : Removes an item val from the set if present. 3.getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned. Example：1234567891011121314151617181920212223// Init an empty set.RandomizedSet randomSet = new RandomizedSet();// Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);// Returns false as 2 does not exist in the set.randomSet.remove(2);// Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);// getRandom should return either 1 or 2 randomly.randomSet.getRandom();// Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);// 2 was already in the set, so return false.randomSet.insert(2);// Since 2 is the only number in the set, getRandom always return 2.randomSet.getRandom(); My Solution*12345678910111213141516171819202122232425262728293031323334353637from random import choiceclass RandomizedSet: def __init__(self): """ Initialize your data structure here. """ self.Rset,self.Rlist = set(),[] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val in self.Rset: return False else: self.Rset.add(val) self.Rlist.append(val) return True def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.Rset: self.Rset.remove(val) self.Rlist.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return choice(self.Rlist) 思路:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素再添加一个discuss里用字典和list来实现的代码，更快一些：1234567891011121314151617181920212223class RandomizedSet(object): def __init__(self): self.nums, self.pos = [], &#123;&#125; def insert(self, val): if val not in self.pos: self.nums.append(val) self.pos[val] = len(self.nums) - 1 return True return False def remove(self, val): if val in self.pos: idx, last = self.pos[val], self.nums[-1] self.nums[idx], self.pos[last] = last, idx self.nums.pop(); self.pos.pop(val, 0) return True return False def getRandom(self): return self.nums[random.randint(0, len(self.nums) - 1)] (Array-medium)4Sum(拓展为Nsum问题)DescriptionGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Solution借鉴discuss的思路，很不错1234567891011121314151617181920212223242526272829303132333435class Solution(object): def fourSum(self, nums, target): def Nsum(N,nums,target,result,results): # 特殊情况 if N&gt;len(nums) or target&gt;N*nums[-1] or target&lt;N*nums[0]: return # 高效的2Sum if N == 2: l,r = 0,len(nums)-1 while l &lt; r: if nums[l] + nums[r] == target: # 补充到最终结果 results.append(result + [nums[l], nums[r]]) # 左指针右移，同时右指针左移，因为已经排好序了，一个值不变另一个值变一定不会得到target l += 1 r -= 1 # 解决重复问题 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while r &gt; l and nums[r] == nums[r + 1]: r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 else: # 注意这里的范围，是到len(nums)-N+1,因为最后N个数为最后一组，无须再进行递归 for i in range(len(nums)-N+1): # 结合sorted可解决重复问题 if i==0 or (i&gt;0 and nums[i-1]!=nums[i]): # 递归，将nSum问题降为n-1Sum问题 Nsum(N-1,nums[i+1:],target-nums[i],result+[nums[i]],results) results = [] Nsum(4,sorted(nums),target,[],results) return results 思路：给定一个list和一个target，求所有n个list中的数和为target的不重复组合。本题是4Sum，代码拓展为了nSum问题，主要思路是通过迭代来把问题转换为高效的2Sum问题，即nSum-&gt;n-1Sum-&gt;….-&gt;4Sum-&gt;3Sum-&gt;2Sum,具体细节在代码注释中。 (Hash-Table)Repeated DNA SequencesDescriptionAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.For example,1234Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",Return:["AAAAACCCCC", "CCCCCAAAAA"]. 就是求一个字符串里的所有指定长度的重复子字符串。Mysolutionclass Solution(object): def findRepeatedDnaSequences(self, s): “”” :type s: str :rtype: List[str] “”” if len(s)0: results.append(key) return results1234567891011121314151617**思路** 循环切片判断是否重复，数据结构用的字典，注意的就是range的范围和切片的范围问题。将10替换为N可以变为求一个字符串中长度为N的重复子串。---# Longest Palindromic Substring经典的最大回文子字符串问题样例：``` pythonInput: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路：从左到右依次把每个字符当做中心，然后依次判断两边的字符是否相等，最后取最大的那个就行了，唯一要注意的一点是连续字符的情况，比如 abccbd,这个时候要把cc整体作为一个字符串，这里用了两个位置变量，left和right，每次判断两边的相同字符之前要确定right的值，也就是相同字符的长度。 123456789101112131415161718192021class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ length = len(s) result = '' for i in range(length): right = 1 left = 1 # get the step length while i + right &lt;= length - 1 and s[i + right] == s[i]: right += 1 while ((i -left ) &gt;= 0 and (i + right) &lt;= length - 1 and s[i - left] == s[i + right]): left += 1 right+=1 longest = s[i - left+1:i + right] if len(longest) &gt; len(result): result = longest return result (链表)Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路:就是由两个链表逆序表示的整数的和，没什么思路可言，这里主要考察的是对链表的操作，具体看代码，讲的很通俗易懂。 12345678910111213141516171819202122232425262728class Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ s1 = str(l1.val) s2 = str(l2.val) while l1.next: l1 = l1.next s1 = str(l1.val)+s1 while l2.next: l2 = l2.next s2 = str(l2.val)+s2 result = str(int(s1)+int(s2)) # 头节点 head = ListNode(int(result[-1])) after = head # 这里是对数组的操作，[-2::-1]表示从倒数第二个元素向后-1的取全部，注意这里[-2:0:-1]和[-2::-1]是不同的，前者取到下标为1，因为:左右就是[)的，后者取到数组头 for c in result[-2::-1]: # 新开辟一块内存空间 node = ListNode(int(c)) # 让after.next指向这个内存空间，相当于把两个节点连接起来 after.next = node # after指向这块内存空间，方便下一个节点建立以后after代表这块内存空间去实行指向下一块新的节点的任务 after = node return head (字符串)最大字符不重复子串问题 Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters.Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.给定一个字符串，求其最大子串，要求子串中无重复字符 思路:一开始我使用简单的从左到右每一个字符遍历最大子串，最后一个测试用例超时了，这里discuss里给出了一个特别好的例子： 12345678910111213141516171819202122class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ maxLength = 0 start = 0 usedChar = &#123;&#125; for i in range(len(s)): # start是一个下表，表示这一轮新的字符串的开始下标 # if s[i] in userChar 表示遍历到的当前字符曾经用过，有跟我当前新字符串重复的嫌疑 # start &lt;= userChar[s[i]]就是说我去查查你上次出现的下标，如果是在start以后，也就是说在当前新字符串你已经出现过一次了，那么这次就算重复了 if s[i] in usedChar and start &lt;= usedChar[s[i]]: # 那么这次新字符串的遍历到此结束，start更新为上次这个下标出现的后一位字符，下面会有详细解释 start = usedChar[s[i]]+1 else: maxLength = max(maxLength,i-start+1) # 每次都更新下标 usedChar[s[i]] = i return maxLength 12345678910111213141516**举个例子说明**abczkoz543q从左到右遍历：(used 误拼为 user 了)a -&gt; not in userChar ; max(0,1)=1 ; userChar[a] = 0b -&gt; not in userChar ; max(1,2)=2 ; userChar[b] = 1c -&gt; not in userChar ; max(2,3)=3 ; userChar[c] = 2z -&gt; not in userChar ; max(3,4)=4 ; userChar[z] = 3k -&gt; not in userChar ; max(4,5)=5 ; userChar[k] = 4o -&gt; not in userChar ; max(5,6)=6 ; userChar[b] = 5(到这儿为止，字符串一直是从start=0到当前下标，所以长度为6)z -&gt; in userChar and start &lt; userChar[z]在这里z在下标为3的时候出现过的，而当前字符串是从下标为0开始的，所以这个字符串到此为止了，它贡献了maxLength=6然后更新start为3+1，也就是从z后面的k作为下一个字符串的开始下标这里就要从第二个开始继续遍历了，因为没必要从b开始再遍历，因为b也肯定会遍历第一个z然后遍历到第二个z，它形成的最大子串其实是a形成的最大子串的子串，即 bczko 属于 abzko所以直接从z的下一个元素，也就是k开始作为start即可，同时这里用到了字典，也降低了时间复杂度 (分治)两个数组的中位数 Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).限制时间复杂度是O(log(m+n))Example1234nums1 = [1, 3]nums2 = [2]The median is 2.0 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 思路:非常简单的一道题目，先用+连起来，sorted一下，如果是偶数就输出中间两个的均值，如果是奇数长度就输出中间那个值。123456789101112class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ l = sorted(nums1+nums2) if len(l)%2==0: return (l[int(len(l)/2)] + l[int(len(l)/2-1)])/2 else: return int(l[int((len(l)-1)/2)]) 但是其实这个复杂度是O(m+n),这种做法的思想基于下面这种做法一样，而且应该花的时间更长，是最优化最差也是最简单的做法：依次遍历两个数组，每次取最小那个，直到遍历到第i个，这个i就是我们要的中位数或中间两个数，时间复杂度为O(m+n)有更好的做法：分治思路是分治常用的“割”，关键点是一条线割开两个数组，使得左边部分全部小于右边部分，这样就可以确定虚拟数组（两个数组合并排序）的前k个值了，妙啊妙啊。这是O(min(m,n))的做法(感觉不够简练)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def findMedianSortedArrays(self, nums1, nums2): if len(nums1)+len(nums2)&lt;=10: l = sorted(nums1 + nums2) if len(l) % 2 == 0: return (float(l[int(len(l) / 2)]) + float(l[int(len(l) / 2 - 1)])) / 2 else: return int(l[int((len(l) - 1) / 2)]) if len(nums1)&lt;len(nums2): long = nums2 short = nums1 else: long = nums1 short = nums2 if (len(long)+len(short))%2!=0: # 前面找k个数 k = ((len(nums1)+len(nums2))-1)/2 k1 = 0 k2 = k - 2 while ((k2 + 1 &lt;= len(long) - 1 and short[k1] &gt; long[k2 + 1]) or ( k1 + 1 &lt;= len(short) - 1 and long[k2] &gt; short[k1 + 1])): if short[k1]&gt;long[k2+1]: k1-=1 k2 = k-k1-2 else: k1+=1 k2 = k-k1-2 if k1 + 1 &lt;= len(short) - 1: return min(short[k1 + 1], long[k2 + 1]) else: return long[k2 + 1] else: k = (len(nums1)+len(nums2))/2 -1 # 割少的那个尾巴，注意下标 k1 = 0 k2 = k-2 while((k2+1&lt;= len(long)-1 and short[k1]&gt;long[k2+1]) or (k1+1 &lt;= len(short)-1 and long[k2]&gt;short[k1+1])): if short[k1]&gt;long[k2+1]: k1-=1 k2 = k-k1-2 else: k1+=1 k2 = k-k1-2 compareL = [] count=0 while k1+1&lt;=len(short)-1 and count &lt;2: compareL.append(short[k1+1]) k1+=1 count+=1 count=0 while k2+1&lt;=len(long)-1 and count &lt;2: compareL.append(long[k2+1]) k2+=1 count+=1 x1 = min(compareL) compareL.remove(x1) x2 = min(compareL) return (float(x1)+float(x2))/2 可以加个二分查找就变为了O(log(min(m,n))),有空再更新吧 3Sum问题第二次重写Nsum问题，花了一个小时调试边界值，虽然基本思想没忘，但是对细节的处理很差，后面写上注意事项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt; 3: return [] result = [] def Nsum(N, L, subResult, target): # 这种写法的复杂度是nlog(n),超时了，改写为排序数组的2Sum写法 # if N == 2: # sumDict = &#123;&#125; # for i in L: # if i not in sumDict: # sumDict[target - i] = i # else: # # 这里用了一个sorted来解决重复问题，不知道有没有更好的办法 # if sorted(subResult+[target-i,i]) not in result: # print subResult+[target-i,i] # result.append(sorted(subResult+[target-i,i])) # return if N==2: l,r = 0,len(L)-1 while r&gt;l: if L[l]+L[r] == target: result.append(subResult+[L[r],L[l]]) while l&lt;r and L[l] == L[l+1]: l+=1 while l&lt;r and L[r] == L[r-1]: r-=1 r-=1 l+=1 elif L[l]+L[r] &gt; target: r-=1 elif L[l]+L[r] &lt; target: l+=1 else: for i in range(len(L)-N+1): # 每次跳过重复字符 # while i&gt;1 and i&lt;len(L)-1 and L[i]==L[i-1]: # i+=1 if i == 0 or (i &gt; 0 and L[i - 1] != L[i]): Nsum(N - 1, L[i + 1:], subResult + [L[i]], target - L[i]) Nsum(3,sorted(nums),[],0) return result 1：思路依然是递归的将Nsum问题转化为2Sum问题，这里2Sum因为要找的值是不用管下标的，所以可以将数组排好序，这样可以将2Sum问题的时间复杂度降为O(n),而找两个下标的2Sum问题的复杂度是O(nlogN),我一开始将两者弄混了，所以一开始用的找下标的那种方法，然后就超时了2：注意2Sum问题的时候，指针移动的时候，要先跳过所以重复值，加上l1 and i&lt;len(L)-1 and L[i]==L[i-1]:**如果用这种方法来去掉遍历时候的重复值，会出现一些问题，比如[0,0,0,0,0]，虽然跳过了0，但是最后一个0还是会进，这样就会出现输出为[[0,0,0],[0,0,0]]的情况，所以用if可以防止这种情况，只要和前面重复都不进。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监督学习 半监督学习 非监督学习 强化学习]]></title>
    <url>%2F2017%2F11%2F29%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[监督学习 监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同） –李航《统计学习方法》 监督学习通常有标注好的训练集，通过这份训练集可以根据某个评价函数训练出最优的模型，从而对于每一个输入，该模型都能够在当前的评价体系下给出一个相对较优的输出。 特点： 有标注好的训练样本 有输入有输出 通常的任务为分类和回归以及标注 常用的监督学习算法 K近邻算法（KNN） 决策树 （Decision Tree） 朴素贝叶斯（Naive Bayesian） 逻辑回归（Logistic Regression） 这里只罗列了几种最基础的算法，通常在实际应用或数据挖掘比赛中人们会采用更为复杂的集成算法。 非监督学习非监督学习没有任何训练样本，直接对数据进行建模，举个例子来说，数据中有大量的地理位置信息比如经纬度，就可以对经纬度进行无监督学习，把地理位置相近的分在一起，这在无监督学习中叫做聚类 特点： 没有训练样本 主要任务是聚类 半监督学习半监督学习就和它的名字一样，同时具备监督学习和非监督学习的特征和方法，它的数据中有标注好的训练样本，也有没有标注的样本。举个半监督学习的例子： 图中有两个标注好的训练样本，绿色的是没有标注的样本，如果按照监督学习的方法，例如SVM模型会按照左边所示来进行分类，然而实际的数据情况如右图所示，所以实际上应该按照右图所示进行划分，这也就是半监督学习的基本原理：想办法如何同时利用标注好的数据和没有标注的数据。 特点： 既有标注好的训练样本也有未标注的样本 强化学习首先上一个很普遍的用来描述强化学习的图片： 解释：训练实体(Agent)不断地采取行动(action), 之后转到下一个状态(State), 并且获得一个回报(reward), 从而进一步更新训练实体Agent. 就像要训练小老鼠走出迷宫, 你可以在迷宫的几个关键地点放上奶酪, 这些奶酪就是算法中的回报(reward)了, 剩下你只要坐着等小老鼠走出迷宫啦: 再举个例子： 假设1:你是第一次撩妹。那么你会去求教他人，逛各种论坛，总之收集大量相关知识。这个过程就是experience data。利用离线数据来train一个model。 假设2:过去你有很多撩妹经验。你似乎又发现总是按照套路来并不能成功。嗯，经典的探索与利用问题，于是你尝试了其他方法，你发现获得了更好的效果。嗯，more optimal policy 将上述过程对应到RL中：action：你的行为state：你观察到的妹子的状态reward：妹子的反应：开心or不开心至此，一个RL的基本模型已经建立。 参考链接 https://www.zhihu.com/question/31140846/answer/94703351 http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/ https://www.zhihu.com/question/31140846]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F1970%2F01%2F01%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[二位数组中的查找题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 My solution:用递归来解，从右下向左上对角线遍历，每次把大矩阵分为左下右上两个小矩阵进行递归，终止条件是target位于对角线或矩阵只剩一行或一列遍历target（矩阵可能行列数不相同）123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self,target, array): def FindTarget(target, array): # 如果只有一行 if len(array) == 1: if target in array[0]: return True else: return False if len(array) &gt;= 2: # 如果只有一列 if len(array[0]) == 1 and len(array[1]) == 1: if target in [x[0] for x in array]: return True else: return False # 其它情况 else: height = len(array) width = len(array[0]) while (height &gt; 0 and width &gt; 0): v = array[height - 1][width - 1] height -= 1 width -= 1 if v == target: return True if v &gt; target and height!=0: else: remain1 = [x[width + 1:len(array[0])] for x in array[:height+1]] remain2 = [x[:width + 1] for x in array[height + 1:len(array)]] return (FindTarget(target, remain1)) or (FindTarget(target, remain2)) result = False result = FindTarget(target, array) return result 简单做法：从左下开始遍历，比target大就往上，比target小就往下（妈的，看完很气，还特么辛苦写了个递归，这个简单做法太简单就不写了，╭(╯^╰)╮） 从尾到头打印列表1234567891011class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here # write code here l = [] head = listNode while head: l.insert(0, head.val) head = head.next return l 很简单，注意是while head 不是 while head.next 旋转数组的最小数字题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。思路就是一个数组，把从后面切片放到前面来，让找最小数字，最简单的做法是直接min()函数，但是耗时我的做法是使用递归，如果数组中间的数比开头的小，那么说明最小的数在这个切片里，不然就在后半切片里12345678910111213def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray)==0: return 0 def findMin(array): if len(array)&lt;5: return min(array) else: if array[int(len(array)/2)]&gt;array[0]: return findMin(array[int(len(array)/2):]) if array[int(len(array)/2)]&lt;array[0]: return findMin(array[:int(len(array)/2)+1]) return findMin(rotateArray) 再优化一点就是从左到右找，找到下一个比当前的小了说明下一个就是最小值 输出斐波那契数列第n个数递归做法12345678910def Fibonacci(n): # write code here def getN(n): if n == 0: return 0 if n == 1 or n==2: return 1 else: return getN(n - 1) + getN(n - 2) return getN(n) 数组做法def Fibonacci(self, n): a = [0,1,1] if n]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F1970%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[#二叉树的相关概念一 特殊的二叉树及其特点1.斜树2.满二叉树3.完全二叉树二 二叉树性质1.一般二叉树性质2.完全二叉树性质三 二叉树遍历1.前序遍历2.中序遍历3.后序遍历四 二叉树的建立 点击查看二叉树相关概念]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各公司校招算法题]]></title>
    <url>%2F1970%2F01%2F01%2F%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[网易2018校园招聘编程题真题魔法币小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。123456789101112#输入描述:输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。#输出描述:输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符'1'和'2'。#输入例子1:10#输出例子1:122 MySolution12345678910111213141516171819n = int(input()) arr=[]def getStr(n): if n==0: return if n%2!=0: # 奇数 arr.append(1) return getStr(int((n-1)/2)) if n%2==0: # 偶数 arr.append(2) return getStr(int((n-2)/2))getStr(n)arr.reverse()finalStr=''for x in arr: finalStr += str(x)print(finalStr) 思路 递归，如果最终结果是偶数，那么上一步一定用了机器2，奇数机器1同理 ##”相反数“”为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.123456789101112#输入描述:输入包括一个整数n,(1 ≤ n ≤ 10^5)#输出描述:输出一个整数,表示n的相反数#输入例子1:1325#输出例子1:6556 MySolution12345678n = int(input())arr = [x for x in str(n)]arr.reverse()finalNumber = ''for x in arr: finalNumber+=xfinalNumber = int(finalNumber)print (finalNumber + n) 思路：很简单 ##字符串碎片一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。123456789101112131415输入描述:输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母('a'-'z')输出描述:输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。如样例所示: s = "aaabbaaac"所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25输入例子1:aaabbaaac输出例子1:2.25 MySolution12345678910s = str(input())def findS(s): if len(s)==1: return 1.0 sum=1 for i in range(len(s)-1): if s[i]!=s[i+1]: sum+=1 return len(s)/sumprint('%.2f'%findS(s)) 思路：很简单的题目，就注意格式化的时候，我一开始用round，报错3.50要求不能3.5，于是用了%.2f ##重排数列 小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。牛博士给小易出了一个难题:对数列A进行重新排列,使数列A满足所有的A[i] * Ai + 1都是4的倍数。小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。123456789101112131415161718#输入描述:#输入的第一行为数列的个数t(1 ≤ t ≤ 10),#接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)#第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)#输出描述:#对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。#示例1#输入231 10 10041 2 3 4#输出YesNo MySolution1234567891011121314151617181920s = int(input())resultArr = []dic = &#123;&#125;for i in range(s): n = int(input()) arr = [int(y) for y in str(input()).split(' ')] dic[n] = arr arr = [int(x%4) for x in arr] ji = arr.count(1)+arr.count(3)-1 # 有能被2整除的 if arr.count(2)&gt;0: arr = [x for x in arr if x != 2] arr.append(1) #如果存在能被2整除的，这些数必须紧邻在一起当做一个奇数 if float(arr.count(0))&gt;=(len(arr)-1)/2: resultArr.append('Yes') else: resultArr.append('No')for x in resultArr: print(x) 思路： 如果有能被2整除的，那为了满足条件，它们必须紧挨着，那就相当于一个奇数，所以可以删除它们加进来一个奇数，那么数组就只剩下奇数和能被4整除的数了，那么满足被4整除的数插在奇数中间即可，即 n* &gt;= (len(array)-1)/2 或者 大于等于奇数-1，都一样.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
