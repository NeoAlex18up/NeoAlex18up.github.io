<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017 CCF 大数据竞赛top4%]]></title>
    <url>%2F2088%2F01%2F20%2F2017CCF%2F</url>
    <content type="text"><![CDATA[2017 CCF 大数据竞赛思路及源码分享源码见我的Github 比赛：蚂蚁金服：精准室内定位**，线下赛最终经过作弊筛选后是前100，共有2845支队伍，因为当时和小伙伴都不太会MapReduce，加上还有两个周期末考试了然而我为了比赛完全没有复习，所以复赛就弃了。 1.题目给出用户在商场使用手机支付时所采集到的信息，包括用户信息，店铺信息，商场信息等，要求预测给出上述信息后精准预测用户所在店铺。具体给出的数据表可以点击这里来看。 2.大致分析与思路虽然给出了比较多的信息，包括很多的用户信息和商店类别之类的看似有用的信息，但是做过这个比赛的都知道，其实是一个Wifi定位的问题，当然其他的信息经过正确的特征提取也会给模型带来增益，但是绝大程度上的精确度都是由wifi信息来提供的。所以，如何有效的提取wifi信息，去除其中的噪音，构造与wifi信息相关的特征，就是比赛的关键。 3.具体做法1.数据预处理 删除公共wifi，因为本题中给出了mall信息，当两个mall距离较远的情况下，同一个wifiId在这两个mall或多个mall都出现过的话，那么就可以判定这个wifiId是公共wifi或者是个人热点。 训练集和测试集wifi取交集，因为对于wifi指纹或我们后来构造的wifi特征来说，只在train中出现过或只在test中出现过的wifi都是无用的，甚至可能是噪音。 离群值的去除，没发现有什么离群点，部分wifi强度值有缺失，这里没有进行处理，因为模型对缺失值自动处理的效果比较好2.经纬度信息给了两种经纬度信息，一种是店铺经纬度（固定值），一种是买家付款时的经纬度，两种经纬度理论上差距应该很小，实际部分差距很大 通过对精度的调整做了一个小的离散化处理 欧氏距离特征 曼哈顿距离特征 经纬度聚类（效果一般）3.时间特征的处理 提取饭点特征 提取早晨和深夜指示特征，因为这两种店可能比较固定4.用户特征 用户购买力 用户常去商店这里的用户特征是个坑，奥斯卡之夜也有人演过这一出，用户特征的提取会使得本地验证的分数提高不少，但是实际上可能是个噪音，因为测试集里的用户更换了绝大多数，记得好像只有不到1/5之一的旧用户吧，但是在训练集里用户特征会占很高的重要性，所以在将来会出现一些预测上的偏差，它们是要负责任的。5.Wifi特征wifi特征是最主要的部分，这里我们主要构建了如下的wifi特征(1)当前用户连接到的最强wifi转换成规则的话其实是一个极大似然估计，举个例子来说，当我能搜索到的最强wifi是wifi0的时候，在历史上最强wifi是wifi0的时候有80个人在A店铺，5个人在B店铺，10个人在C店铺，那么我最大可能当前在A店铺。这个特征算是一个比较强的特征了。(2)wifi出现的次数搜索到的wifi数，wifi历史计数(3)店铺wifi指纹根据每个店铺历史上出现过的wifi和强度建立wifi强度指纹库，取每个wifi出现过的所有值得中位数作为最终指纹值，比对当前强度wifi和指纹库(4)商场wifi原点根据整个商场历史上出现过的wifi和强度（统计频率，只取出现频率前50的wiif）建立一个原点wiif，计算每条数据wiif的wifi序列到wifi原点的欧氏距离(5)高频wifi强度特征也是先统计所有wifi出现过的次数，选其中出现频率高的wifi，每一个wifi及其强度作为一个特征，效果较好。后处理除了特征以外，还用了一些简单的规则来对预测数据进行后处理，相对于模型预测来说，后处理可处理的数据很少，但是相对于模型来说更加准确。 wiif强度序列完全相同 当前连接的wifi在历史上所在店铺的极大似然其实在作比赛的时候远远试了比这些更多的特征，但是因为效果不好都去掉了，最后提交模型一共使用了以上特征。4.数据集划分因为这是个时间相关的预测问题，所以应该和大多数人一样，最终我选取了最后一个周进行训练，特征提取是在整个训练集上进行的5.模型最开始我们使用了xgb的多分类模型，分mall进行预测，效果一般，然后转而使用二分类实现多分类，依然分mall进行预测，提升显著。具体做法是使用N个二分类器，分别对每个mall的每个店铺进行二分类得到一个二分类器，然后对数据进行预测，这样对于每一个二分类器都可以得到一个预测概率值，选取其中预测最大的概率值对应的店铺作为最终分类结果。 样本 分类器1 分类器2 1 0.12 0.131 2 0.13 0.03 3 0.94 0.001 大概就是表格里这种（值是我瞎写的）这样做的好处还有一个是模型融合的时候会很快捷和高效，直接将模型概率加权相加即可模型融合:最后我们取了 0.65xgb + 0.35lgb 加权融合 就写这么多，比赛过去两个月了好多东西都忘了，以后想到再补充。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-JDD京东金融算法大赛15th解决方案]]></title>
    <url>%2F2088%2F01%2F20%2F2017JDD%2F</url>
    <content type="text"><![CDATA[JDD-2017JDD-2017 京东金融大数据竞赛-销量预测-15th解决方案 比赛说明通过竞赛数据中店铺过往的销售记录，商品信息，商品评价，以及广告费用等信息来建立预测模型，预测店铺未来90天内的销售额。训练数据包含2017-04-30日之前270天之内若干店铺的每日订单量、销售额、顾客数、评价数、广告费用等数据，下架时间在2017-04-30之后或者未下架的商品数据，以及这些店铺2016年6月-2017年1月每月末后90天内的销售额。 数据处理特殊的数据主要包含以下几部分 活动促销：比如双11和618 特殊月份：比如过年前后 店铺刷单：有些店铺平时销量很低，会有几天莫名其妙的很高 下降商品：某些店铺会在短时间内下架大量的商品 数据集划分我们试过非常多的方案，最终选择了使用一个月作为训练区间，该月的前三个月作为特征提取区间 特征商品特征 在售总商品数 平均每个商品的订单量 平均每个商品的实际销量 平均每个商品的退货订单数 未售商品占总商品的比例 订单特征 总销售金额 平均每个订单销售金额 总优惠金额 平均每笔订单优惠金额 总优惠金额占总销售金额比 总订单量 总退货订单量 总实际订单量 总退货订单金额 退货金额占总销售额金额的比 总实际销售金额 平均每笔订单实际销售金额 总顾客数 平均每个顾客的订单量 平均每个顾客的购买金额 平均每个顾客的退货订单数 平均每个顾客的退货金额 总优惠笔数 总优惠金额占总退货金额比例 平均每笔订单总优惠金额占总退货金额比例 平均每笔优惠金额 平均销售金额增长率（每个月和前一个月算增长率，所有增长率取平均） 平均订单量增长率 平均退货订单增长率 平均退货金额增长率 评价特征（取平均的时候是按照有效评论日期取平均） 总好评数 总中评数 总差评数 总评论数 平均好评数 平均中评数 平均差评数 好评率 差评率 中评率 平均好评率增长率 交叉特征 平均每个月的充值广告费用占总销售金额比 平均每个月的充值广告费用占实际销售金额比 平均每个订单的好评率 平均每个订单的差评率 平均每个订单的好评数 平均每个订单的差评数 销售额和下架特征 总销售额 当月销售额 前一个月总销售金额 前两个月总销售金额 前三个月总销售金额 前一个周总销售金额 前两个周总销售金额 前三个周总销售金额 前一个月下架商品数 前两个月下架商品数 前三个月下架商品数 最近一周下架商品数 一开始加的特征比较多，因为效果还不错吧，所以也没有根据线上去判断一下哪些特征是否有用，而且这个比赛想构建一个比较稳定的线下验证是非常困难的，因为销量波动还是比较大的，所以更多的时候是以线上来验证我的一些想法。根据特征的重要性来看，跟销售金额有关的特征比较强一些，某些特征重要性非常低但是我也没删除。 后处理因为某些店铺的销量波动实在是太大了，所以除了预测销量的模型之外，我还尝试构建了一个二分类模型，主要来区别销量比较平稳和销量波动很大的商铺，所以最终的模型为：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow]]></title>
    <url>%2F2088%2F01%2F20%2FTensorflow%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用flags定义命令行参数flag在TensorFlow中用于定义命令行参数参考链接1234567891011121314151617import tensorflow as tf#第一个是参数名称，第二个参数是默认值，第三个是参数描述tf.app.flags.DEFINE_string('str_name', 'def_v_1',"descrip1")tf.app.flags.DEFINE_integer('int_name', 10,"descript2")tf.app.flags.DEFINE_boolean('bool_name', False, "descript3")FLAGS = tf.app.flags.FLAGS#必须带参数，否则：'TypeError: main() takes no arguments (1 given)'; main的参数名随意定义，无要求def main(_): print(FLAGS.str_name) print(FLAGS.int_name) print(FLAGS.bool_name)if __name__ == '__main__': tf.app.run() #执行main函数 执行结果12345678[root@AliHPC-G41-211 test]# python tt.pydef_v_110False[root@AliHPC-G41-211 test]# python tt.py --str_name test_str --int_name 99 --bool_name Truetest_str99True Tensorflow实现线性回归(本习题也是港大深度学习的第一次作业) 线性回归原理单变量线性回归 因为是线性回归，所以学习到的函数为线性函数，即直线函数 因为是单变量，因此只有一个x我们能够给出单变量线性回归的模型：我们常称x为feature，h(x)为hypothesis（假设函数）Cost Function：对假设的函数进行评价，Cost Function越小的函数，说明对训练数据拟合的越好。下面给出costFunction公式：如果theta0和theta1都不固定，则theta0、theta1、J的函数为：注意如果是线性回归，则cost function一定是碗状的，即只有一个最小点。 损失函数最优化：梯度下降下面给出梯度下降算法：特点a)初始点不同，获得的最小值也不同，因此梯度下降求得的只是局部最小值；b)越接近最小值，下降速度越慢。问题1：如果和初始值就在local minimum的位置，则、会如何变化？答案：因为、已经在local minimum位置，所以derivative（导数）肯定是0，因此、不会改变。问题2：如果取到一个正确的值，则cost function应该会越来越小。那么，怎么取值？答案：随时观察值，如果cost function变小了，则OK；反之，则再取一个更小的值。 注意：下降的步伐大小非常重要，因为，如果太小，则找到函数最小值的速度就很慢；如果太大，则可能会出现overshoot the minimum现象。那既然梯度下降可以求到损失函数的最小值，线性回归又是需要一个最小的损失函数，那么可以将两者进行整合： Feature Scaling此种方法应用于梯度下降，为了加快梯度下降的执行速度。思想：将各个feature的值标准化，使得取值范围大致都在-1&lt;=x&lt;=1之间。常用的方法是Mean Normalization，即,或者[X-mean(X)]/std(X)。 多变量线性回归其假设函数为:损失函数仍然定义为平方损失函数最小化损失函数仍然可以用梯度下降法： 下面给出python实现12345678910111213141516171819202122232425262728293031323334353637383940import tensorflow as tfimport numpy as np# 构造数据集 -2到2 200个点 等差数列x_train = np.linspace(-2, 2, 200)# 构造 系数为2 偏差为4的y 加入一些随机噪音y_train = x_train * 2 + np.ones(len(x_train)) * 4 + np.random.randn(len(x_train)) * 0.02# Tensorflow构造模型# 1.定义输入和输出的占位符 tf中一般是tf.float32X = tf.placeholder('float')Y = tf.placeholder('float')# 2.定义参数变量,初始化为0w = tf.Variable(0.0, name='weights')b = tf.Variable(0.0, name='bias')# 3.定义假设模型的输出,wx+by_pred = tf.multiply(X, w) + b# 4.定义损失函数,这里是平方损失函数loss = tf.square(y_pred - Y)# 5.定义优化函数来最小化损失函数,学习率，要最小化的损失函数optimizer = tf.train.GradientDescentOptimizer(0.001).minimize(loss)# 到这里搭建完了图模型，但是不会产生任何运算结果，因为需要session来驱动sess = tf.Session()# 变量必须要初始化，如果变量有嵌套关系，则必须按顺序初始化sess.run(tf.initialize_all_variables())# 定义迭代次数iteration_nums = 500for i in range(iteration_nums): # 注意这里，要run的是optimizer这个函数，它又用到了loss这个函数，而loss函数又用到了y_pred这个结果，所以追溯向前，一共 # 用到了 X,Y 这两个被占位符声明的输入与输出以及w,b这两个变量，而参数变量正是我们要优化的目标 sess.run(optimizer, feed_dict=&#123;X: x_train, Y: y_train&#125;)# 学习完成后，变量w,b被重新赋值，打印w和bprint(sess.run(w))print(sess.run(b)) 最终的输出为122.00243.9702 与预期输出相符，注意我在一开始设置步长为0.01的时候发散掉了，最后w和b都是nan，所以合理的调参是必不可少的下面绘制一下样本点和回归函数的图像：12345678# 注意上面y_pred没有实际的值y_pred = sess.run(y_pred,&#123;X:x_train&#125;)plt.xlabel('Population of City in 10,000s')plt.ylabel('Profit in $10,000s')plt.plot(x_train,y_train,marker='x',lw=0,color='r',label='Training data')plt.plot(x_train,y_pred,linestyle='-',color='b',label='Linear regression line')plt.legend()plt.show() 再构造一些测试数据，用学习到的模型进行预测12345678910111213# 1.定义测试数据X_test = tf.placeholder('float')# 2.定义相关参数w = sess.run(w)b = sess.run(b)# 3.定义预测predict = tf.multiply(w,X_test)+b# 4.得到预测结果sess = tf.Session()sess.run(tf.initialize_all_variables())test_pred = sess.run(predict,&#123;X_test:x_test&#125;)print(test_pred) 绘制测试集上的回归函数图像：可以看到拟合的效果还是不错的。 这是freedom098博客上的一点关于梯度下降的一点儿感悟：1、梯度下降法分为批量梯度下降和随机梯度下降法，第一种是所有数据都参与运算后，计算误差函数，根据此误差函数来更新模型参数，实际调试发现，如果定义误差函数为平方误差函数，这个值很快就会飞掉，原因是，批量平方误差都加起来可能会很大，如果此时学习率比较高，那么调整就会过，造成模型参数向一个方向大幅调整，造成最终结果发散。所以这个时候要降低学习率，让参数变化不要太快。2、随机梯度下降法，每次用一个数据计算误差函数，然后更新模型参数，这个方法有可能会造成结果出现震荡，而且麻烦的是由于要一个个取出数据参与运算，而不是像批量计算那样采用了广播或者向量化乘法的机制，收敛会慢一些。但是速度要比使用批量梯度下降要快，原因是不需要每次计算全部数据的梯度了。比较折中的办法是mini-batch，也就是每次选用一小部分数据做梯度下降，目前这也是最为常用的方法了。3、epoch概念：所有样本集过完一轮，就是一个epoch，很明显，如果是严格的随机梯度下降法，一个epoch内更新了样本个数这么多次参数，而批量法只更新了一次。 tf.multiply和tf.matmul区别其中tf.multiply是点乘，tf.matmul是矩阵乘法，点乘要求维度相同，结果是每个对应的元素相乘，矩阵乘法要求MxN NxK,最后得到MxK举个例子:1234567891011A = np.array([[1,2,3],[4,5,6]])B = np.array([[5],[2],[1]])C = np.array([[1,0,-1],[2,-2,0]])print('矩阵A')print(A)print('矩阵B')print(B)print('矩阵A乘以B')print(np.matmul(A,B))print('矩阵A点乘C')print(np.multiply(A,C)) Output12345678910111213矩阵A[[1 2 3] [4 5 6]]矩阵B[[5] [2] [1]]矩阵A乘以B[[12] [36]]矩阵A点乘C[[ 1 0 -3] [ 8 -10 0]] np.dot12345678910111213A = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])B = np.array([[1],[2],[3],[4]])C = np.array([[1],[2],[3],[4]])D = np.array([1,2,3,4,5])E = np.array([1,2,3,4,5])# 当x,y都为一维数组的时候，np.dot表示内积print(np.dot(D,E))#print(np.dot(np.mat(B).T,np.mat(C).T))# 除此之外，表示矩阵乘积print(np.dot(A,C)) 输出12345655[[ 30] [ 70] [110] [150]] 手动实现Logistic参考链接1下面两个图可以看到线性回归和逻辑回归的联系，因为逻辑回归的假设函数的输出是0到1之间的概率，相当于把线性回归的假设函数归一化那现在有一个线性回归模型$ z = \theta^Tx $,要将输出转为y(0,1)，那么就需要将z转为y，如果用单位阶跃函数来表示:由于其不连续，所以用sigmoid函数代替：$ y = \frac{1}{1+e^{-z}} $则其输出为（假设函数）:$ y = \frac{1}{1+e^{-(\theta^Tx)}} $其函数图像为：如果将假设函数进行变形，将theta向量与X矩阵相乘拿出来的话，可以得到：那这也就是对数几率回归，y看成是样本x正例的概率，1-y则为样本x负例的概率，这里将条件概率模型转化为了线性模型:那么接下来要求样本点的联合概率分布，对于每一个样本点来说:那考虑所有样本，由于每个样本点互相独立，因此他们的联合概率分布等于各自的边缘概率分布的积：其对数似然函数为：现在需要使得联合概率分布最大，或者说使得其对数似然函数最大，需要使用梯度下降法来求θ(其损失函数可以说是-1/m * 对数似然函数（联合概率分布）)给出其损失函数并给出从损失函数到偏导的推导: 下面给出其python实现过程：12345678910111213141516171819import numpy as npimport matplotlib.pyplot as plt# 构造数据集x_train = [[1.0, 2.0], [2.0, 1.0], [2.0, 3.0], [3.0, 5.0], [1.0, 3.0], [4.0, 2.0], [7.0, 3.0], [4.0, 5.0], [11.0, 3.0], [8.0, 7.0]]y_train = [1, 1, 0, 1, 1, 0, 0, 1, 0, 1]# 可视化good_index = []bad_index = []for i in range(len(y_train)): if y_train[i]==1: good_index.append(i) else: bad_index.append(i)plt.xlabel('x')plt.ylabel('y')plt.scatter(np.array([x[0] for x in x_train])[good_index],np.array([x[1] for x in x_train])[good_index],marker='o',color='k',label='good')plt.scatter(np.array([x[0] for x in x_train])[bad_index],np.array([x[1] for x in x_train])[bad_index],marker='x',color='g',label='bad')plt.show() 1234567891011121314151617# 初始化变量 由于这里是两维特征 h(θ) = θ0*x0 + θ1*x1 + θ2*x2# 为了构造矩阵相乘，给数据集X添加一列1init_theta = np.array([1,2,1])X = np.array([[1.0]+x for x in x_train])y = np.array(y_train)# 构造假设函数def Objective(theta,X): return 1 / (1 + np.exp(-np.dot(theta.reshape(1,3),X.T)))# 构造损失函数def loss(theta,X,y): pred_y = Objective(theta,X)[0] # 在当前theta下训练集的损失函数值,求原来损失函数的最大，在这里取负号就是最小 lossSum = 0 for i in range(X.shape[0]): lossSum += -y[i]*pred_y[i] + np.log(1+np.exp(pred_y[i])) return lossSum/X.shape[0]print('在初始theta的情况下，训练集的损失函数值为:',loss(init_theta,X,y)) 1在初始theta的情况下，训练集的损失函数值为: 0.71354969579 1234567891011121314# 优化损失函数# 为了寻找最优的theta向量使得损失函数最小，这里使用梯度下降法# 计算当前梯度def Gradient(theta,X,y): grad = [] pred_y = Objective(theta,X)[0] for i in range(X.shape[1]): cur_grad = 0 # 当前梯度跟每一个样本实例都有关系 for j in range(X.shape[0]): cur_grad += (pred_y[j]-y[j]) * X[j][i] grad.append(cur_grad/X.shape[0]) return np.array(grad)print('初始梯度',Gradient(init_theta,X,y)) 1初始梯度 [ 0.39880029 2.39851299 1.09756494] 1234567891011121314151617181920212223242526# 使用梯度下降找到最优参数def logistic(theta,X,y,eta): loss_list = [] minLoss = 1000 minTheta = None # 定义迭代次数 theLoss = 0 iteration_times = 5000 for i in range(iteration_times): # 每一轮迭代更新损失theta向量和损失函数值 theta = theta - eta * Gradient(theta,X,y) theLoss = loss(theta,X,y) if theLoss &lt; minLoss: minLoss = theLoss minTheta = theta loss_list.append(theLoss) return loss_list,minLoss,minThetaloss_list,minLoss,minTheta = logistic(init_theta,X,y,0.01)# 画出收敛曲线的图axis_x = [x for x in range(len(loss_list))]plt.xlabel('iteration times')plt.ylabel('loss function value')plt.plot(axis_x,loss_list,linestyle='-',color='b',label='Convergent curve')plt.legend()plt.show() 交叉熵Corss-entropy和Softmax交叉熵Cross-entropy参考链接 Softmax函数Softmax函数用于多分类或二分类，可以对样本输出的每一个类别给出对应的概率值这里的softmax可以看成是一个激励（activation）函数或者链接（link）函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10个数字类的概率分布。因此，给定一张图片，它对于每一个数字的吻合度可以被softmax函数转换成为一个概率值 Logistic回归：MINIST训练集MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import tensorflow as tfimport numpy as npfrom tensorflow.examples.tutorials.mnist import input_data# 读入数据MNIST = input_data.read_data_sets("data", one_hot=True)# 定义相关超参eta = 0.01batch_size = 128n_epochs = 25# 为输入和输出定义placeholder# 因为每个在MNIST中的像素是28*28 = 784# 所以每一个图像都有784个特征，是一个1x784的张量X = tf.placeholder('float32',[batch_size,784])y = tf.placeholder('float32',[batch_size,10])# 创建要调整的参数变量 weights and bias# 784，10 是因为要输出一个长度为10的结果向量w = tf.Variable(tf.random_normal(shape=[784,10],stddev=0.1), name='weights')b = tf.Variable(tf.zeros([1,10]), name='bias')# 定义假设函数logits = tf.matmul(X,w) + b# 定义损失函数entropy = tf.nn.softmax_cross_entropy_with_logits(logits=logits,labels=y)loss = tf.reduce_mean(entropy)# 梯度下降optimizer = tf.train.GradientDescentOptimizer(learning_rate=eta).minimize(loss)# 初始化变量sess = tf.Session()sess.run(tf.global_variables_initializer())# 这里batch_size是每一次训练多少个样本，这里要算每一轮要训练多少次n_batches = int(MNIST.train.num_examples/batch_size)# 训练多少轮for i in range(n_epochs): for _ in range(n_batches): # 该循环的每个步骤中，我们都会随机抓取训练数据中的batch_size个批处理数据点，然后我们用这些数据点作为参数替换之前的占位符来运行train_step X_batch,Y_batch = MNIST.train.next_batch(batch_size) sess.run([optimizer,loss],&#123;X:X_batch,y:Y_batch&#125;)# 测试模型corrects = 0n_batches = int(MNIST.test.num_examples/batch_size)total_correct_preds = 0for i in range(n_batches): X_batch, Y_batch = MNIST.test.next_batch(batch_size) _,loss_batch,logits_batch = sess.run([optimizer,loss,logits],feed_dict=&#123;X:X_batch,y:Y_batch&#125;) preds = tf.nn.softmax(logits_batch) corrects_preds = tf.equal(tf.argmax(preds,1),tf.argmax(Y_batch,1)) accuracy = tf.reduce_sum(tf.cast(corrects_preds,tf.float32)) total_correct_preds += sess.run(accuracy)print('Accuracy',total_correct_preds/MNIST.test.num_examples) 1&gt;&gt;&gt; Accuracy 0.9077]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2088%2F01%2F05%2Fpython%2F</url>
    <content type="text"><![CDATA[python math库Number-theoretic and representation functions math.ceil(x) 上限，返回大于或等于x的最小整数 math.copysign(x,y) 赋值符号,返回x的绝对值，使用y的符号,返回类型为float math.fabs(x) 返回x的绝对值 math.factorial(x) 返回x的阶乘，如果x为非正整数会报错 math.floor(x) 下限，小于或等于x的最大整数 math.fmod(x,y) 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号） math.frexp(x) 返回一个元组(m,n),根据x = m(2*n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了） math.fsum(iterable) 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999 math.gcd(a,b) 返回最大公约数,a,b必须为整数 math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0) 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:1print(math.isclose(1,0.8,rel_tol=0.18)) 输出为False1print(math.isclose(1,0.8,rel_tol=0.2)) 输出为True1print(math.isclose(12,0.8,abs_tol = 10)) 输出为False1print(math.isclose(12,0.8,abs_tol = 11.3)) 输出为True math.isfinite(x) 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number) math.isinf(x) 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN 12345# 正无穷float('inf')# 负无穷float('-inf')-float('inf') math.isnan(x) 判断是否是NAN（not a number） math.ldexp(x,i) 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数 math.modf(x) 分别返回x的小数部分和整数部分，同时带x的符号，例如1print(math.modf(-1.89)) 输出(-0.8899999999999999, -1.0) math.trunc(x) 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数Power and logarithmic functions math.exp(x) 返回e的x方 math.expm1(x) 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确 math.log(x[,base]) 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base), math.log1p(x) 返回值为 log(1+x)/log(e) math.log2(x) 返回值为log(x)/log2,用来代替log(x,2),因为更加精确 math.log10(x) 同理，返回log(x)/log(10) math.pow(x,y) 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan math.sqrt(x) 返回x的平方根Trigonometric functions三角函数 math.acos(x) 返回x的反余弦 arc cosine，把斜率转换成弧度 math.asin(x) 返回x的反正弦 arc sine math.atan(x) 返回x的反正切 arc tangent math.atan2(y,x) 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标 math.cos(x) 返回x的余弦,角度值转为余弦值,cos(0)=1.0 math.sin(x) 返回x的正弦 math.tan(x) 返回x的正切 math.hypot(x,y) 返回欧几里得范数 sqrt(xx + yy) ,也就是点(x,y)到原点的距离 math.degrees(x) 把角度x转为弧度，角度=（弧度/π）*180 math.radians(x) 把弧度x转为角度，弧度= (角度/180)*πothers math.lgamma(x) 返回伽马函数绝对值在x上的自然对数。 filter 函数pyhton 中的 filter函数接收一个函数f和一个序列(python中的序列有：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象，列表和元组的区别主要是：列表可以修改，元组不能)，函数f的作用是对列表中的每一个元素进行条件判断，返回True或False，filter函数最终返回一个迭代器Iterator(在python 2.x中返回一个list)举例：返回1-1000中的所有奇数123456def is_odd(x): return x%2!=0# in python 3.xprint(list(filter(is_odd,range(1,1001))))# in python 2.xprint filter(is_odd,range(1,1001)) 字符串遍历筛选的例子：12345def is_a(x): return x=='a'print(list(filter(is_a,'HaHaHaHa')))Output:['a','a','a','a'] 例如：删除None和空字符串1234def Cal_str(s): return s and len(s.strip())&gt;0filter(Cal_str,["H",None,"","ello"])Output: "[H","ello"] strip strip(rm) 默认删除s字符串中开头、结尾处的rm字符串，当rm为空的时候，默认删除空白（包括’\n’, ‘\r’, ‘\t’, ‘ ‘) s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符 s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符 s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符12345678a = 'Hello world'print(a.strip('He'))print(a.strip('eH'))print(a.strip('el'))Output:llo worldllo worldHello world 由于Python3.x中的filter返回的是一个Iterator，所以不仅仅可以指定为list，也可以set(filter(…)) map 函数python 中的 map函数接收一个函数f和一个序列，f将作用于序列中的每个元素，最终的结果作为Interator返回 如果使用map来实现filter中的例子123456def is_a(x): if x=='a': return xprint(list(map(is_a,"Hahahah")))Output:[None, 'a', None, 'a', None, 'a', None] map最终返回的序列长度是等于原来的序列长度的，filter返回的序列长度是小于等于原来的长度的1234# 使用lambda函数的例子print(list(map(lambda x:x+1,[1,2,3,4,5])))Output:[2,3,4,5,6] 注意！ 当只有一个序列的时候，map和filter都是可以使用的，但是当处理多个序列的时候，只能使用map例如：12345print(list(map(lambda x,y:x+y,[1,4,6],[2,5,8])))Output:[3,9,14]# 相当于zip,然后将zip的结果传给函数,所以map在处理多个序列的时候，无法操作序列长度不一致，对应值类型不同的情况# 例如[1,4,6],[2,5,6,8]或[1,4,6],['a',3,6] reduce 函数注意 在python3中，reduce已经从内置函数中被抛弃了，要使用就要引入1from functools import reduce reduce函数是一个累积运算的过程，其接收一个函数f(x,y)和一个序列（以及一个可选的初始值）,其中函数f的x,y首先代表序列中的第一个和第二个参数，其返回值作为新的x，第三个参数作为新的y，依次运算至结束。例如求和运算：123456789def f(x, y): return x + yprint(list(reduce(f,[1,3,5,7,9])))Process:先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25 如果设置了初始值为100，那么第一次运算就是f(100,1) 再例如，用reduce实现5的阶乘:123print(reduce(lambda x,y:x*y,range(1,6)))Output:120 只举了两个简单的例子，通过函数可以实现更为复杂的操作 lambda 函数lambda作为一个表达式，定义了一个匿名函数定义一个lambda表达式:1234g = lambda x:x+1# 可以这样理解def g(x): return x+1 lambda 常常配合上述的 reduce , map, filter 作为f来使用，可以使得代码大大简化。但是python中的 for..in..if 已经非常强大，lambda并不一定作为首选12# 注意是[]print ([x for x in range(10) if x % 3 == 0]) 总之：ambda 并不会带来程序运行效率的提高，只会使代码更简洁。lambda是为了减少单行函数而存在的 set 集合python的set和其他语言类似，是一个是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。 初始化 12345s0 = set()s1 = set('HelloWorld')s2 = set(['h','e','l','l','o'])s3 = &#123;1,2,3,4,5&#125;# 注意，没有这种操作 set(1,2,3) 简单例子：12345x = set('spam') y = set(['h','a','m']) x,y#输出:(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm'])) 去除list l 中重复元素的例子1234l = [1,2,3,45,55,5,5,5,5]print([x for x in set(l)])输出：[1, 2, 3, 5, 45, 55] 两个集合的数学运算1234567891011a = t | s # t 和 s的并集 b = t &amp; s # t 和 s的交集 c = t – s # 求差集（项在t中，但不在s中） d = t ^ s # 对称差集（项在t或s中，但不会同时出现在二者中） # 当然，也可以麻烦点写成函数的形式print(s.intersection(t), s &amp; t) # 交集print(s.union(t), s | t) # 并集 print(s.difference(t), s - t) # 差集 print(s.symmetric_difference(t), s ^ t) # 对称差集 print(s1.issubset(s2), s1 &lt;= s2) # 子集print(s1.issuperset(s2), s1 &gt;= s2) # 包含 基本方法 12345678910len(s) # 获取集合中的元素的总数s.update([1,2,3]) # 添加多个元素s.add("x") # 添加一个元素s.remove("x") # 去掉一个元素s.discard("x") # 如果集合存在指定元素，则删除该元素c = s.copy() # 复制集合s.pop() # 弹出集合中的一个不确定元素(好像不是等价随机)s.clear() # 删除集合中所有的元素(改变原集合)x in s #测试 x 是否是 s 的成员 x not in s 参考链接链接1链接2 replace 函数replace()方法语法：1str.replace(old, new[, max]) 参数 old – 将被替换的子字符串。 new – 新字符串，用于替换old子字符串。 max – 可选字符串, 替换不超过 max 次 例子123str = "this is string example....wow!!! this is really string";print str.replace("is", "was");print str.replace("is", "was", 3); 输出如下12thwas was string example....wow!!! thwas was really stringthwas was string example....wow!!! thwas is really string sort sorted reverse reversedsortsort()是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。12345a=[5,4,3,2,1]a.sort()&gt;&gt;&gt; [1, 2, 3, 4, 5]a&gt;&gt;&gt; [1, 2, 3, 4, 5] sortedsorted()是python的内置函数，并不是可变对象(列表、字典)的特有方法，sorted()函数需要一个参数(参数可以是列表、字典、元组、字符串)，无论传递什么参数，都将返回一个以列表为容器的返回值，如果是字典将返回键的列表。123456789101112131415mystring="54321"mytuple=(5,4,3,2,1)mylist=[5,4,3,2,1]sorted(mystring)&gt;&gt;&gt;[1, 2, 3, 4, 5]mystring&gt;&gt;&gt;"54321"sorted(mytuple)&gt;&gt;&gt;[1, 2, 3, 4, 5]sorted(mylist)&gt;&gt;&gt;[1, 2, 3, 4, 5] reverse reversedreverse()与sort的使用方式一样，而reversed()与sorted()的使用方式相同123456789mylist=[5,4,3,2,1]mylist.reverse()mylist&gt;&gt;&gt;[1, 2, 3, 4, 5]for i in reversed(mylist):print i,&gt;&gt;&gt;1 2 3 4 5 通过序列的切片也可以达到“逆转”的效果123456789101112mystring="54321"mytuple=(5,4,3,2,1)mylist=[5,4,3,2,1]mystring[::-1]&gt;&gt;&gt;'12345'mytuple[::-1]&gt;&gt;&gt;(1, 2, 3, 4, 5)mylist[::-1]&gt;&gt;&gt;[1, 2, 3, 4, 5]]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode]]></title>
    <url>%2F2017%2F12%2F13%2Fleetcode%2F</url>
    <content type="text"><![CDATA[(Array)Two sum**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.** Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解） Sample solution:123456789def twoSum(self, nums, target): if len(nums) &lt;= 1: return False buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i 思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index] (Array)Reverse IntegerQ:Given a 32-bit signed integer, reverse digits of an integer.Example 1:12Input: 123Output: 321 Example 2:12Input: -123Output: -321 Example 3:12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. My Answer:12345678910111213141516171819class Solution: def reverse(self, nums): if len(str(nums))&gt;0 and nums != 0 and nums &lt;= math.pow(2,31): nums = str(nums) newStr = '' # len(nums)-1 to -1 , -1 not included , interval is -1 for i in range(len(nums)-1,-1,-1): newStr = newStr + nums[i] print(newStr) while newStr[0] == '0': newStr= newStr[1:] if newStr[-1]=='-': newStr='-'+newStr[:len(newStr)-1] if math.fabs(int(newStr)) &gt;= math.pow(2,31): return 0 else: return(int(newStr)) else: return 0 思路：主要注意几点1.32位有符号整数范围判断2.逆序以后0的处理3.切片时注意索引是否会超范围，也就是只输入0的情况4.对于是否为负的处理 (Array)Palindrome Number判断是否是回文数字注意1.负数不为回文数2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性 Mysolution:123456789101112131415class Solution: def isPalindrome(self, nums): if nums &lt; 0: return False if nums&lt; 10: return True else: length = 1 while math.pow(10,length) &lt;= nums: length+=1 for i in range(math.ceil(length/2)): status = math.isclose((math.floor(nums/math.pow(10,i))%10),(math.floor(nums/math.pow(10,length-i-1))%10),abs_tol = 0.5) if status == False: return status return True Hint: 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。 (Array)Non-decreasing Array非下降数组Q:Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).Example 1:1234567Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 123Input: [4,2,1]Output: FalseExplanation: You can't get a non-decreasing array by modify at most one element. Note:The n belongs to [1, 10,000]. 题意:给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。 Mysolution: 123456789101112class Solution: def checkPossibility(self, nums): num1 = nums.copy() num2 = nums.copy() if len(nums)==1: return True for i in range(len(nums)-1): if nums[i]&gt;nums[i+1]: num1[i] = num1[i+1] num2[i+1] = num2[i] break return num1==sorted(num1) or num2==sorted(num2) 借鉴了Discuss里 -Yangshun的思路:First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting. (Array)k-diff Pairs in an ArrayQ:Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.Example 1:1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2:123Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3:123Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). 注意1.(1,3),(3,1)属于同一个数值对2.k为负的时候返回03.注意处理k=0的情况4.不要使用循环嵌套，必超时 Mysolution 1234567# 精简版class Solution: def findPairs(self, nums, k): if k&lt;0:return 0 #if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums)))) if k==0:return sum(v&gt;1 for v in collections.Counter(nums).values()) return len(set(sorted(nums)) &amp; set(map(lambda x:x+k,nums))) 12345678910# 这样写会好理解一些class Solution: def findPairs(self, nums, k): if k&lt;0:return 0 if k==0:return sum(v&gt;1 for v in collections.Counter(nums).values()) #nums = list(filter(lambda x:nums.count(x)&gt;1,nums)) #return len(set(nums)) nums = set(sorted(nums)) nums1 = set(map(lambda x:x+k,nums)) return len(nums &amp; nums1) 思路：将数组中每个数+k后与原数组取交集 (Hash Table)Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n.计算小于正整数n的素数的个数 1234567891011121314151617181920def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt; 3: return 0 # 一个长度为n的，值为True的list primes = [True] * n # 前两位置为False 0和1 都不是素数，最小的素数是2 primes[0] = primes[1] = False for i in range(2, int(n ** 0.5) + 1): # 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数 # 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了 if primes[i]: # 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数 # 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了 primes[i * i: n: i] = [False] * len(primes[i * i: n: i]) # 返回剩余的True的个数 return sum(primes) 这个算法实现的是埃拉托斯特尼筛法：算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了） (Array-Medium)Insert Delete GetRandom O(1)Description:Design a data structure that supports all following operations in average O(1) time. 1.insert(val) : Inserts an item val to the set if not already present. 2.remove(val) : Removes an item val from the set if present. 3.getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned. Example：1234567891011121314151617181920212223// Init an empty set.RandomizedSet randomSet = new RandomizedSet();// Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);// Returns false as 2 does not exist in the set.randomSet.remove(2);// Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);// getRandom should return either 1 or 2 randomly.randomSet.getRandom();// Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);// 2 was already in the set, so return false.randomSet.insert(2);// Since 2 is the only number in the set, getRandom always return 2.randomSet.getRandom(); My Solution*12345678910111213141516171819202122232425262728293031323334353637from random import choiceclass RandomizedSet: def __init__(self): """ Initialize your data structure here. """ self.Rset,self.Rlist = set(),[] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val in self.Rset: return False else: self.Rset.add(val) self.Rlist.append(val) return True def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.Rset: self.Rset.remove(val) self.Rlist.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return choice(self.Rlist) 思路:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素再添加一个discuss里用字典和list来实现的代码，更快一些：1234567891011121314151617181920212223class RandomizedSet(object): def __init__(self): self.nums, self.pos = [], &#123;&#125; def insert(self, val): if val not in self.pos: self.nums.append(val) self.pos[val] = len(self.nums) - 1 return True return False def remove(self, val): if val in self.pos: idx, last = self.pos[val], self.nums[-1] self.nums[idx], self.pos[last] = last, idx self.nums.pop(); self.pos.pop(val, 0) return True return False def getRandom(self): return self.nums[random.randint(0, len(self.nums) - 1)] (Array-medium)4Sum(拓展为Nsum问题)DescriptionGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Solution借鉴discuss的思路，很不错1234567891011121314151617181920212223242526272829303132333435class Solution(object): def fourSum(self, nums, target): def Nsum(N,nums,target,result,results): # 特殊情况 if N&gt;len(nums) or target&gt;N*nums[-1] or target&lt;N*nums[0]: return # 高效的2Sum if N == 2: l,r = 0,len(nums)-1 while l &lt; r: if nums[l] + nums[r] == target: # 补充到最终结果 results.append(result + [nums[l], nums[r]]) # 左指针右移，同时右指针左移，因为已经排好序了，一个值不变另一个值变一定不会得到target l += 1 r -= 1 # 解决重复问题 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while r &gt; l and nums[r] == nums[r + 1]: r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 else: # 注意这里的范围，是到len(nums)-N+1,因为最后N个数为最后一组，无须再进行递归 for i in range(len(nums)-N+1): # 结合sorted可解决重复问题 if i==0 or (i&gt;0 and nums[i-1]!=nums[i]): # 递归，将nSum问题降为n-1Sum问题 Nsum(N-1,nums[i+1:],target-nums[i],result+[nums[i]],results) results = [] Nsum(4,sorted(nums),target,[],results) return results 思路：给定一个list和一个target，求所有n个list中的数和为target的不重复组合。本题是4Sum，代码拓展为了nSum问题，主要思路是通过迭代来把问题转换为高效的2Sum问题，即nSum-&gt;n-1Sum-&gt;….-&gt;4Sum-&gt;3Sum-&gt;2Sum,具体细节在代码注释中。 (Hash-Table)Repeated DNA SequencesDescriptionAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.For example,1234Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",Return:["AAAAACCCCC", "CCCCCAAAAA"]. 就是求一个字符串里的所有指定长度的重复子字符串。Mysolutionclass Solution(object): def findRepeatedDnaSequences(self, s): “”” :type s: str :rtype: List[str] “”” if len(s)0: results.append(key) return results1234567891011121314151617**思路** 循环切片判断是否重复，数据结构用的字典，注意的就是range的范围和切片的范围问题。将10替换为N可以变为求一个字符串中长度为N的重复子串。---# Longest Palindromic Substring经典的最大回文子字符串问题样例：``` pythonInput: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路：从左到右依次把每个字符当做中心，然后依次判断两边的字符是否相等，最后取最大的那个就行了，唯一要注意的一点是连续字符的情况，比如 abccbd,这个时候要把cc整体作为一个字符串，这里用了两个位置变量，left和right，每次判断两边的相同字符之前要确定right的值，也就是相同字符的长度。 123456789101112131415161718192021class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ length = len(s) result = '' for i in range(length): right = 1 left = 1 # get the step length while i + right &lt;= length - 1 and s[i + right] == s[i]: right += 1 while ((i -left ) &gt;= 0 and (i + right) &lt;= length - 1 and s[i - left] == s[i + right]): left += 1 right+=1 longest = s[i - left+1:i + right] if len(longest) &gt; len(result): result = longest return result (链表)Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路:就是由两个链表逆序表示的整数的和，没什么思路可言，这里主要考察的是对链表的操作，具体看代码，讲的很通俗易懂。 12345678910111213141516171819202122232425262728class Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ s1 = str(l1.val) s2 = str(l2.val) while l1.next: l1 = l1.next s1 = str(l1.val)+s1 while l2.next: l2 = l2.next s2 = str(l2.val)+s2 result = str(int(s1)+int(s2)) # 头节点 head = ListNode(int(result[-1])) after = head # 这里是对数组的操作，[-2::-1]表示从倒数第二个元素向后-1的取全部，注意这里[-2:0:-1]和[-2::-1]是不同的，前者取到下标为1，因为:左右就是[)的，后者取到数组头 for c in result[-2::-1]: # 新开辟一块内存空间 node = ListNode(int(c)) # 让after.next指向这个内存空间，相当于把两个节点连接起来 after.next = node # after指向这块内存空间，方便下一个节点建立以后after代表这块内存空间去实行指向下一块新的节点的任务 after = node return head (字符串)最大字符不重复子串问题 Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters.Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.给定一个字符串，求其最大子串，要求子串中无重复字符 思路:一开始我使用简单的从左到右每一个字符遍历最大子串，最后一个测试用例超时了，这里discuss里给出了一个特别好的例子： 12345678910111213141516171819202122class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ maxLength = 0 start = 0 usedChar = &#123;&#125; for i in range(len(s)): # start是一个下表，表示这一轮新的字符串的开始下标 # if s[i] in userChar 表示遍历到的当前字符曾经用过，有跟我当前新字符串重复的嫌疑 # start &lt;= userChar[s[i]]就是说我去查查你上次出现的下标，如果是在start以后，也就是说在当前新字符串你已经出现过一次了，那么这次就算重复了 if s[i] in usedChar and start &lt;= usedChar[s[i]]: # 那么这次新字符串的遍历到此结束，start更新为上次这个下标出现的后一位字符，下面会有详细解释 start = usedChar[s[i]]+1 else: maxLength = max(maxLength,i-start+1) # 每次都更新下标 usedChar[s[i]] = i return maxLength 12345678910111213141516**举个例子说明**abczkoz543q从左到右遍历：(used 误拼为 user 了)a -&gt; not in userChar ; max(0,1)=1 ; userChar[a] = 0b -&gt; not in userChar ; max(1,2)=2 ; userChar[b] = 1c -&gt; not in userChar ; max(2,3)=3 ; userChar[c] = 2z -&gt; not in userChar ; max(3,4)=4 ; userChar[z] = 3k -&gt; not in userChar ; max(4,5)=5 ; userChar[k] = 4o -&gt; not in userChar ; max(5,6)=6 ; userChar[b] = 5(到这儿为止，字符串一直是从start=0到当前下标，所以长度为6)z -&gt; in userChar and start &lt; userChar[z]在这里z在下标为3的时候出现过的，而当前字符串是从下标为0开始的，所以这个字符串到此为止了，它贡献了maxLength=6然后更新start为3+1，也就是从z后面的k作为下一个字符串的开始下标这里就要从第二个开始继续遍历了，因为没必要从b开始再遍历，因为b也肯定会遍历第一个z然后遍历到第二个z，它形成的最大子串其实是a形成的最大子串的子串，即 bczko 属于 abzko所以直接从z的下一个元素，也就是k开始作为start即可，同时这里用到了字典，也降低了时间复杂度 (分治)两个数组的中位数 Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).限制时间复杂度是O(log(m+n))Example1234nums1 = [1, 3]nums2 = [2]The median is 2.0 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 思路:非常简单的一道题目，先用+连起来，sorted一下，如果是偶数就输出中间两个的均值，如果是奇数长度就输出中间那个值。123456789101112class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ l = sorted(nums1+nums2) if len(l)%2==0: return (l[int(len(l)/2)] + l[int(len(l)/2-1)])/2 else: return int(l[int((len(l)-1)/2)]) 但是其实这个复杂度是O(m+n),这种做法的思想基于下面这种做法一样，而且应该花的时间更长，是最优化最差也是最简单的做法：依次遍历两个数组，每次取最小那个，直到遍历到第i个，这个i就是我们要的中位数或中间两个数，时间复杂度为O(m+n)有更好的做法：分治思路是分治常用的“割”，关键点是一条线割开两个数组，使得左边部分全部小于右边部分，这样就可以确定虚拟数组（两个数组合并排序）的前k个值了，妙啊妙啊。这是O(min(m,n))的做法(感觉不够简练)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def findMedianSortedArrays(self, nums1, nums2): if len(nums1)+len(nums2)&lt;=10: l = sorted(nums1 + nums2) if len(l) % 2 == 0: return (float(l[int(len(l) / 2)]) + float(l[int(len(l) / 2 - 1)])) / 2 else: return int(l[int((len(l) - 1) / 2)]) if len(nums1)&lt;len(nums2): long = nums2 short = nums1 else: long = nums1 short = nums2 if (len(long)+len(short))%2!=0: # 前面找k个数 k = ((len(nums1)+len(nums2))-1)/2 k1 = 0 k2 = k - 2 while ((k2 + 1 &lt;= len(long) - 1 and short[k1] &gt; long[k2 + 1]) or ( k1 + 1 &lt;= len(short) - 1 and long[k2] &gt; short[k1 + 1])): if short[k1]&gt;long[k2+1]: k1-=1 k2 = k-k1-2 else: k1+=1 k2 = k-k1-2 if k1 + 1 &lt;= len(short) - 1: return min(short[k1 + 1], long[k2 + 1]) else: return long[k2 + 1] else: k = (len(nums1)+len(nums2))/2 -1 # 割少的那个尾巴，注意下标 k1 = 0 k2 = k-2 while((k2+1&lt;= len(long)-1 and short[k1]&gt;long[k2+1]) or (k1+1 &lt;= len(short)-1 and long[k2]&gt;short[k1+1])): if short[k1]&gt;long[k2+1]: k1-=1 k2 = k-k1-2 else: k1+=1 k2 = k-k1-2 compareL = [] count=0 while k1+1&lt;=len(short)-1 and count &lt;2: compareL.append(short[k1+1]) k1+=1 count+=1 count=0 while k2+1&lt;=len(long)-1 and count &lt;2: compareL.append(long[k2+1]) k2+=1 count+=1 x1 = min(compareL) compareL.remove(x1) x2 = min(compareL) return (float(x1)+float(x2))/2 可以加个二分查找就变为了O(log(min(m,n))),有空再更新吧 3Sum问题第二次重写Nsum问题，花了一个小时调试边界值，虽然基本思想没忘，但是对细节的处理很差，后面写上注意事项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt; 3: return [] result = [] def Nsum(N, L, subResult, target): # 这种写法的复杂度是nlog(n),超时了，改写为排序数组的2Sum写法 # if N == 2: # sumDict = &#123;&#125; # for i in L: # if i not in sumDict: # sumDict[target - i] = i # else: # # 这里用了一个sorted来解决重复问题，不知道有没有更好的办法 # if sorted(subResult+[target-i,i]) not in result: # print subResult+[target-i,i] # result.append(sorted(subResult+[target-i,i])) # return if N==2: l,r = 0,len(L)-1 while r&gt;l: if L[l]+L[r] == target: result.append(subResult+[L[r],L[l]]) while l&lt;r and L[l] == L[l+1]: l+=1 while l&lt;r and L[r] == L[r-1]: r-=1 r-=1 l+=1 elif L[l]+L[r] &gt; target: r-=1 elif L[l]+L[r] &lt; target: l+=1 else: for i in range(len(L)-N+1): # 每次跳过重复字符 # while i&gt;1 and i&lt;len(L)-1 and L[i]==L[i-1]: # i+=1 if i == 0 or (i &gt; 0 and L[i - 1] != L[i]): Nsum(N - 1, L[i + 1:], subResult + [L[i]], target - L[i]) Nsum(3,sorted(nums),[],0) return result 1：思路依然是递归的将Nsum问题转化为2Sum问题，这里2Sum因为要找的值是不用管下标的，所以可以将数组排好序，这样可以将2Sum问题的时间复杂度降为O(n),而找两个下标的2Sum问题的复杂度是O(nlogN),我一开始将两者弄混了，所以一开始用的找下标的那种方法，然后就超时了2：注意2Sum问题的时候，指针移动的时候，要先跳过所以重复值，加上l1 and i&lt;len(L)-1 and L[i]==L[i-1]:**如果用这种方法来去掉遍历时候的重复值，会出现一些问题，比如[0,0,0,0,0]，虽然跳过了0，但是最后一个0还是会进，这样就会出现输出为[[0,0,0],[0,0,0]]的情况，所以用if可以防止这种情况，只要和前面重复都不进。 NSum Closest问题是Nsum问题的变形，但是原理差不多 123456789101112131415161718192021222324252627282930313233343536373839def threeSumClosest(nums, target): """ :type nums: List[int] :type target: int :rtype: int """ # 全局变量问题 global result global Min Min = 9999 result = 0 def findSum(N, L, Sum, target): global result global Min if N == 2: # 从L里找两个数，使得min(|(x1+x2+sum)-1|) l, r = 0, len(L) - 1 while l &lt; r: # 先替换 if Min &gt; abs(L[r] + L[l] + Sum - target): Min = abs(L[r] + L[l] + Sum - target) result = L[r] + L[l] + Sum # 是否特殊情况 if abs(L[r] + L[l] + Sum - target) ==0: result = L[r] + L[l] + Sum return # 移动指针 if L[r] + L[l] + Sum &gt; target and l&lt;r: r-=1 elif L[r] + L[l] + Sum &lt;target and l&lt;r: l+=1 else: for i in range(len(L) - N + 1): if i == 0 or (i &gt; 0 and L[i] != L[i - 1]): findSum(N - 1, L[i + 1:], Sum + L[i], target) findSum(3, sorted(nums), 0, target) return result 思路：还是递归的思想减少的2Sum问题，每次左右指针先算一次去替换最小，如果出现最优情况直接return，否则根据情况移动左右指针，跟Nsum还是有所区别。 Letter Combinations of a Phone Number数字组合，给出手机上的号码，每个号码对应着一组字母，求之间的有多少种组合方式Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below.12Input:Digit string "23"Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 思路：就是一个简单的递归 12345678910111213141516171819202122232425262728293031class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ kvmaps = &#123; '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' &#125; def comLetter(number, L): result = [] if number == '': return [] if L == []:result = [x for x in kvmaps[number[0]]] else: for x in kvmaps[number[0]]: for y in L: result.append(y+x) if len(number) == 1: return result else: return comLetter(number[1:], result) return comLetter(digits, []) 动态规划 最长不下降或不上升子序列参考 O(n)复杂度根据index删除链表中的元素给定一个链表，要求删除掉倒数第n个元素，然后返回head例子：12Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 要求onepass，遍历一次123456789101112131415161718class Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ fast = slow = head for _ in range(n): fast = fast.next if fast == None: return head.next else: while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head 思路：两个指针，一个在前一个在后，他们之间的间隔为n，那么当前面的那个指针到达链表的尾部的时候，后面那个指针的下一个元素就是要删除掉的元素，直接next = next.next跳过就可以了 括号匹配问题Generate Parentheses给定一个数字，比如3，在3个括号的前提下求所有可能的括号匹配，例如：1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 思路：回溯，注意两个点，一个是左括号一定等于右括号，第二个是左括号一定大于右括号1234567891011121314151617class Solution(object): def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ result = [] def addParentheses(strP,left,right): # 如果还剩下左括号，优先安排左括号 if left: addParentheses(strP+'(',left-1,right) # 如果右括号比左括号剩的多，再安排右括号 if right&gt;left:addParentheses(strP+')',left,right-1) # 这样，在递归的过程中，就可以列出所有可能的情况了 if right==0: result.append(strP) addParentheses('',n,n) return result 下面就3的例子画个图解释一下： 交换链表节点从左到右，一次交换每两个节点例如 1-&gt;2-&gt;3-&gt;4-&gt;5 到 2-&gt;1-&gt;4-&gt;3-&gt;5要求不准使用多余的空间，不准改变链表的值My Solution1234567891011121314151617181920212223242526272829class Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ current = None if head==None: return [] if head.next: temp = head.next head.next = head.next.next temp.next = head head = temp current = head.next while current: if current.next: if current.next.next: first = current.next second = current.next.next current.next = second first.next = second.next second.next = first current = current.next.next else: break else: break return head 思路：因为头结点比较特殊，所以我把对头结点的交换和后面的交换给分开了，主要用到三个变量，current,first,scond,其中，first和second是要交换的节点，current是first的上一个节点，所以要判断后面是否有两个值可以交换要判断current.next.next是否为None,具体的交换思路看下图 Reverse Nodes in k-Group翻转链表中k-group，例如：123456For example:Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 感冒了脑子太僵了，先占个坑 Next Permutation下一个最大的数字串，如果不是最大的，就找一个最小的比它大的，如果已经已经最大了，找一个最小的,例如：1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路： 从后往前遍历看看每一位是否能被替换 看每一位后面的所有字符是否有比它大的 挑出比它大的最小的那个来互换 互换完以后把该位后面的数按从小到大排序 123456789101112131415161718192021222324252627282930def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if len(nums)==1 or 0: return AlreadyMax = 1 for i in range(-2,-len(nums)-1,-1): if max(nums[i:]) &gt; nums[i]: AlreadyMax = 0 min_index = 0 minvalue = 9999999 for j in range(len(nums)+i,len(nums)): if nums[j] &gt; nums[i] and nums[j] &lt; minvalue: min_index = j minvalue = nums[j] # change temp = nums[i] nums[i] = nums[min_index] nums[min_index] = temp sortedList = sorted(nums[len(nums)+i+1:]) m = 0 for j in range(len(nums) + i + 1, len(nums)): nums[j] = sortedList[m] m+=1 break if AlreadyMax: nums.reverse() return Search in Rotated Sorted Array翻转的有序数组里找个数，就是一个升序排序数组事先翻转了，例如：0 1 2 4 5 6 7 -&gt; 4 5 6 7 0 1 2 12345678910111213if len(nums) &lt; 3: return nums.index(target) if target in nums else -1def findIndex(head, tail): if tail - head &lt; 3: result = [i for i in range(head, tail + 1) if nums[i] == target] return -1 if result == [] else result[0] elif nums[int((tail + head) / 2)]&gt;=nums[head]: return findIndex(head, int((tail + head) / 2)) if nums[head]&lt;=target&lt;=nums[int((tail + head) / 2)] else findIndex(int((tail + head) / 2), tail) else: return findIndex(int((tail + head) / 2), tail) if nums[int((tail + head) / 2)]&lt;=target&lt;=nums[tail] else findIndex(head, int((tail + head) / 2))return findIndex(0, len(nums) - 1) 思路：递归，参数为数组头和尾指针 Search for a Range找数组中某个数开始和结束的index例子：1234567891011121314151617181920212223242526def searchRange(nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [-1, -1] def findIndex(head, tail): halfIndex = int((tail + head) / 2) halfNumber = nums[halfIndex] if nums[head] == nums[tail]: return [head,tail] if nums[head]==target else [-1,-1] if halfNumber != target and halfIndex-head &gt; 1 and tail - halfIndex &gt;1: return findIndex(head,halfIndex) if target &lt; halfNumber else findIndex(halfIndex,tail) else: while halfIndex-head &gt; 1 and nums[int((head+halfIndex)/2)]&lt;target: head = int((head+halfIndex)/2) while tail - halfIndex &gt;1 and nums[int((tail+halfIndex)/2)]&gt;target: tail = int((tail+halfIndex)/2) while tail &gt; head and nums[head]!=target: head+=1 while tail &gt; head and nums[tail]!=target: tail-=1 return findIndex(head,tail) return findIndex(0,len(nums)-1) 思路：二分法，我用的是从两边往中间缩，直到无法用二分法缩了以后，用while找到头和尾，详细一点： 终止条件：如果头的值等于尾的值，判断是否等于target，是返回最终结果，否则[-1,-1]说明不在list里 如果中间值不等于target说明该值在左半部分或右半部分，递归 左边每次缩一半，如果还没遇到target的话，右边同理，缩到最小 左右多余一点儿裁掉，找到head和tail，返回注意：int((head+halfIndex)/2)如果两个index紧邻的话会无限重复，因为int(a,a+1)=a,需要判别 Combination Sum给定一个正整数去重序列，求序列中所有和为target的非重复组合，每个数可以重复用，例如：1234[ [7], [2, 2, 3]] Mysolution12345678910111213141516171819202122232425class Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates)==0: return [] candidates.sort() minValue = candidates[0] result= [] def findSum(Sum,tempL): if Sum == 0: final = sorted(tempL) if final not in result: result.append(final) else: for x in candidates: if Sum-x &gt;=0: findSum(Sum-x,tempL+[x]) else: break findSum(target,[]) return result 思路：递归，参数为每个子序列及其目前的和，每次用target减去总序列的每个值，如果为0，说明该子序列结束有解，如果为负数则无解，不添加该子序列。 Combination Sum II与上个题基本一样，但是序列是重复的，并且每个数不能重复用，求所有和为target的非重复序列思路：递归参数加一个，nowCandidate，大小为遍历到的该数后面的序列[i+1:]solution123456789101112131415161718192021222324252627class Solution(object): def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] candidates.sort() minValue = candidates[0] result = [] def findSum(Sum, tempL, nowCan): if Sum == 0: final = sorted(tempL) if final not in result: result.append(final) else: for i in range(len(nowCan)): if Sum - nowCan[i] &gt;= 0: findSum(Sum - nowCan[i], tempL + [nowCan[i]], nowCan[i+1:]) else: break findSum(target, [], candidates) return result Permutations给定一个非重复整数串，求所有可能的子序排列，例如：12345678910input:[1,2,3]output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路：递归，从剩下的序列中遍历选取一个加入到目前子序列，再将这个数从剩下的子序列中删除12345678910111213141516171819class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] result = [] def findAll(nowL, remainL): if remainL == []: result.append(nowL) for i in range(len(remainL)): tempL = remainL[:] tempL.remove(remainL[i]) findAll(nowL + [remainL[i]], tempL) findAll([], nums) return result Permutations II与上题类似，但是给定序列中有重复数字，求所有可能的子序排列（去重复）只要在上题的基础上在每次从剩余序列选值的时候加上跳过重复值得操作即可，首先要对整个序列排序 12345678910111213141516171819202122class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums.sort() if len(nums) == 0: return [] result = [] def findAll(nowL, remainL): if remainL == []: result.append(nowL) for i in range(len(remainL)): # 加入下面这一行,因为不管在哪一轮，如果有两个以上重复的，那么选他们任意超过两个后续操作必然重复，因为没有区别 if i==0 or (i&gt;0 and remainL[i]!=remainL[i-1]): tempL = remainL[:] tempL.remove(remainL[i]) findAll(nowL + [remainL[i]], tempL) findAll([], nums) return result Valid Sudoku判断给的已经填充一部分的数独是否有效思路：只需要判断三个条件： 行不能重复 列不能重复 九宫格内不能重复所以，依次遍历每一个填充的值，把i,j,position（位于哪个九宫格）加入字典，只要有一个重复就fail 12345678910111213141516171819202122class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ sudokuDict = &#123;&#125; n = len(board) for i in range(n): for j in range(n): # 判断在哪个九宫格内 position = [int(i / 3), int(j / 3)] if board[i][j] != '.': if board[i][j] not in sudokuDict: sudokuDict[board[i][j]] = [[i, j, position]] else: for l in sudokuDict[board[i][j]]: if l[0] == i or l[1] == j or l[2] == position: return False else: sudokuDict[board[i][j]].append([i, j, position]) return True Rotate Image旋转二位数组，例如：123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 思路：每次遍历最外层的正方形的第一层，找到四个位置的对应关系，依次替换即可（不用管奇数偶数问题，因为最后中心即使剩下一个单独的值无需替换） 1234567891011121314151617181920212223class Solution(object): def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ n = len(matrix) for i in range(int(n/2)): start = i # 不包括ends end = n-i-1 for j in range(start,end): print(start,end) print(i,j) # matrix[i][j] -&gt; matrix[j][end] # ↑ ↓ # matrix[n-1-j][start] &lt;- matrix[n-1-i][n-1-j] temp = matrix[j][end] matrix[j][end] = matrix[i][j] matrix[i][j] = matrix[n-1-j][start] matrix[n-1-j][start] = matrix[n-1-i][n-1-j] matrix[n-1-i][n-1-j] = temp return Group Anagrams给定一个字符串数组，把里面字符串内容相同但是顺序不同的归到一起，例如：1234567given:: ["eat", "tea", "tan", "ate", "nat", "bat"]return:[ ["ate", "eat","tea"], ["nat","tan"], ["bat"]] 思路：依次遍历，用字典来存遍历过的字符串，键为排序过的字符串，如果不计算sort的时间的话，是nlog(n)12345678910111213141516171819class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ if not strs: return [[]] result = [] searchDict = &#123;&#125; for s in strs: sortedS = ''.join(sorted(s)) if sortedS in searchDict: searchDict[sortedS] += [s] else: searchDict[sortedS] = [s] for k,v in searchDict.items(): result.append(v) return result Spiral Matrix 螺旋矩阵例如：123456[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]output:[1,2,3,6,9,8,7,4,5] 思路：沿着一个方向一直走直到不能走，顺序是右下左上。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if not matrix: return [] rows = len(matrix) cols = len(matrix[0]) hasMoved = &#123;&#125; for i in range(rows): hasMoved[i] = [0 for x in range(cols)] result = [] hasMoved[0][0] = 1 result.append(matrix[0][0]) i,j = 0,0 while len(result) != rows*cols: while j&lt;cols-1 and hasMoved[i][j+1] == 0: hasMoved[i][j+1] = 1 result.append(matrix[i][j+1]) j+=1 while i &lt; rows - 1 and hasMoved[i+1][j] == 0: hasMoved[i+1][j] = 1 result.append(matrix[i+1][j]) i += 1 while j &gt;0 and hasMoved[i][j-1] == 0: hasMoved[i][j-1] = 1 result.append(matrix[i][j-1]) j-=1 while i&gt;0 and hasMoved[i-1][j] == 0: hasMoved[i-1][j] = 1 result.append(matrix[i-1][j]) i -= 1 return result]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F1970%2F01%2F01%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[二位数组中的查找题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 My solution:用递归来解，从右下向左上对角线遍历，每次把大矩阵分为左下右上两个小矩阵进行递归，终止条件是target位于对角线或矩阵只剩一行或一列遍历target（矩阵可能行列数不相同）123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self,target, array): def FindTarget(target, array): # 如果只有一行 if len(array) == 1: if target in array[0]: return True else: return False if len(array) &gt;= 2: # 如果只有一列 if len(array[0]) == 1 and len(array[1]) == 1: if target in [x[0] for x in array]: return True else: return False # 其它情况 else: height = len(array) width = len(array[0]) while (height &gt; 0 and width &gt; 0): v = array[height - 1][width - 1] height -= 1 width -= 1 if v == target: return True if v &gt; target and height!=0: else: remain1 = [x[width + 1:len(array[0])] for x in array[:height+1]] remain2 = [x[:width + 1] for x in array[height + 1:len(array)]] return (FindTarget(target, remain1)) or (FindTarget(target, remain2)) result = False result = FindTarget(target, array) return result 简单做法：从左下开始遍历，比target大就往上，比target小就往下（妈的，看完很气，还特么辛苦写了个递归，这个简单做法太简单就不写了，╭(╯^╰)╮） 从尾到头打印列表1234567891011class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here # write code here l = [] head = listNode while head: l.insert(0, head.val) head = head.next return l 很简单，注意是while head 不是 while head.next 旋转数组的最小数字题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。思路就是一个数组，把从后面切片放到前面来，让找最小数字，最简单的做法是直接min()函数，但是耗时我的做法是使用递归，如果数组中间的数比开头的小，那么说明最小的数在这个切片里，不然就在后半切片里12345678910111213def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray)==0: return 0 def findMin(array): if len(array)&lt;5: return min(array) else: if array[int(len(array)/2)]&gt;array[0]: return findMin(array[int(len(array)/2):]) if array[int(len(array)/2)]&lt;array[0]: return findMin(array[:int(len(array)/2)+1]) return findMin(rotateArray) 再优化一点就是从左到右找，找到下一个比当前的小了说明下一个就是最小值 输出斐波那契数列第n个数递归做法12345678910111213141516171819202122def Fibonacci(n): # write code here def getN(n): if n == 0: return 0 if n == 1 or n==2: return 1 else: return getN(n - 1) + getN(n - 2) return getN(n)``` **数组做法**``` pythondef Fibonacci(self, n): a = [0,1,1] if n&lt;3: return a[n] else: for i in range(n-2): a.append(a[-1]+a[-2]) return a[-1] 三个变量做法最快 12345678910111213public int Fibonacci(int n) &#123; int one = 0; int two = 1; if(n &lt;= 0) return one; if(n == 1) return two; int result = 0; for(int i = 2; i &lt;= n; i++)&#123; result = one + two; one = two; two = result; &#125; return result; &#125; 斐波那契数列扩展问题一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。思路一个青蛙跳到第k个台阶，对于k-1个台阶来说只有一种跳法，就是跳1级，对k-2级台阶来说就是跳两级，也只有一种跳法，所以跳到第k个台阶的做法就是跳到第k-1个台阶的做法+跳到第k-2个台阶的做法也就是 斐波那契数列！精彩 变态跳台阶问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。思路：跟上题类似，但是青蛙上次的位置不限于k-1和k-2了，可以在任何位置，用递归来实现，核心思想是：**递归的加上一次所有可能的位置（1到k-1）加上从0直接到当前位置 12345678910def jumpFloorII(number): # write code here def findAlljumps(n): if n==1: return 1 if n==2: return 2 else: return sum([findAlljumps(i) for i in range(1,n)],1) return findAlljumps(number) 矩形覆盖题目：我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2n的大矩形，总共有多少种方法？*思路：用从后往前的递归方法想一下，先填满，然后依次往外拿，行已经知道是2了，列为n列，那么就是求f(n),递归往前一步想，有两类往外拿的方法，一个是拿一个横的，一个是拿一个竖着的，如果拿出一个竖着的，那么其实就是f(n-1)然后填一个竖着的到f(n),如果拿一个横着的（其实相当于拿出两个横着的，因为不管拿上面还是下面的横着的，它对应的上面或下面的那个横着的没有其它拿法，所以相当于f(n-2),所以这道题其实又是一个斐波那契数列的问题了）123456789101112131415def rectCover(self, number): # write code here if not number: return 0 if number == 1: return 1 else: last = 1 current = 2 while number-2&gt;0: temp = current current = last + current last = temp number-=1 return current 机器人的运动范围题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？思路：用递归上下左右的满足条件去走，每走一步count+1，具体的条件：1.下一步不超边界2.下一步满足横纵坐标各个位数之和不大于k3.下一步不重复（可以把走过的位置用字典存起来） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def movingCount(threshold, rows, cols): # write code here if rows==cols==1: return 1 count = [] hasGone = &#123;&#125; hasGone[0] = [0] def isSmaller(n, x, y): xSum = 0 ySum = 0 for i in range(len(str(x))): xSum += int(str(x)[i]) for j in range(len(str(y))): ySum += int(str(y)[j]) if xSum+ySum &gt; n: return False else: return True def fuck(): print('调用') count.append(1) def move(i,j): global count # 往上走 if i&gt;0: if isSmaller(threshold,i-1,j): if i-1 not in hasGone: fuck() hasGone[i-1] = [j] move(i - 1, j) else: if j not in hasGone[i-1]: fuck() hasGone[i-1] += [j] move(i - 1, j) # 往下走 if i&lt;rows-1: if isSmaller(threshold,i+1,j): if i+1 not in hasGone: fuck() hasGone[i+1] = [j] move(i + 1, j) else: if j not in hasGone[i+1]: fuck() hasGone[i+1] += [j] move(i + 1, j) # 往左 if j&gt;0: if isSmaller(threshold,i,j-1): if i not in hasGone: fuck() hasGone[i] = [j-1] move(i, j-1) else: if j-1 not in hasGone[i]: fuck() hasGone[i] += [j-1] move(i, j-1) # 右 if j&lt;cols-1: if isSmaller(threshold,i,j+1): if i not in hasGone: fuck() hasGone[i] = [j+1] move(i, j+1) else: if j+1 not in hasGone[i]: fuck() hasGone[i] += [j+1] move(i, j+1) move(0,0) return sum(count)+1 矩阵中的路径题目：设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。思路：想把输出按照行列换成对应的矩阵，然后找到所有的开头点，对于每个开头点：先把指针cur指向path的下一个字符 递归，上下左右查看 如果满足边界内并且非重复并且是cur当前所指的字符 指针+1，横纵坐标对应操作一并当做参数进行下一轮递归，坐标加入已经走过的坐标字典1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): if len(path)==0: return False if len(path)==1: if path in matrix: return True else: return False result = [] def finalfind(): result.append(1) def findStr(i,j,cur): if cur == len(path): finalfind() return elif cur &lt; len(path): if i&gt;0: # 往上 if M[i-1][j] == path[cur]: if i-1 in GoneDict: if j not in GoneDict[i-1]: GoneDict[i-1]+=[j] #print('shang',i-1,j) findStr(i-1,j,cur+1) else: GoneDict[i-1] = [j] #print('shang', i - 1, j) findStr(i - 1, j, cur+1) if i&lt;rows-1: # 往下 if M[i + 1][j] == path[cur]: if i + 1 in GoneDict: if j not in GoneDict[i + 1]: GoneDict[i + 1] += [j] #print('xia', i + 1, j) findStr(i + 1, j, cur+1) else: GoneDict[i + 1] = [j] findStr(i + 1, j, cur+1) if j&gt;0: # 左 if M[i][j-1] == path[cur]: if i in GoneDict: if j-1 not in GoneDict[i]: GoneDict[i] += [j-1] #print('zuo', i, j-1) findStr(i, j-1, cur+1) else: GoneDict[i] = [j-1] #print('zuo', i, j - 1) findStr(i, j-1, cur+1) if j&lt;cols-1: # 右 if M[i][j+1] == path[cur]: if i in GoneDict: if j+1 not in GoneDict[i]: GoneDict[i] += [j+1] #print('you', i, j + 1) findStr(i, j+1, cur+1) else: GoneDict[i] = [j+1] #print('you', i, j + 1) findStr(i, j+1, cur+1) # write code here GoneDict = &#123;&#125; M = [] start = 0 end = cols for i in range(rows): M.append([x for x in matrix[start:end]]) start = end end += cols # 记录当前查询的位置 startPoint = [] # 找到所有开头的节点 for i in range(rows): for j in range(cols): if M[i][j] == path[0]: startPoint.append([i,j]) if startPoint: for point in startPoint: # 对于每一个头重置字典 GoneDict = &#123;&#125; # 先把开头的节点放入字典 GoneDict[point[0]] = [point[1]] findStr(point[0],point[1],1) if result ==True: break if result: return True else: return False 滑动窗口的最大值题目：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。12345678910def maxInWindows(self, num, size): # write code here if size==0: return [] result = [] if size &gt; len(num): return [] for i in range(len(num) -size+ 1): result.append(max(num[i:i + size])) return result 二叉搜索树的第K个节点二叉搜索数的中序遍历是有序的，因此只要把第k个节点返回12345678910111213141516171819202122232425# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here # 特殊情况1 if k==0: return result = [] def middle(root): if root==None: return middle(root.left) result.append(root) middle(root.right) middle(pRoot) # 特殊情况2 if k&gt;len(result): return return result[k-1] 二进制中1的个数输入一个整数，可能为负数，求其二进制中1的个数12345# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here return sum([1 &amp; n&gt;&gt;i for i in range(32)]) 其二进制长度为32位，依次右移i位，也就是每次比较最后一位 &amp; 1 ，判断最后一位是否为0. 调整数组使得奇数位于偶数前输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。12345# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here return [x for x in array if x%2!=0] + [x for x in array if x%2==0] 链表中倒数第k个节点做法一，遍历一遍，把每个节点保存下来，最后返回第-k个做法二，用两个指针，第一个先走k步，然后一起走，第一个到尾节点的时候后面的那个指针应该正好倒数第k个12345678910111213class Solution: def FindKthToTail(self, head, k): # write code here if not head: return pre = head l = [head] while pre.next!=None: pre = pre.next l.append(pre) if len(l) &lt; k or k &lt;= 0: return return l[-k] 输入一个链表，反转链表后，输出链表的所有元素。1234567891011121314151617class Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead def revLinked(pre,after): if after == None: return pre if pre == pHead: pre.next = None temp = after.next after.next = pre if after.next == None: return after return revLinked(after,temp) return revLinked(pHead,pHead.next) 递归，每次输入两个节点，让后面的节点指向前面的节点,别忘了处理头结点合并两个排序的链表题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。123456789101112131415161718192021222324252627282930313233class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if not pHead1: return pHead2 if not pHead2: return pHead1 p1 = pHead1 p2 = pHead2 head = ListNode(0) pre = head while True: if p1!=None and p2!=None: if p1.val &lt; p2.val: pre.next = ListNode(p1.val) p1 = p1.next else: pre.next = ListNode(p2.val) p2 = p2.next pre = pre.next elif p1==None: while p2: pre.next = ListNode(p2.val) p2 = p2.next pre = pre.next elif p2==None: while p1: pre.next = ListNode(p1.val) p1 = p1.next pre = pre.next if p1==None and p2==None: return head.next 每次从两个链表当前指针所在位置选一个最小的，如果一条链表为空，添加剩余链表 魔法币小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。123456789101112#输入描述:输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。#输出描述:输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符'1'和'2'。#输入例子1:10#输出例子1:122 MySolution12345678910111213141516171819n = int(input()) arr=[]def getStr(n): if n==0: return if n%2!=0: # 奇数 arr.append(1) return getStr(int((n-1)/2)) if n%2==0: # 偶数 arr.append(2) return getStr(int((n-2)/2))getStr(n)arr.reverse()finalStr=''for x in arr: finalStr += str(x)print(finalStr) 思路 递归，如果最终结果是偶数，那么上一步一定用了机器2，奇数机器1同理 ”相反数“”为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.123456789101112#输入描述:输入包括一个整数n,(1 ≤ n ≤ 10^5)#输出描述:输出一个整数,表示n的相反数#输入例子1:1325#输出例子1:6556 MySolution12345678n = int(input())arr = [x for x in str(n)]arr.reverse()finalNumber = ''for x in arr: finalNumber+=xfinalNumber = int(finalNumber)print (finalNumber + n) 思路：很简单 字符串碎片一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。123456789101112131415输入描述:输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母('a'-'z')输出描述:输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。如样例所示: s = "aaabbaaac"所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25输入例子1:aaabbaaac输出例子1:2.25 MySolution12345678910s = str(input())def findS(s): if len(s)==1: return 1.0 sum=1 for i in range(len(s)-1): if s[i]!=s[i+1]: sum+=1 return len(s)/sumprint('%.2f'%findS(s)) 思路：很简单的题目，就注意格式化的时候，我一开始用round，报错3.50要求不能3.5，于是用了%.2f 重排数列小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。牛博士给小易出了一个难题:对数列A进行重新排列,使数列A满足所有的A[i] * Ai + 1都是4的倍数。小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。123456789101112131415161718#输入描述:#输入的第一行为数列的个数t(1 ≤ t ≤ 10),#接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)#第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)#输出描述:#对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。#示例1#输入231 10 10041 2 3 4#输出YesNo MySolution1234567891011121314151617181920s = int(input())resultArr = []dic = &#123;&#125;for i in range(s): n = int(input()) arr = [int(y) for y in str(input()).split(' ')] dic[n] = arr arr = [int(x%4) for x in arr] ji = arr.count(1)+arr.count(3)-1 # 有能被2整除的 if arr.count(2)&gt;0: arr = [x for x in arr if x != 2] arr.append(1) #如果存在能被2整除的，这些数必须紧邻在一起当做一个奇数 if float(arr.count(0))&gt;=(len(arr)-1)/2: resultArr.append('Yes') else: resultArr.append('No')for x in resultArr: print(x) 思路： 如果有能被2整除的，那为了满足条件，它们必须紧挨着，那就相当于一个奇数，所以可以删除它们加进来一个奇数，那么数组就只剩下奇数和能被4整除的数了，那么满足被4整除的数插在奇数中间即可，即 n* &gt;= (len(array)-1)/2 或者 大于等于奇数-1，都一样.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
