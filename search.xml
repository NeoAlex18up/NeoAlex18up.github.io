<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode_easy]]></title>
    <url>%2F2017%2F12%2F13%2Fleetcode%2F</url>
    <content type="text"><![CDATA[Two sum**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.** Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解） Sample solution:123456789def twoSum(self, nums, target): if len(nums) &lt;= 1: return False buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i 思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index] Reverse IntegerQ:Given a 32-bit signed integer, reverse digits of an integer.Example 1:12Input: 123Output: 321 Example 2:12Input: -123Output: -321 Example 3:12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. My Answer:12345678910111213141516171819class Solution: def reverse(self, nums): if len(str(nums))&gt;0 and nums != 0 and nums &lt;= math.pow(2,31): nums = str(nums) newStr = '' # len(nums)-1 to -1 , -1 not included , interval is -1 for i in range(len(nums)-1,-1,-1): newStr = newStr + nums[i] print(newStr) while newStr[0] == '0': newStr= newStr[1:] if newStr[-1]=='-': newStr='-'+newStr[:len(newStr)-1] if math.fabs(int(newStr)) &gt;= math.pow(2,31): return 0 else: return(int(newStr)) else: return 0 思路：主要注意几点1.32位有符号整数范围判断2.逆序以后0的处理3.切片时注意索引是否会超范围，也就是只输入0的情况4.对于是否为负的处理 python mathNumber-theoretic and representation functions里附上一些常用的math方法:(python 3.6.4 standard) math.ceil(x) 上限，返回大于或等于x的最小整数 math.copysign(x,y) 赋值符号,返回x的绝对值，使用y的符号,返回类型为float math.fabs(x) 返回x的绝对值 math.factorial(x) 返回x的阶乘，如果x为非正整数会报错 math.floor(x) 下限，小于或等于x的最大整数 math.fmod(x,y) 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号） math.frexp(x) 返回一个元组(m,n),根据x = m(2*n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了） math.fsum(iterable) 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999 math.gcd(a,b) 返回最大公约数,a,b必须为整数 math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0) 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:1print(math.isclose(1,0.8,rel_tol=0.18)) 输出为False1print(math.isclose(1,0.8,rel_tol=0.2)) 输出为True1print(math.isclose(12,0.8,abs_tol = 10)) 输出为False1print(math.isclose(12,0.8,abs_tol = 11.3)) 输出为True math.isfinite(x) 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number) math.isinf(x) 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN 12345# 正无穷float('inf')# 负无穷float('-inf')-float('inf') math.isnan(x) 判断是否是NAN（not a number） math.ldexp(x,i) 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数 math.modf(x) 分别返回x的小数部分和整数部分，同时带x的符号，例如1print(math.modf(-1.89)) 输出(-0.8899999999999999, -1.0) math.trunc(x) 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数Power and logarithmic functions math.exp(x) 返回e的x方 math.expm1(x) 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确 math.log(x[,base]) 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base), math.log1p(x) 返回值为 log(1+x)/log(e) math.log2(x) 返回值为log(x)/log2,用来代替log(x,2),因为更加精确 math.log10(x) 同理，返回log(x)/log(10) math.pow(x,y) 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan math.sqrt(x) 返回x的平方根Trigonometric functions三角函数 math.acos(x) 返回x的反余弦 arc cosine，把斜率转换成弧度 math.asin(x) 返回x的反正弦 arc sine math.atan(x) 返回x的反正切 arc tangent math.atan2(y,x) 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标 math.cos(x) 返回x的余弦,角度值转为余弦值,cos(0)=1.0 math.sin(x) 返回x的正弦 math.tan(x) 返回x的正切 *math.hypot(x,y) 返回欧几里得范数 sqrt(xx + y*y) ,也就是点(x,y)到原点的距离 *math.degrees(x) 把角度x转为弧度，角度=（弧度/π）180 *math.radians(x) 把弧度x转为角度，弧度= (角度/180)πothers math.lgamma(x) 返回伽马函数绝对值在x上的自然对数。 Palindrome Number]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2017%2F11%2F29%2Ftest%2F</url>
    <content type="text"><![CDATA[时间测试：2017年11月29日 19时16分32秒 ==字体加粗高亮斜体测试== ###百度链接测试 ###代码测试1import numpy as np ###插入图片测试 ###添加附件测试=点击下载 ###多标签写法123tags: - python - 机器学习]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监督学习 半监督学习 非监督学习 强化学习]]></title>
    <url>%2F2017%2F11%2F29%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[监督学习 监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同） –李航《统计学习方法》 监督学习通常有标注好的训练集，通过这份训练集可以根据某个评价函数训练出最优的模型，从而对于每一个输入，该模型都能够在当前的评价体系下给出一个相对较优的输出。 特点： 有标注好的训练样本 有输入有输出 通常的任务为分类和回归以及标注 常用的监督学习算法 K近邻算法（KNN） 决策树 （Decision Tree） 朴素贝叶斯（Naive Bayesian） 逻辑回归（Logistic Regression） 这里只罗列了几种最基础的算法，通常在实际应用或数据挖掘比赛中人们会采用更为复杂的集成算法。 非监督学习非监督学习没有任何训练样本，直接对数据进行建模，举个例子来说，数据中有大量的地理位置信息比如经纬度，就可以对经纬度进行无监督学习，把地理位置相近的分在一起，这在无监督学习中叫做聚类 特点： 没有训练样本 主要任务是聚类 半监督学习半监督学习就和它的名字一样，同时具备监督学习和非监督学习的特征和方法，它的数据中有标注好的训练样本，也有没有标注的样本。举个半监督学习的例子： 图中有两个标注好的训练样本，绿色的是没有标注的样本，如果按照监督学习的方法，例如SVM模型会按照左边所示来进行分类，然而实际的数据情况如右图所示，所以实际上应该按照右图所示进行划分，这也就是半监督学习的基本原理：想办法如何同时利用标注好的数据和没有标注的数据。 特点： 既有标注好的训练样本也有未标注的样本 强化学习首先上一个很普遍的用来描述强化学习的图片： 解释：训练实体(Agent)不断地采取行动(action), 之后转到下一个状态(State), 并且获得一个回报(reward), 从而进一步更新训练实体Agent. 就像要训练小老鼠走出迷宫, 你可以在迷宫的几个关键地点放上奶酪, 这些奶酪就是算法中的回报(reward)了, 剩下你只要坐着等小老鼠走出迷宫啦: 再举个例子： 假设1:你是第一次撩妹。那么你会去求教他人，逛各种论坛，总之收集大量相关知识。这个过程就是experience data。利用离线数据来train一个model。 假设2:过去你有很多撩妹经验。你似乎又发现总是按照套路来并不能成功。嗯，经典的探索与利用问题，于是你尝试了其他方法，你发现获得了更好的效果。嗯，more optimal policy 将上述过程对应到RL中：action：你的行为state：你观察到的妹子的状态reward：妹子的反应：开心or不开心至此，一个RL的基本模型已经建立。 参考链接 https://www.zhihu.com/question/31140846/answer/94703351 http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/ https://www.zhihu.com/question/31140846]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
