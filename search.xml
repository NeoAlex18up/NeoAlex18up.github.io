<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[流畅的python]]></title>
    <url>%2F2017%2F12%2F14%2Fpython%2F</url>
    <content type="text"><![CDATA[python math库Number-theoretic and representation functions math.ceil(x) 上限，返回大于或等于x的最小整数 math.copysign(x,y) 赋值符号,返回x的绝对值，使用y的符号,返回类型为float math.fabs(x) 返回x的绝对值 math.factorial(x) 返回x的阶乘，如果x为非正整数会报错 math.floor(x) 下限，小于或等于x的最大整数 math.fmod(x,y) 返回x对y取模的余数（x决定余数符号），与x%y不同（y决定余数符号） math.frexp(x) 返回一个元组(m,n),根据x = m(2*n)即 m乘以2的n次方,一般用来拆分一个浮点数（文档写的是m,e，我觉得容易造成误会改成n了） math.fsum(iterable) 返回数组的和，比内置sum要准确，例如10个0.1相加，内置sum可能会得到0.99999999999 math.gcd(a,b) 返回最大公约数,a,b必须为整数 math.isclose(a,b,*,rel_tol=1e-09, abs_tol=0.0) 用来比较a,b两个数是否接近，判断是否接近的标准就是rel_tol和abs_tol.rel_tol 是 relative tolerance 相对误差(指a.b之间可以允许的最大误差)，默认值是1e-09,也就是输入的值相对差值小于1e-09才算closeToEachOther，rel_tol必须大于0;abs_tol是绝对误差;简单来讲，rel_tol是差值百分比，abs_tol是差值绝对值，举例:1print(math.isclose(1,0.8,rel_tol=0.18)) 输出为False1print(math.isclose(1,0.8,rel_tol=0.2)) 输出为True1print(math.isclose(12,0.8,abs_tol = 10)) 输出为False1print(math.isclose(12,0.8,abs_tol = 11.3)) 输出为True math.isfinite(x) 判断一个数是否是有限的，如果是 infinite 或者 nan , NaN（包括np.NaN） 会输出False，否则为True,(注意，判断不是有限的并不代表是无限的，可能是NaN -&gt; not a number) math.isinf(x) 判断一个数是否是无限的（正无限和负无限），无法判断是否是NAN 12345# 正无穷float('inf')# 负无穷float('-inf')-float('inf') math.isnan(x) 判断是否是NAN（not a number） math.ldexp(x,i) 返回 x乘2的i次方，是frexp()函数的逆，一个是把数分解为两元，一个是两元合成一个数 math.modf(x) 分别返回x的小数部分和整数部分，同时带x的符号，例如1print(math.modf(-1.89)) 输出(-0.8899999999999999, -1.0) math.trunc(x) 在3.5版本中跟floor没区别，在2.7版本中，floor返回的是浮点整数，trunc返回的整数Power and logarithmic functions math.exp(x) 返回e的x方 math.expm1(x) 因为对于小浮点数，当计算exp(x)-1的时候会有精度损失，所以使用expm1(x)来代替计算使得更精确 math.log(x[,base]) 如果只有一个参数，那么默认以e为底 log(x)/log(e)，如果有两个参数，以新参数base为底 log(x)/log(base), math.log1p(x) 返回值为 log(1+x)/log(e) math.log2(x) 返回值为log(x)/log2,用来代替log(x,2),因为更加精确 math.log10(x) 同理，返回log(x)/log(10) math.pow(x,y) 返回x的y次方，y为0,0.0,时候返回1，如果x为1,那么即使y为NaN也返回1.0,其他情况下y为NaN结果为nan math.sqrt(x) 返回x的平方根Trigonometric functions三角函数 math.acos(x) 返回x的反余弦 arc cosine，把斜率转换成弧度 math.asin(x) 返回x的反正弦 arc sine math.atan(x) 返回x的反正切 arc tangent math.atan2(y,x) 返回atan(y/x),结果在-pi到pi之间，一般用这个函数（因为函数的周期性），可以把yx看做是坐标 math.cos(x) 返回x的余弦,角度值转为余弦值,cos(0)=1.0 math.sin(x) 返回x的正弦 math.tan(x) 返回x的正切 math.hypot(x,y) 返回欧几里得范数 sqrt(xx + yy) ,也就是点(x,y)到原点的距离 math.degrees(x) 把角度x转为弧度，角度=（弧度/π）*180 math.radians(x) 把弧度x转为角度，弧度= (角度/180)*πothers math.lgamma(x) 返回伽马函数绝对值在x上的自然对数。 filter 函数pyhton 中的 filter函数接收一个函数f和一个序列(python中的序列有：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象，列表和元组的区别主要是：列表可以修改，元组不能)，函数f的作用是对列表中的每一个元素进行条件判断，返回True或False，filter函数最终返回一个迭代器Iterator(在python 2.x中返回一个list)举例：返回1-1000中的所有奇数123456def is_odd(x): return x%2!=0# in python 3.xprint(list(filter(is_odd,range(1,1001))))# in python 2.xprint filter(is_odd,range(1,1001)) 字符串遍历筛选的例子：12345def is_a(x): return x=='a'print(list(filter(is_a,'HaHaHaHa')))Output:['a','a','a','a'] 例如：删除None和空字符串1234def Cal_str(s): return s and len(s.strip())&gt;0filter(Cal_str,["H",None,"","ello"])Output: "[H","ello"] strip strip(rm) 默认删除s字符串中开头、结尾处的rm字符串，当rm为空的时候，默认删除空白（包括’\n’, ‘\r’, ‘\t’, ‘ ‘) s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符 s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符 s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符12345678a = 'Hello world'print(a.strip('He'))print(a.strip('eH'))print(a.strip('el'))Output:llo worldllo worldHello world 由于Python3.x中的filter返回的是一个Iterator，所以不仅仅可以指定为list，也可以set(filter(…)) map 函数python 中的 map函数接收一个函数f和一个序列，f将作用于序列中的每个元素，最终的结果作为Interator返回 如果使用map来实现filter中的例子123456def is_a(x): if x=='a': return xprint(list(map(is_a,"Hahahah")))Output:[None, 'a', None, 'a', None, 'a', None] map最终返回的序列长度是等于原来的序列长度的，filter返回的序列长度是小于等于原来的长度的1234# 使用lambda函数的例子print(list(map(lambda x:x+1,[1,2,3,4,5])))Output:[2,3,4,5,6] 注意！ 当只有一个序列的时候，map和filter都是可以使用的，但是当处理多个序列的时候，只能使用map例如：12345print(list(map(lambda x,y:x+y,[1,4,6],[2,5,8])))Output:[3,9,14]# 相当于zip,然后将zip的结果传给函数,所以map在处理多个序列的时候，无法操作序列长度不一致，对应值类型不同的情况# 例如[1,4,6],[2,5,6,8]或[1,4,6],['a',3,6] reduce 函数注意 在python3中，reduce已经从内置函数中被抛弃了，要使用就要引入1from functools import reduce reduce函数是一个累积运算的过程，其接收一个函数f(x,y)和一个序列（以及一个可选的初始值）,其中函数f的x,y首先代表序列中的第一个和第二个参数，其返回值作为新的x，第三个参数作为新的y，依次运算至结束。例如求和运算：123456789def f(x, y): return x + yprint(list(reduce(f,[1,3,5,7,9])))Process:先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25 如果设置了初始值为100，那么第一次运算就是f(100,1) 再例如，用reduce实现5的阶乘:123print(reduce(lambda x,y:x*y,range(1,6)))Output:120 只举了两个简单的例子，通过函数可以实现更为复杂的操作 lambda 函数lambda作为一个表达式，定义了一个匿名函数定义一个lambda表达式:1234g = lambda x:x+1# 可以这样理解def g(x): return x+1 lambda 常常配合上述的 reduce , map, filter 作为f来使用，可以使得代码大大简化。但是python中的 for..in..if 已经非常强大，lambda并不一定作为首选12# 注意是[]print ([x for x in range(10) if x % 3 == 0]) 总之：ambda 并不会带来程序运行效率的提高，只会使代码更简洁。lambda是为了减少单行函数而存在的]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode]]></title>
    <url>%2F2017%2F12%2F13%2Fleetcode%2F</url>
    <content type="text"><![CDATA[(Array)Two sum**Q:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.** Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 给定一个数组和一个特定的数字，找出这个数组中两个和为该数字的index.（假定只有一组解） Sample solution:123456789def twoSum(self, nums, target): if len(nums) &lt;= 1: return False buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i 思路：建立一个字典并遍历数组，存入键[和-加数1] = [加数1.index],遍历寻找加数2使得(和-加数1=加数2)，输出[加数1.index,加数2.index] (Array)Reverse IntegerQ:Given a 32-bit signed integer, reverse digits of an integer.Example 1:12Input: 123Output: 321 Example 2:12Input: -123Output: -321 Example 3:12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. My Answer:12345678910111213141516171819class Solution: def reverse(self, nums): if len(str(nums))&gt;0 and nums != 0 and nums &lt;= math.pow(2,31): nums = str(nums) newStr = '' # len(nums)-1 to -1 , -1 not included , interval is -1 for i in range(len(nums)-1,-1,-1): newStr = newStr + nums[i] print(newStr) while newStr[0] == '0': newStr= newStr[1:] if newStr[-1]=='-': newStr='-'+newStr[:len(newStr)-1] if math.fabs(int(newStr)) &gt;= math.pow(2,31): return 0 else: return(int(newStr)) else: return 0 思路：主要注意几点1.32位有符号整数范围判断2.逆序以后0的处理3.切片时注意索引是否会超范围，也就是只输入0的情况4.对于是否为负的处理 (Array)Palindrome Number判断是否是回文数字注意1.负数不为回文数2.不能转为字符串，因为不能使用额外空间，这样空间复杂度将为线性 Mysolution:123456789101112131415class Solution: def isPalindrome(self, nums): if nums &lt; 0: return False if nums&lt; 10: return True else: length = 1 while math.pow(10,length) &lt;= nums: length+=1 for i in range(math.ceil(length/2)): status = math.isclose((math.floor(nums/math.pow(10,i))%10),(math.floor(nums/math.pow(10,length-i-1))%10),abs_tol = 0.5) if status == False: return status return True Hint: 先获取整数的长度，然后依次比较左右两端的数字，我在这里用的math.isclose并指定了绝对距离，因为对python中的精度损失理解不深，先这样模糊处理了。 (Array)Non-decreasing Array非下降数组Q:Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n).Example 1:1234567Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 123Input: [4,2,1]Output: FalseExplanation: You can't get a non-decreasing array by modify at most one element. Note:The n belongs to [1, 10,000]. 题意:给定一个数组，判断只修改一个数字（或不修改）是否可以让数组变为非下降数组。 Mysolution: 123456789101112class Solution: def checkPossibility(self, nums): num1 = nums.copy() num2 = nums.copy() if len(nums)==1: return True for i in range(len(nums)-1): if nums[i]&gt;nums[i+1]: num1[i] = num1[i+1] num2[i+1] = num2[i] break return num1==sorted(num1) or num2==sorted(num2) 借鉴了Discuss里 -Yangshun的思路:First, find a pair where the order is wrong. Then there are two possibilities, either the first in the pair can be modified or the second can be modified to create a valid sequence. We simply modify both of them and check for validity of the modified arrays by comparing with the array after sorting. (Array)k-diff Pairs in an ArrayQ:Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.Example 1:1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2:123Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3:123Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). 注意1.(1,3),(3,1)属于同一个数值对2.k为负的时候返回03.注意处理k=0的情况4.不要使用循环嵌套，必超时 Mysolution 1234567# 精简版class Solution: def findPairs(self, nums, k): if k&lt;0:return 0 #if k==0:return len(set(list(filter(lambda x:nums.count(x)&gt;1,nums)))) if k==0:return sum(v&gt;1 for v in collections.Counter(nums).values()) return len(set(sorted(nums)) &amp; set(map(lambda x:x+k,nums))) 12345678910# 这样写会好理解一些class Solution: def findPairs(self, nums, k): if k&lt;0:return 0 if k==0:return sum(v&gt;1 for v in collections.Counter(nums).values()) #nums = list(filter(lambda x:nums.count(x)&gt;1,nums)) #return len(set(nums)) nums = set(sorted(nums)) nums1 = set(map(lambda x:x+k,nums)) return len(nums &amp; nums1) 思路：将数组中每个数+k后与原数组取交集 (Hash Table)Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n.计算小于正整数n的素数的个数 1234567891011121314151617181920def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt; 3: return 0 # 一个长度为n的，值为True的list primes = [True] * n # 前两位置为False 0和1 都不是素数，最小的素数是2 primes[0] = primes[1] = False for i in range(2, int(n ** 0.5) + 1): # 原始数组是全置为素数的，每一次的置False操作都会保证下一个Ture的数为质数 # 因为如果不是素数的话，那么肯定会被它小的数整数，而这些比它小的数已经做过倍数置False处理了 if primes[i]: # 从i平方 到 n ，步长为i 都置为false，因为i从2开始，是i的倍数的整数肯定不是素数 # 这里从 i * i 开始置False是因为i*1,i*2...i*i-1已经被以前的数计算过了，比如i=2的时候，会计算2*i,所以不必计算i*2了 primes[i * i: n: i] = [False] * len(primes[i * i: n: i]) # 返回剩余的True的个数 return sum(primes) 这个算法实现的是埃拉托斯特尼筛法：算法的核心思想是：要得到自然数n以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。（代码的实现注释的已经很清楚了） (Array)Insert Delete GetRandom O(1)Description:Design a data structure that supports all following operations in average O(1) time. 1.insert(val) ：Inserts an item val to the set if not already present. 2.remove(val) Removes an item val from the set if present. 3.getRandomReturns a random element from current set of elements. Each element must have the same probability of being returned. Example：1234567891011121314151617181920212223// Init an empty set.RandomizedSet randomSet = new RandomizedSet();// Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);// Returns false as 2 does not exist in the set.randomSet.remove(2);// Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);// getRandom should return either 1 or 2 randomly.randomSet.getRandom();// Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);// 2 was already in the set, so return false.randomSet.insert(2);// Since 2 is the only number in the set, getRandom always return 2.randomSet.getRandom(); My Solution*12345678910111213141516171819202122232425262728293031323334353637from random import choiceclass RandomizedSet: def __init__(self): """ Initialize your data structure here. """ self.Rset,self.Rlist = set(),[] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val in self.Rset: return False else: self.Rset.add(val) self.Rlist.append(val) return True def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.Rset: self.Rset.remove(val) self.Rlist.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return choice(self.Rlist) 思路:用到了集合这个数据结构，只需要注意一点就是集合是非irerative的，所以引入了一个list来用choice函数返回随机元素再添加一个discuss里用字典和list来实现的代码，更快一些：1234567891011121314151617181920212223class RandomizedSet(object): def __init__(self): self.nums, self.pos = [], &#123;&#125; def insert(self, val): if val not in self.pos: self.nums.append(val) self.pos[val] = len(self.nums) - 1 return True return False def remove(self, val): if val in self.pos: idx, last = self.pos[val], self.nums[-1] self.nums[idx], self.pos[last] = last, idx self.nums.pop(); self.pos.pop(val, 0) return True return False def getRandom(self): return self.nums[random.randint(0, len(self.nums) - 1)]]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监督学习 半监督学习 非监督学习 强化学习]]></title>
    <url>%2F2017%2F11%2F29%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[监督学习 监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同） –李航《统计学习方法》 监督学习通常有标注好的训练集，通过这份训练集可以根据某个评价函数训练出最优的模型，从而对于每一个输入，该模型都能够在当前的评价体系下给出一个相对较优的输出。 特点： 有标注好的训练样本 有输入有输出 通常的任务为分类和回归以及标注 常用的监督学习算法 K近邻算法（KNN） 决策树 （Decision Tree） 朴素贝叶斯（Naive Bayesian） 逻辑回归（Logistic Regression） 这里只罗列了几种最基础的算法，通常在实际应用或数据挖掘比赛中人们会采用更为复杂的集成算法。 非监督学习非监督学习没有任何训练样本，直接对数据进行建模，举个例子来说，数据中有大量的地理位置信息比如经纬度，就可以对经纬度进行无监督学习，把地理位置相近的分在一起，这在无监督学习中叫做聚类 特点： 没有训练样本 主要任务是聚类 半监督学习半监督学习就和它的名字一样，同时具备监督学习和非监督学习的特征和方法，它的数据中有标注好的训练样本，也有没有标注的样本。举个半监督学习的例子： 图中有两个标注好的训练样本，绿色的是没有标注的样本，如果按照监督学习的方法，例如SVM模型会按照左边所示来进行分类，然而实际的数据情况如右图所示，所以实际上应该按照右图所示进行划分，这也就是半监督学习的基本原理：想办法如何同时利用标注好的数据和没有标注的数据。 特点： 既有标注好的训练样本也有未标注的样本 强化学习首先上一个很普遍的用来描述强化学习的图片： 解释：训练实体(Agent)不断地采取行动(action), 之后转到下一个状态(State), 并且获得一个回报(reward), 从而进一步更新训练实体Agent. 就像要训练小老鼠走出迷宫, 你可以在迷宫的几个关键地点放上奶酪, 这些奶酪就是算法中的回报(reward)了, 剩下你只要坐着等小老鼠走出迷宫啦: 再举个例子： 假设1:你是第一次撩妹。那么你会去求教他人，逛各种论坛，总之收集大量相关知识。这个过程就是experience data。利用离线数据来train一个model。 假设2:过去你有很多撩妹经验。你似乎又发现总是按照套路来并不能成功。嗯，经典的探索与利用问题，于是你尝试了其他方法，你发现获得了更好的效果。嗯，more optimal policy 将上述过程对应到RL中：action：你的行为state：你观察到的妹子的状态reward：妹子的反应：开心or不开心至此，一个RL的基本模型已经建立。 参考链接 https://www.zhihu.com/question/31140846/answer/94703351 http://nooverfit.com/wp/15-%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0101-%E9%97%AA%E7%94%B5%E5%85%A5%E9%97%A8-reinforcement-learning/ https://www.zhihu.com/question/31140846]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
